From ed2989dc05405ce1a59f038d81a0fcc20caba0f7 Mon Sep 17 00:00:00 2001
From: Jaehoon Lee <jaehoon85.lee@lge.com>
Date: Thu, 25 Apr 2019 10:19:25 +0000
Subject: [PATCH] Update eglfs_kms to render on topmost drmplane

:Release Notes:
Update eglfs_kms to render on topmost drmplane

:Detailed Notes:
eglfs_kms screens directly write to scanout buffer
a.k.a crtc plane. This causes graphics to display
behind video overlays. With this CL graphics will
use the topmost plane for all crtcs.

:Testing Performed:
Tested with modetest app to to display patterns on
lower planes to confirm that LSM displays above all
the patterns on HDMI output.

:QA Notes:

:Issues Addressed:
[PLAT-41583] Support output resolution change on webOS RPi

Change-Id: Ife73ec8bcbec51af2ab136ac31a5f1c393f449f5
Upstream-Status: Inappropriate [webOS specific]
---
 src/platformsupport/kmsconvenience/qkmsdevice.cpp  |  9 ++---
 .../eglfs_kms/qeglfskmsgbmintegration.cpp          |  2 +-
 .../eglfs_kms/qeglfskmsgbmscreen.cpp               | 39 +++++++---------------
 3 files changed, 16 insertions(+), 34 deletions(-)

diff --git a/src/platformsupport/kmsconvenience/qkmsdevice.cpp b/src/platformsupport/kmsconvenience/qkmsdevice.cpp
index ee2367d..9919af4 100644
--- a/src/platformsupport/kmsconvenience/qkmsdevice.cpp
+++ b/src/platformsupport/kmsconvenience/qkmsdevice.cpp
@@ -425,6 +425,9 @@ QPlatformScreen *QKmsDevice::createScreenForConnector(drmModeResPtr resources,
         }
     }
 
+    output.wants_forced_plane = true;
+    output.forced_plane_id = output.available_planes.back().id;
+
     m_crtc_allocator |= (1 << output.crtc_index);
 
     vinfo->output = output;
@@ -872,12 +875,6 @@ void QKmsScreenConfig::loadConfig()
 void QKmsOutput::restoreMode(QKmsDevice *device)
 {
     if (mode_set && saved_crtc) {
-        drmModeSetCrtc(device->fd(),
-                       saved_crtc->crtc_id,
-                       saved_crtc->buffer_id,
-                       0, 0,
-                       &connector_id, 1,
-                       &saved_crtc->mode);
         mode_set = false;
     }
 }
diff --git a/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmintegration.cpp b/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmintegration.cpp
index 5ed2e0e..b2bfd73 100644
--- a/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmintegration.cpp
+++ b/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmintegration.cpp
@@ -103,7 +103,7 @@ EGLNativeWindowType QEglFSKmsGbmIntegration::createNativeOffscreenWindow(const Q
 
     gbm_surface *surface = gbm_surface_create(static_cast<QEglFSKmsGbmDevice *>(device())->gbmDevice(),
                                               1, 1,
-                                              GBM_FORMAT_XRGB8888,
+                                              GBM_FORMAT_ARGB8888,
                                               GBM_BO_USE_RENDERING);
 
     return reinterpret_cast<EGLNativeWindowType>(surface);
diff --git a/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmscreen.cpp b/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmscreen.cpp
index 1b52bdf..087a2cc 100644
--- a/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmscreen.cpp
+++ b/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmscreen.cpp
@@ -285,39 +285,24 @@ void QEglFSKmsGbmScreen::flip()
     }
 
     FrameBuffer *fb = framebufferForBufferObject(m_gbm_bo_next);
-    ensureModeSet(fb->fb);
+    //ensureModeSet(fb->fb);
 
-    QKmsOutput &op(output());
-    const int fd = device()->fd();
-    m_flipPending = true;
-    int ret = drmModePageFlip(fd,
-                              op.crtc_id,
-                              fb->fb,
-                              DRM_MODE_PAGE_FLIP_EVENT,
-                              this);
-    if (ret) {
-        qErrnoWarning("Could not queue DRM page flip on screen %s", qPrintable(name()));
-        m_flipPending = false;
-        gbm_surface_release_buffer(m_gbm_surface, m_gbm_bo_next);
-        m_gbm_bo_next = nullptr;
-        return;
-    }
+    uint32_t width = gbm_bo_get_width(m_gbm_bo_next);
+    uint32_t height = gbm_bo_get_height(m_gbm_bo_next);
+
+    int ret =  drmModeSetPlane(device()->fd(), output().forced_plane_id, output().crtc_id, fb->fb,
+                               0, 0, 0, width, height, 0 << 16,
+                               0 << 16, output().saved_crtc->width<<16, output().saved_crtc->height<<16);
 
     for (CloneDestination &d : m_cloneDests) {
         if (d.screen != this) {
-            d.screen->ensureModeSet(fb->fb);
-            d.cloneFlipPending = true;
-            int ret = drmModePageFlip(fd,
-                                      d.screen->output().crtc_id,
-                                      fb->fb,
-                                      DRM_MODE_PAGE_FLIP_EVENT,
-                                      d.screen);
-            if (ret) {
-                qErrnoWarning("Could not queue DRM page flip for clone screen %s", qPrintable(name()));
-                d.cloneFlipPending = false;
-            }
+            int ret =  drmModeSetPlane(device()->fd(), d.screen->output().forced_plane_id, d.screen->output().crtc_id, fb->fb,
+                                       0, 0, 0, width, height, 0 << 16,
+                                       0 << 16, d.screen->output().saved_crtc->width<<16, d.screen->output().saved_crtc->height<<16);
         }
     }
+
+    flipFinished();
 }
 
 void QEglFSKmsGbmScreen::pageFlipHandler(int fd, unsigned int sequence, unsigned int tv_sec, unsigned int tv_usec, void *user_data)
