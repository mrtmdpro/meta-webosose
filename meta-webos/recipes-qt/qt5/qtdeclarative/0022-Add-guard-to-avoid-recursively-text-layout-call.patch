From 30d8297541f57c1a4e2a23dd4f83ac9233197f94 Mon Sep 17 00:00:00 2001
From: Valery Volgutov <valery.volgutov@lge.com>
Date: Thu, 26 Jul 2018 13:01:20 +0900
Subject: [PATCH] Add guard to avoid recursively text layout call

setupTextLayout can be called twice or more times recursively.
When this function call and do q->setImplicitSize
function call. This function set implicit width and height
and after that emit some signals. After that we can to
enter in setupTextLayout again and full passed it.
After second setupTextLayout passed - QTextEngine clear self
data (lines). When we return to first setupTextLayout
we have incorrect data for text engine and crash occurs in

    QTextLine firstLine = visibleCount == 1 && elideLayout
            ? elideLayout->lineAt(0)
            : layout.lineAt(0);
    Q_ASSERT(firstLine.isValid());
    *baseline = firstLine.y() <--- HERE + firstLine.ascent();

because firstLine::y try to access to lines which cleared
previously.

Upstream-Status: Submitted [https://codereview.qt-project.org/#/c/235313/]
---
 src/quick/items/qquicktext.cpp   | 6 +++++-
 src/quick/items/qquicktext_p_p.h | 1 +
 2 files changed, 6 insertions(+), 1 deletion(-)

diff --git a/src/quick/items/qquicktext.cpp b/src/quick/items/qquicktext.cpp
index 76720e5c5..05f72e0a9 100644
--- a/src/quick/items/qquicktext.cpp
+++ b/src/quick/items/qquicktext.cpp
@@ -88,6 +88,7 @@ QQuickTextPrivate::QQuickTextPrivate()
     , truncated(false), hAlignImplicit(true), rightToLeftText(false)
     , layoutTextElided(false), textHasChanged(true), needToUpdateLayout(false), formatModifiesFontSize(false)
     , polishSize(false)
+    , layoutInProgress(false)
 {
     implicitAntialiasing = true;
 }
@@ -648,7 +649,7 @@ QRectF QQuickTextPrivate::setupTextLayout(qreal *const baseline)
             && q->widthValid()
             && (q->heightValid() || maximumLineCountValid);
 
-    if ((!requireImplicitSize || (implicitWidthValid && implicitHeightValid))
+    if (layoutInProgress || (!requireImplicitSize || (implicitWidthValid && implicitHeightValid))
             && ((singlelineElide && availableWidth() <= 0.)
                 || (multilineElide && q->heightValid() && availableHeight() <= 0.))) {
         // we are elided and we have a zero width or height
@@ -674,6 +675,7 @@ QRectF QQuickTextPrivate::setupTextLayout(qreal *const baseline)
         *baseline = fm.ascent();
         return QRectF(0, 0, 0, height);
     }
+    layoutInProgress = true;
 
     bool shouldUseDesignMetrics = renderType != QQuickText::NativeRendering;
     if (extra.isAllocated())
@@ -1131,6 +1133,8 @@ QRectF QQuickTextPrivate::setupTextLayout(qreal *const baseline)
     if (truncated != wasTruncated)
         emit q->truncatedChanged();
 
+    layoutInProgress = false;
+
     return br;
 }
 
diff --git a/src/quick/items/qquicktext_p_p.h b/src/quick/items/qquicktext_p_p.h
index b0b1492d5..cc21d7948 100644
--- a/src/quick/items/qquicktext_p_p.h
+++ b/src/quick/items/qquicktext_p_p.h
@@ -174,6 +174,7 @@ public:
     bool needToUpdateLayout:1;
     bool formatModifiesFontSize:1;
     bool polishSize:1; // Workaround for problem with polish called after updateSize (QTBUG-42636)
+    bool layoutInProgress:1; // Do not do layout again if previous call is not completed
 
     static const QChar elideChar;
 
