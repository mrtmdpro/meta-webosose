From 75f19185926747e9242f9e55c5a3726702825c14 Mon Sep 17 00:00:00 2001
From: Lauren Jeong <jy.jeong@lge.com>
Date: Fri, 27 Jul 2018 13:19:48 +0900
Subject: [PATCH] Add 'webos' into the target OS list

- TARGET_OS "webos" is added
- IP adapter for network monitoring is implemented
- Introduce PmLog for IoTivity over webos
- Provisioning library is included
- Crash with iotivity-node application is fixed
- Build error due to RD_MODE=all is fixed
- ACG (Access Control Group) configuration file for
  sample application is added
- Procedure for registering/Unregistering luna service
  is implemented
- Internal function for getting LSHandle is implemented
- ocserverbasicops & occlientbasicops for webos
  is implemented (built from separate folder)
- IoTivity sampler(iotivity-node) for webOS is implemented
- Set native application path to /usr/palm/services

Bug: https://jira.iotivity.org/browse/IOT-2967
Change-Id: I3f4f143e7f528e873e5758410e226d98b2679151
Signed-off-by: sungmok.shin <sungmok.shin@lge.com>
---
 Readme.scons.txt                                   |    8 +
 bridging/SConscript                                |    2 +-
 bridging/mpm_client/SConscript                     |    4 +-
 build_common/SConscript                            |   16 +-
 plugins/SConscript                                 |    2 +-
 plugins/unittests/SConscript                       |    2 +-
 resource/SConscript                                |    2 +-
 resource/csdk/connectivity/inc/caadapterutils.h    |   27 +
 resource/csdk/connectivity/inc/caipinterface.h     |   10 +
 resource/csdk/connectivity/src/SConscript          |   18 +-
 .../src/adapter_util/webos/caadapterutils.c        |  586 ++++++++
 .../csdk/connectivity/src/ip_adapter/caipadapter.c |    4 +
 .../connectivity/src/ip_adapter/webos/SConscript   |   35 +
 .../src/ip_adapter/webos/caipnwmonitor.c           |  672 ++++++++++
 resource/csdk/logger/SConscript                    |    5 +
 resource/csdk/logger/src/logger.c                  |   98 +-
 resource/csdk/resource-directory/SConscript        |    4 +-
 resource/csdk/security/SConscript                  |    9 +-
 resource/csdk/security/provisioning/src/SConscript |    2 +-
 resource/csdk/stack/SConscript                     |    8 +-
 resource/csdk/stack/samples/SConscript             |    5 +
 .../webos/com.example.app.iotivity/appinfo.json    |   11 +
 .../com.example.app.iotivity/npm-shrinkwrap.json   |  258 ++++
 .../webos/com.example.app.iotivity/package.json    |   45 +
 .../client-lowlevel.js                             |  249 ++++
 .../com.example.service.iotivity.client/client.txt |  310 +++++
 .../com.example.service.iotivity.client.json       |    3 +
 .../com.example.service.iotivity.client.api.json   |   14 +
 ...m.example.service.iotivity.client.manifest.json |   13 +
 .../com.example.service.iotivity.client.perm.json  |    3 +
 .../com.example.service.iotivity.client.role.json  |   12 +
 .../com.example.service.iotivity.client.service    |   23 +
 .../com.example.service.iotivity.client/main.js    |  474 +++++++
 .../oic_svr_db_client.json                         |   61 +
 .../package.json                                   |    4 +
 .../com.example.service.iotivity.server.json       |    3 +
 .../com.example.service.iotivity.server.api.json   |   12 +
 ...m.example.service.iotivity.server.manifest.json |   13 +
 .../com.example.service.iotivity.server.perm.json  |    3 +
 .../com.example.service.iotivity.server.role.json  |   11 +
 .../com.example.service.iotivity.server.service    |   23 +
 .../com.example.service.iotivity.server/main.js    |  273 ++++
 .../mock-sensor.js                                 |   59 +
 .../oic_svr_db_server.json                         |   90 ++
 .../package.json                                   |    4 +
 .../server-lowlevel.js                             |  228 ++++
 .../com.example.service.iotivity.server/server.txt |  167 +++
 .../webos/com.example.app.iotivity/src/App/App.js  |   26 +
 .../com.example.app.iotivity/src/App/package.json  |    3 +
 .../src/actions/ActionCreators.js                  |  269 ++++
 .../src/actions/ActionTypes.js                     |   10 +
 .../webos/com.example.app.iotivity/src/index.js    |   40 +
 .../src/reducer/Reducer.js                         |   45 +
 .../com.example.app.iotivity/src/views/Client.js   |  204 +++
 .../src/views/MainPanel.js                         |   31 +
 .../com.example.app.iotivity/src/views/Server.js   |  186 +++
 .../csdk/stack/samples/webos/secure/SConscript     |   24 +
 .../csdk/stack/samples/webos/secure/common.cpp     |  143 ++
 resource/csdk/stack/samples/webos/secure/common.h  |   36 +
 .../secure/files/sysbus/occlientbasicops.api.json  |    2 +
 .../files/sysbus/occlientbasicops.manifest.json    |   16 +
 .../secure/files/sysbus/occlientbasicops.perm.json |    5 +
 .../secure/files/sysbus/occlientbasicops.role.json |   11 +
 .../secure/files/sysbus/occlientbasicops.service   |   24 +
 .../secure/files/sysbus/ocserverbasicops.api.json  |    2 +
 .../files/sysbus/ocserverbasicops.manifest.json    |   16 +
 .../secure/files/sysbus/ocserverbasicops.perm.json |    5 +
 .../secure/files/sysbus/ocserverbasicops.role.json |   11 +
 .../secure/files/sysbus/ocserverbasicops.service   |   24 +
 .../webos/secure/occlientbasicops/SConscript       |  107 ++
 .../webos/secure/occlientbasicops/logging.h        |   69 +
 .../secure/occlientbasicops/occlientbasicops.cpp   |  612 +++++++++
 .../secure/occlientbasicops/occlientbasicops.h     |  108 ++
 .../oic_svr_db_client_devowner.json                |   61 +
 .../oic_svr_db_client_nondevowner.json             |   61 +
 .../occlientbasicops/sample_payload_logging.h      |  356 +++++
 .../webos/secure/ocserverbasicops/SConscript       |   98 ++
 .../webos/secure/ocserverbasicops/logging.h        |   69 +
 .../secure/ocserverbasicops/ocserverbasicops.cpp   |  451 +++++++
 .../secure/ocserverbasicops/ocserverbasicops.h     |   77 ++
 .../secure/ocserverbasicops/oic_svr_db_server.json |   90 ++
 .../csdk/stack/samples/webos/unsecure/SConscript   |   24 +
 .../csdk/stack/samples/webos/unsecure/common.cpp   |   99 ++
 .../csdk/stack/samples/webos/unsecure/common.h     |   29 +
 .../samples/webos/unsecure/device_properties.json  |    5 +
 .../webos/unsecure/files/sysbus/occlient.api.json  |    2 +
 .../unsecure/files/sysbus/occlient.manifest.json   |   16 +
 .../webos/unsecure/files/sysbus/occlient.perm.json |    5 +
 .../webos/unsecure/files/sysbus/occlient.role.json |   11 +
 .../webos/unsecure/files/sysbus/occlient.service   |   24 +
 .../webos/unsecure/files/sysbus/ocserver.api.json  |    2 +
 .../unsecure/files/sysbus/ocserver.manifest.json   |   16 +
 .../webos/unsecure/files/sysbus/ocserver.perm.json |    5 +
 .../webos/unsecure/files/sysbus/ocserver.role.json |   11 +
 .../webos/unsecure/files/sysbus/ocserver.service   |   24 +
 .../samples/webos/unsecure/introspection.json      |  272 ++++
 .../samples/webos/unsecure/occlient/SConscript     |   90 ++
 .../samples/webos/unsecure/occlient/logging.h      |   69 +
 .../samples/webos/unsecure/occlient/occlient.cpp   | 1415 ++++++++++++++++++++
 .../samples/webos/unsecure/occlient/occlient.h     |  160 +++
 .../unsecure/occlient/sample_payload_logging.h     |  356 +++++
 .../samples/webos/unsecure/ocserver/SConscript     |   90 ++
 .../samples/webos/unsecure/ocserver/logging.h      |   69 +
 .../samples/webos/unsecure/ocserver/ocserver.cpp   | 1387 +++++++++++++++++++
 .../samples/webos/unsecure/ocserver/ocserver.h     |  130 ++
 resource/provisioning/SConscript                   |    4 +-
 resource/src/SConscript                            |    4 +-
 107 files changed, 11463 insertions(+), 33 deletions(-)
 create mode 100644 resource/csdk/connectivity/src/adapter_util/webos/caadapterutils.c
 create mode 100644 resource/csdk/connectivity/src/ip_adapter/webos/SConscript
 create mode 100644 resource/csdk/connectivity/src/ip_adapter/webos/caipnwmonitor.c
 create mode 100644 resource/csdk/stack/samples/webos/com.example.app.iotivity/appinfo.json
 create mode 100644 resource/csdk/stack/samples/webos/com.example.app.iotivity/npm-shrinkwrap.json
 create mode 100644 resource/csdk/stack/samples/webos/com.example.app.iotivity/package.json
 create mode 100644 resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.client/client-lowlevel.js
 create mode 100644 resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.client/client.txt
 create mode 100644 resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.client/com.example.service.iotivity.client.json
 create mode 100644 resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.client/files/sysbus/com.example.service.iotivity.client.api.json
 create mode 100644 resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.client/files/sysbus/com.example.service.iotivity.client.manifest.json
 create mode 100644 resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.client/files/sysbus/com.example.service.iotivity.client.perm.json
 create mode 100644 resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.client/files/sysbus/com.example.service.iotivity.client.role.json
 create mode 100644 resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.client/files/sysbus/com.example.service.iotivity.client.service
 create mode 100644 resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.client/main.js
 create mode 100644 resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.client/oic_svr_db_client.json
 create mode 100644 resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.client/package.json
 create mode 100644 resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/com.example.service.iotivity.server.json
 create mode 100644 resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/files/sysbus/com.example.service.iotivity.server.api.json
 create mode 100644 resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/files/sysbus/com.example.service.iotivity.server.manifest.json
 create mode 100644 resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/files/sysbus/com.example.service.iotivity.server.perm.json
 create mode 100644 resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/files/sysbus/com.example.service.iotivity.server.role.json
 create mode 100644 resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/files/sysbus/com.example.service.iotivity.server.service
 create mode 100644 resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/main.js
 create mode 100644 resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/mock-sensor.js
 create mode 100644 resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/oic_svr_db_server.json
 create mode 100644 resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/package.json
 create mode 100644 resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/server-lowlevel.js
 create mode 100644 resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/server.txt
 create mode 100644 resource/csdk/stack/samples/webos/com.example.app.iotivity/src/App/App.js
 create mode 100755 resource/csdk/stack/samples/webos/com.example.app.iotivity/src/App/package.json
 create mode 100644 resource/csdk/stack/samples/webos/com.example.app.iotivity/src/actions/ActionCreators.js
 create mode 100644 resource/csdk/stack/samples/webos/com.example.app.iotivity/src/actions/ActionTypes.js
 create mode 100644 resource/csdk/stack/samples/webos/com.example.app.iotivity/src/index.js
 create mode 100644 resource/csdk/stack/samples/webos/com.example.app.iotivity/src/reducer/Reducer.js
 create mode 100644 resource/csdk/stack/samples/webos/com.example.app.iotivity/src/views/Client.js
 create mode 100644 resource/csdk/stack/samples/webos/com.example.app.iotivity/src/views/MainPanel.js
 create mode 100644 resource/csdk/stack/samples/webos/com.example.app.iotivity/src/views/Server.js
 create mode 100644 resource/csdk/stack/samples/webos/secure/SConscript
 create mode 100644 resource/csdk/stack/samples/webos/secure/common.cpp
 create mode 100644 resource/csdk/stack/samples/webos/secure/common.h
 create mode 100644 resource/csdk/stack/samples/webos/secure/files/sysbus/occlientbasicops.api.json
 create mode 100644 resource/csdk/stack/samples/webos/secure/files/sysbus/occlientbasicops.manifest.json
 create mode 100644 resource/csdk/stack/samples/webos/secure/files/sysbus/occlientbasicops.perm.json
 create mode 100644 resource/csdk/stack/samples/webos/secure/files/sysbus/occlientbasicops.role.json
 create mode 100644 resource/csdk/stack/samples/webos/secure/files/sysbus/occlientbasicops.service
 create mode 100644 resource/csdk/stack/samples/webos/secure/files/sysbus/ocserverbasicops.api.json
 create mode 100644 resource/csdk/stack/samples/webos/secure/files/sysbus/ocserverbasicops.manifest.json
 create mode 100644 resource/csdk/stack/samples/webos/secure/files/sysbus/ocserverbasicops.perm.json
 create mode 100644 resource/csdk/stack/samples/webos/secure/files/sysbus/ocserverbasicops.role.json
 create mode 100644 resource/csdk/stack/samples/webos/secure/files/sysbus/ocserverbasicops.service
 create mode 100644 resource/csdk/stack/samples/webos/secure/occlientbasicops/SConscript
 create mode 100644 resource/csdk/stack/samples/webos/secure/occlientbasicops/logging.h
 create mode 100644 resource/csdk/stack/samples/webos/secure/occlientbasicops/occlientbasicops.cpp
 create mode 100644 resource/csdk/stack/samples/webos/secure/occlientbasicops/occlientbasicops.h
 create mode 100644 resource/csdk/stack/samples/webos/secure/occlientbasicops/oic_svr_db_client_devowner.json
 create mode 100644 resource/csdk/stack/samples/webos/secure/occlientbasicops/oic_svr_db_client_nondevowner.json
 create mode 100644 resource/csdk/stack/samples/webos/secure/occlientbasicops/sample_payload_logging.h
 create mode 100644 resource/csdk/stack/samples/webos/secure/ocserverbasicops/SConscript
 create mode 100644 resource/csdk/stack/samples/webos/secure/ocserverbasicops/logging.h
 create mode 100644 resource/csdk/stack/samples/webos/secure/ocserverbasicops/ocserverbasicops.cpp
 create mode 100644 resource/csdk/stack/samples/webos/secure/ocserverbasicops/ocserverbasicops.h
 create mode 100644 resource/csdk/stack/samples/webos/secure/ocserverbasicops/oic_svr_db_server.json
 create mode 100644 resource/csdk/stack/samples/webos/unsecure/SConscript
 create mode 100644 resource/csdk/stack/samples/webos/unsecure/common.cpp
 create mode 100644 resource/csdk/stack/samples/webos/unsecure/common.h
 create mode 100644 resource/csdk/stack/samples/webos/unsecure/device_properties.json
 create mode 100644 resource/csdk/stack/samples/webos/unsecure/files/sysbus/occlient.api.json
 create mode 100644 resource/csdk/stack/samples/webos/unsecure/files/sysbus/occlient.manifest.json
 create mode 100644 resource/csdk/stack/samples/webos/unsecure/files/sysbus/occlient.perm.json
 create mode 100644 resource/csdk/stack/samples/webos/unsecure/files/sysbus/occlient.role.json
 create mode 100644 resource/csdk/stack/samples/webos/unsecure/files/sysbus/occlient.service
 create mode 100644 resource/csdk/stack/samples/webos/unsecure/files/sysbus/ocserver.api.json
 create mode 100644 resource/csdk/stack/samples/webos/unsecure/files/sysbus/ocserver.manifest.json
 create mode 100644 resource/csdk/stack/samples/webos/unsecure/files/sysbus/ocserver.perm.json
 create mode 100644 resource/csdk/stack/samples/webos/unsecure/files/sysbus/ocserver.role.json
 create mode 100644 resource/csdk/stack/samples/webos/unsecure/files/sysbus/ocserver.service
 create mode 100644 resource/csdk/stack/samples/webos/unsecure/introspection.json
 create mode 100644 resource/csdk/stack/samples/webos/unsecure/occlient/SConscript
 create mode 100644 resource/csdk/stack/samples/webos/unsecure/occlient/logging.h
 create mode 100644 resource/csdk/stack/samples/webos/unsecure/occlient/occlient.cpp
 create mode 100644 resource/csdk/stack/samples/webos/unsecure/occlient/occlient.h
 create mode 100644 resource/csdk/stack/samples/webos/unsecure/occlient/sample_payload_logging.h
 create mode 100644 resource/csdk/stack/samples/webos/unsecure/ocserver/SConscript
 create mode 100644 resource/csdk/stack/samples/webos/unsecure/ocserver/logging.h
 create mode 100644 resource/csdk/stack/samples/webos/unsecure/ocserver/ocserver.cpp
 create mode 100644 resource/csdk/stack/samples/webos/unsecure/ocserver/ocserver.h

diff --git a/Readme.scons.txt b/Readme.scons.txt
index 5d92938..73c2a57 100644
--- a/Readme.scons.txt
+++ b/Readme.scons.txt
@@ -272,6 +272,14 @@ to run many build combinations with TARGET_OS to 'windows'.
       $ run build -arch x86 -release
 See run.bat for more example usage parameters
 
+webOS:
+ * Possible values for <TARGET_TRANSPORT> are: ALL, IP
+
+IoTivity build for webOS requires webOS build based on the open-embedded build
+framework. So to speak, scons build is not directly triggered by user but by
+the build recipe combinated with build environment. You can check the whole
+procedure for building IoTivity over webOS at https://wiki.iotivity.org/webos.
+
 * Additional options
  * VERBOSE=true or false (Show compilation)
  * RELEASE=true or false (Build for release?)
diff --git a/bridging/SConscript b/bridging/SConscript
index 24d00b7..8071249 100644
--- a/bridging/SConscript
+++ b/bridging/SConscript
@@ -33,7 +33,7 @@ src_dir = env.get('SRC_DIR')
 SConscript(os.path.join(env.get('SRC_DIR'), 'extlibs', 'rapidjson', 'SConscript'))
 
 if target_os not in [
-    'android', 'arduino', 'darwin', 'ios', 'tizen', 'msys_nt', 'windows']:
+    'android', 'arduino', 'darwin', 'ios', 'tizen', 'msys_nt', 'windows', 'webos']:
 
     SConscript(os.path.join('common', 'SConscript'))
 
diff --git a/bridging/mpm_client/SConscript b/bridging/mpm_client/SConscript
index 0b98b42..5b9115a 100644
--- a/bridging/mpm_client/SConscript
+++ b/bridging/mpm_client/SConscript
@@ -49,10 +49,10 @@ mpmclient_env.AppendUnique(LIBS=[
     'm', 'octbstack', 'ocsrm', 'mpmcommon', 'connectivity_abstraction', 'coap', 'curl'
 ])
 
-if target_os in ['linux', 'tizen', 'yocto']:
+if target_os in ['linux', 'tizen', 'yocto', 'webos']:
     mpmclient_env.AppendUnique(LIBS = ['rt'])
 
-if target_os in ['linux', 'tizen']:
+if target_os in ['linux', 'tizen', 'webos']:
     mpmclient_env.ParseConfig('pkg-config --cflags --libs sqlite3')
 else:
     mpmclient_env.AppendUnique(CPPPATH=['#/extlibs/sqlite3'])
diff --git a/build_common/SConscript b/build_common/SConscript
index 954bcc3..cfc752f 100755
--- a/build_common/SConscript
+++ b/build_common/SConscript
@@ -10,7 +10,7 @@ project_version = '1.3.1'
 
 # Map of build host to possible target os
 host_target_map = {
-    'linux': ['linux', 'android', 'arduino', 'yocto', 'tizen'],
+    'linux': ['linux', 'android', 'arduino', 'yocto', 'tizen', 'webos'],
     'windows': ['windows', 'android', 'arduino'],
     'darwin': ['darwin', 'ios', 'android', 'arduino'],
     'msys_nt': ['msys_nt'],
@@ -24,6 +24,7 @@ os_arch_map = {
         'armv6l', 'armv7l'
     ],
     'tizen': ['x86', 'x86_64', 'arm', 'arm-v7a', 'armeabi-v7a', 'arm64'],
+    'webos': ['i586', 'aarch64', 'arm'],
     'android': [
         'x86', 'x86_64', 'armeabi', 'armeabi-v7a', 'armeabi-v7a-hard',
         'arm64-v8a'
@@ -65,6 +66,8 @@ if target_os not in host_target_map[host]:
 # work out a reasonable default for target_arch if not specified by user
 if target_os == 'android':
     default_arch = 'x86'
+elif target_os == 'webos':
+    default_arch = 'arm'
 else:
     default_arch = platform.machine()
     if target_os == 'windows':
@@ -371,7 +374,7 @@ if target_os in targets_support_cc:
         print(tc_set_msg)
 
 # Import env variables only if reproductibility is ensured
-if target_os in ['yocto']:
+if target_os in ['yocto', 'webos']:
     env['CONFIG_ENVIRONMENT_IMPORT'] = True
 else:
     env['CONFIG_ENVIRONMENT_IMPORT'] = False
@@ -654,6 +657,9 @@ if 'ALL' in target_transport:
         env.AppendUnique(CPPDEFINES=[
             'IP_ADAPTER', 'EDR_ADAPTER', 'LE_ADAPTER', 'NFC_ADAPTER'
         ])
+    elif (target_os in ['webos']):
+        env.AppendUnique(CPPDEFINES=[
+            'IP_ADAPTER', 'NO_EDR_ADAPTER', 'NO_LE_ADAPTER'])
     elif (target_os in ['darwin', 'ios', 'msys_nt', 'windows']):
         env.AppendUnique(
             CPPDEFINES=['IP_ADAPTER', 'NO_EDR_ADAPTER', 'NO_LE_ADAPTER'])
@@ -662,7 +668,7 @@ if 'ALL' in target_transport:
             CPPDEFINES=['IP_ADAPTER', 'EDR_ADAPTER', 'LE_ADAPTER'])
 else:
     if ('BT' in target_transport):
-        if (target_os == 'linux'):
+        if target_os in ('linux', 'webos'):
             msg = "CA Transport BT is not supported "
             Exit(msg)
         else:
@@ -682,7 +688,7 @@ else:
 
     if with_tcp:
         if (target_os in [
-                'linux', 'tizen', 'android', 'arduino', 'ios', 'windows'
+                'linux', 'tizen', 'android', 'arduino', 'ios', 'windows', 'webos'
         ]):
             env.AppendUnique(CPPDEFINES=['TCP_ADAPTER', 'WITH_TCP'])
         else:
@@ -733,7 +739,7 @@ env.SConscript('external_builders.scons')
 ######################################################################
 # Link scons to Yocto cross-toolchain ONLY when target_os is yocto
 ######################################################################
-if target_os == "yocto":
+if target_os in ['yocto', 'webos']:
     '''
     This code injects Yocto cross-compilation tools+flags into the scons
     construction environment in order to invoke the relevant tools while
diff --git a/plugins/SConscript b/plugins/SConscript
index 3decb72..c2e03f0 100644
--- a/plugins/SConscript
+++ b/plugins/SConscript
@@ -30,7 +30,7 @@ build_sample = env.get('BUILD_SAMPLE')
 src_dir = env.get('SRC_DIR')
 
 if target_os not in [
-        'android', 'arduino', 'darwin', 'ios', 'tizen', 'msys_nt', 'windows'
+        'android', 'arduino', 'darwin', 'ios', 'tizen', 'msys_nt', 'windows', 'webos'
 ]:
 
     SConscript('zigbee_wrapper/SConscript')
diff --git a/plugins/unittests/SConscript b/plugins/unittests/SConscript
index 8e1ade2..4679931 100644
--- a/plugins/unittests/SConscript
+++ b/plugins/unittests/SConscript
@@ -59,6 +59,6 @@ Alias("piunittests", [piunittests])
 
 unittests_env.AppendTarget('piunittests')
 if unittests_env.get('TEST') == '1':
-    if target_os in ['linux']:
+    if target_os in ['linux', 'webos']:
         run_test(unittests_env, 'plugins_unittests.memcheck',
                  'plugins/unittests/piunittests', piunittests)
diff --git a/resource/SConscript b/resource/SConscript
index 3ec5999..9a751bd 100644
--- a/resource/SConscript
+++ b/resource/SConscript
@@ -54,7 +54,7 @@ if target_os not in ['arduino','darwin','ios','android']:
     # Build examples
     SConscript('examples/SConscript')
 
-if target_os in ['linux', 'windows', 'darwin', 'msys_nt']:
+if target_os in ['linux', 'windows', 'darwin', 'msys_nt', 'webos']:
     if target_os == 'darwin':
         env.Command('#/out/darwin/iotivity-csdk.framework', None, '#/tools/darwin/mkfwk_osx.sh')
 
diff --git a/resource/csdk/connectivity/inc/caadapterutils.h b/resource/csdk/connectivity/inc/caadapterutils.h
index b91581a..f221fbb 100644
--- a/resource/csdk/connectivity/inc/caadapterutils.h
+++ b/resource/csdk/connectivity/inc/caadapterutils.h
@@ -52,6 +52,12 @@
 #include "uarraylist.h"
 #include "cacommonutil.h"
 
+#ifdef __webos__
+#include <luna-service2/lunaservice.h>
+#include <pbnjson.h>
+#include "cathreadpool.h"
+#endif // __webos__
+
 #ifdef __cplusplus
 extern "C"
 {
@@ -330,6 +336,27 @@ void CALogAdapterTypeInfo(CATransportAdapter_t adapter);
 CAResult_t CAGetIpv6AddrScopeInternal(const char *addr, CATransportFlags_t *scopeLevel);
 #endif
 
+#ifdef __webos__
+/**
+ * Initialize Luna service.
+ * @param[in] handle The thread pool structure.
+ * @return CA_STATUS_OK on success, or an appropriate error code on failure.
+ *
+ */
+CAResult_t CAInitializeLS(ca_thread_pool_t handle);
+
+/**
+ * Terminate Luna service.
+ */
+void CATerminateLS();
+
+/**
+ * Get Luna service handle.
+ * @return Luna service handle.
+ */
+LSHandle* CAGetLSHandle();
+#endif // __webos__
+
 #ifdef __cplusplus
 } /* extern "C" */
 #endif
diff --git a/resource/csdk/connectivity/inc/caipinterface.h b/resource/csdk/connectivity/inc/caipinterface.h
index bcf1573..0ad1d49 100644
--- a/resource/csdk/connectivity/inc/caipinterface.h
+++ b/resource/csdk/connectivity/inc/caipinterface.h
@@ -185,6 +185,16 @@ void CAWakeUpForChange();
  */
 void CAIPSetErrorHandler(CAIPErrorHandleCallback errorHandleCallback);
 
+#ifdef __webos__
+/**
+ * Set the thread pool handle for IP monitoring thread.
+ *
+ * @param[in] handle Thread pool handle which is given by above layer
+ *                   for using thread creation task.
+ */
+void CAIPSetMonitorThreadPoolHandle(ca_thread_pool_t handle);
+#endif // __webos__
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/resource/csdk/connectivity/src/SConscript b/resource/csdk/connectivity/src/SConscript
index 9696ea7..0a58110 100644
--- a/resource/csdk/connectivity/src/SConscript
+++ b/resource/csdk/connectivity/src/SConscript
@@ -48,7 +48,10 @@ connectivity_env.SConscript(os.path.join(root_dir, 'util', 'SConscript'), export
 
 build_dir = connectivity_env.get('BUILD_DIR')
 
-connectivity_env.AppendUnique(CA_SRC = [os.path.join(ca_path,'adapter_util/caadapterutils.c')])
+if ca_os in ['webos']:
+    connectivity_env.AppendUnique(CA_SRC = [os.path.join(ca_path,'adapter_util/webos/caadapterutils.c')])
+else:
+    connectivity_env.AppendUnique(CA_SRC = [os.path.join(ca_path,'adapter_util/caadapterutils.c')])
 
 if (('BLE' in ca_transport) or ('ALL' in ca_transport)):
     connectivity_env.AppendUnique(CA_SRC = [os.path.join(ca_path, 'adapter_util/cafragmentation.c')])
@@ -121,7 +124,9 @@ if 'ALL' in ca_transport:
         transports.add('bt_edr_adapter')
         transports.add('bt_le_adapter')
         transports.add('nfc_adapter')
-    elif ca_os in['darwin','ios', 'msys_nt', 'windows']:
+    elif ca_os in ['webos']:
+        transports.add('ip_adapter')
+    elif ca_os in ['darwin', 'ios', 'msys_nt', 'windows']:
         transports.add('ip_adapter')
     else:
         transports.add('ip_adapter')
@@ -145,7 +150,7 @@ if 'BLE' in ca_transport:
 if 'NFC' in ca_transport:
     transports.add('nfc_adapter')
 
-if ca_os in ['linux', 'tizen', 'android', 'ios', 'windows'] and with_tcp:
+if ca_os in ['linux', 'tizen', 'android', 'ios', 'windows', 'webos'] and with_tcp:
     transports.add('tcp_adapter')
 
 SConscript(dirs = list(transports), exports='connectivity_env')
@@ -165,13 +170,18 @@ if ca_os == 'android':
 if connectivity_env.get('SECURED') == '1':
     connectivity_env.AppendUnique(LIBS = ['mbedtls','mbedx509'])
 
+if ca_os in ['webos']:
+    connectivity_env.ParseConfig("pkg-config --cflags --libs glib-2.0")
+    connectivity_env.ParseConfig("pkg-config --cflags --libs luna-service2")
+    connectivity_env.ParseConfig("pkg-config --cflags --libs pbnjson_c")
+
 # c_common calls into mbedcrypto.
 connectivity_env.AppendUnique(LIBS = ['mbedcrypto'])
 
 calib_internal = connectivity_env.StaticLibrary('connectivity_abstraction_internal', connectivity_env.get('CA_SRC'))
 calib = Flatten(calib_internal)
 
-if ca_os in ['android', 'tizen', 'linux', 'yocto']:
+if ca_os in ['android', 'tizen', 'linux', 'yocto', 'webos']:
     connectivity_env.AppendUnique(LIBS = ['coap'])
     if ca_os != 'android':
         connectivity_env.AppendUnique(LIBS = ['rt'])
diff --git a/resource/csdk/connectivity/src/adapter_util/webos/caadapterutils.c b/resource/csdk/connectivity/src/adapter_util/webos/caadapterutils.c
new file mode 100644
index 0000000..0e0e171
--- /dev/null
+++ b/resource/csdk/connectivity/src/adapter_util/webos/caadapterutils.c
@@ -0,0 +1,586 @@
+/******************************************************************
+ *
+ * Copyright (c) 2018 LG Electronics Inc.
+ * Copyright 2014 Samsung Electronics All Rights Reserved.
+ *
+ *
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ******************************************************************/
+
+#include "iotivity_config.h"
+#include "caadapterutils.h"
+
+#include <string.h>
+#include <ctype.h>
+#include "oic_string.h"
+#include "oic_malloc.h"
+#include <errno.h>
+#include <inttypes.h>
+
+#ifdef HAVE_WS2TCPIP_H
+#include <ws2tcpip.h>
+#endif
+#ifdef HAVE_SYS_SOCKET_H
+#include <sys/socket.h>
+#endif
+#ifdef HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#if defined(HAVE_WINSOCK2_H) && defined(HAVE_WS2TCPIP_H)
+#include <winsock2.h>
+#include <ws2tcpip.h>
+#endif
+#ifdef HAVE_NETDB_H
+#include <netdb.h>
+#endif
+#ifdef HAVE_ARPA_INET_H
+#include <arpa/inet.h>
+#endif
+#ifdef HAVE_IN6ADDR_H
+#include <in6addr.h>
+#endif
+
+#ifdef __JAVA__
+#include <jni.h>
+
+/**
+ * @var g_jvm
+ * @brief pointer to store JavaVM
+ */
+static JavaVM *g_jvm = NULL;
+
+#ifdef __ANDROID__
+/**
+ * @var gContext
+ * @brief pointer to store context for android callback interface
+ */
+static jobject g_Context = NULL;
+static jobject g_Activity = NULL;
+#endif
+#endif
+
+#define MAX_LS_NAME_SIZE 1024
+#define MAX_GET_LS_SERVICE_NAME_COUNT 5
+static LSHandle *g_pLSHandle = NULL;
+static GMainContext *g_loopContext = NULL;
+static GMainLoop *g_mainLoop = NULL;
+static bool g_isLSRegistering = false;
+char *g_lsServiceName = NULL;
+
+#define CA_ADAPTER_UTILS_TAG "OIC_CA_ADAP_UTILS"
+
+CAResult_t CAConvertAddrToName(const struct sockaddr_storage *sockAddr, socklen_t sockAddrLen,
+                               char *host, uint16_t *port)
+{
+    VERIFY_NON_NULL_RET(sockAddr, CA_ADAPTER_UTILS_TAG, "sockAddr is null",
+                        CA_STATUS_INVALID_PARAM);
+    VERIFY_NON_NULL_RET(host, CA_ADAPTER_UTILS_TAG, "host is null", CA_STATUS_INVALID_PARAM);
+    VERIFY_NON_NULL_RET(port, CA_ADAPTER_UTILS_TAG, "port is null", CA_STATUS_INVALID_PARAM);
+
+    int r = getnameinfo((struct sockaddr *)sockAddr,
+                        sockAddrLen,
+                        host, MAX_ADDR_STR_SIZE_CA,
+                        NULL, 0,
+                        NI_NUMERICHOST|NI_NUMERICSERV);
+    if (r)
+    {
+#if defined(EAI_SYSTEM)
+        if (EAI_SYSTEM == r)
+        {
+            OIC_LOG_V(ERROR, CA_ADAPTER_UTILS_TAG,
+                            "getnameinfo failed: errno %s", strerror(errno));
+        }
+        else
+        {
+            OIC_LOG_V(ERROR, CA_ADAPTER_UTILS_TAG,
+                            "getnameinfo failed: %s", gai_strerror(r));
+        }
+#elif defined(_WIN32)
+        OIC_LOG_V(ERROR, CA_ADAPTER_UTILS_TAG,
+                            "getnameinfo failed: errno %i", WSAGetLastError());
+#else
+        OIC_LOG_V(ERROR, CA_ADAPTER_UTILS_TAG,
+                            "getnameinfo failed: %s", gai_strerror(r));
+#endif
+        return CA_STATUS_FAILED;
+    }
+    *port = ntohs(((struct sockaddr_in *)sockAddr)->sin_port); // IPv4 and IPv6
+    return CA_STATUS_OK;
+}
+
+CAResult_t CAConvertNameToAddr(const char *host, uint16_t port, struct sockaddr_storage *sockaddr)
+{
+    VERIFY_NON_NULL_RET(host, CA_ADAPTER_UTILS_TAG, "host is null", CA_STATUS_INVALID_PARAM);
+    VERIFY_NON_NULL_RET(sockaddr, CA_ADAPTER_UTILS_TAG, "sockaddr is null",
+                        CA_STATUS_INVALID_PARAM);
+
+    struct addrinfo *addrs = NULL;
+    struct addrinfo hints = { .ai_family = AF_UNSPEC,
+                              .ai_flags = AI_NUMERICHOST };
+
+    int r = getaddrinfo(host, NULL, &hints, &addrs);
+    if (r)
+    {
+        if (NULL != addrs)
+        {
+            freeaddrinfo(addrs);
+        }
+#if defined(EAI_SYSTEM)
+        if (EAI_SYSTEM == r)
+        {
+            OIC_LOG_V(ERROR, CA_ADAPTER_UTILS_TAG,
+                            "getaddrinfo failed: errno %s", strerror(errno));
+        }
+        else
+        {
+            OIC_LOG_V(ERROR, CA_ADAPTER_UTILS_TAG,
+                            "getaddrinfo failed: %s", gai_strerror(r));
+        }
+#elif defined(_WIN32)
+        OIC_LOG_V(ERROR, CA_ADAPTER_UTILS_TAG,
+                            "getaddrinfo failed: errno %i", WSAGetLastError());
+#else
+        OIC_LOG_V(ERROR, CA_ADAPTER_UTILS_TAG,
+                            "getaddrinfo failed: %s", gai_strerror(r));
+#endif
+        return CA_STATUS_FAILED;
+    }
+    // assumption: in this case, getaddrinfo will only return one addrinfo
+    // or first is the one we want.
+    if (addrs[0].ai_family == AF_INET6)
+    {
+        memcpy(sockaddr, addrs[0].ai_addr, sizeof (struct sockaddr_in6));
+        ((struct sockaddr_in6 *)sockaddr)->sin6_port = htons(port);
+    }
+    else
+    {
+        memcpy(sockaddr, addrs[0].ai_addr, sizeof (struct sockaddr_in));
+        ((struct sockaddr_in *)sockaddr)->sin_port = htons(port);
+    }
+    freeaddrinfo(addrs);
+    return CA_STATUS_OK;
+}
+
+#ifdef __JAVA__
+void CANativeJNISetJavaVM(JavaVM *jvm)
+{
+    OIC_LOG_V(DEBUG, CA_ADAPTER_UTILS_TAG, "CANativeJNISetJavaVM");
+    g_jvm = jvm;
+}
+
+JavaVM *CANativeJNIGetJavaVM()
+{
+    return g_jvm;
+}
+
+void CADeleteGlobalReferences(JNIEnv *env)
+{
+    OC_UNUSED(env);
+#ifdef __ANDROID__
+    if (g_Context)
+    {
+        (*env)->DeleteGlobalRef(env, g_Context);
+        g_Context = NULL;
+    }
+
+    if (g_Activity)
+    {
+        (*env)->DeleteGlobalRef(env, g_Activity);
+        g_Activity = NULL;
+    }
+#endif //__ANDROID__
+}
+
+jmethodID CAGetJNIMethodID(JNIEnv *env, const char* className,
+                           const char* methodName,
+                           const char* methodFormat)
+{
+    VERIFY_NON_NULL_RET(env, CA_ADAPTER_UTILS_TAG, "env", NULL);
+    VERIFY_NON_NULL_RET(className, CA_ADAPTER_UTILS_TAG, "className", NULL);
+    VERIFY_NON_NULL_RET(methodName, CA_ADAPTER_UTILS_TAG, "methodName", NULL);
+    VERIFY_NON_NULL_RET(methodFormat, CA_ADAPTER_UTILS_TAG, "methodFormat", NULL);
+
+    jclass jni_cid = (*env)->FindClass(env, className);
+    if (!jni_cid)
+    {
+        OIC_LOG_V(ERROR, CA_ADAPTER_UTILS_TAG, "jni_cid [%s] is null", className);
+        CACheckJNIException(env);
+        return NULL;
+    }
+
+    jmethodID jni_midID = (*env)->GetMethodID(env, jni_cid, methodName, methodFormat);
+    if (!jni_midID)
+    {
+        OIC_LOG_V(ERROR, CA_ADAPTER_UTILS_TAG, "jni_midID [%s] is null", methodName);
+        CACheckJNIException(env);
+        (*env)->DeleteLocalRef(env, jni_cid);
+        return NULL;
+    }
+
+    (*env)->DeleteLocalRef(env, jni_cid);
+    return jni_midID;
+}
+
+bool CACheckJNIException(JNIEnv *env)
+{
+    if ((*env)->ExceptionCheck(env))
+    {
+        (*env)->ExceptionDescribe(env);
+        (*env)->ExceptionClear(env);
+        return true;
+    }
+    return false;
+}
+
+#ifdef __ANDROID__
+void CANativeJNISetContext(JNIEnv *env, jobject context)
+{
+    OIC_LOG_V(DEBUG, CA_ADAPTER_UTILS_TAG, "CANativeJNISetContext");
+
+    if (!context)
+    {
+        OIC_LOG(ERROR, CA_ADAPTER_UTILS_TAG, "context is null");
+        return;
+    }
+
+    if (!g_Context)
+    {
+        g_Context = (*env)->NewGlobalRef(env, context);
+    }
+    else
+    {
+        OIC_LOG(INFO, CA_ADAPTER_UTILS_TAG, "context is already set");
+    }
+}
+
+jobject CANativeJNIGetContext()
+{
+    return g_Context;
+}
+
+void CANativeSetActivity(JNIEnv *env, jobject activity)
+{
+    OIC_LOG_V(DEBUG, CA_ADAPTER_UTILS_TAG, "CANativeSetActivity");
+
+    if (!activity)
+    {
+        OIC_LOG(ERROR, CA_ADAPTER_UTILS_TAG, "activity is null");
+        return;
+    }
+
+    if (!g_Activity)
+    {
+        g_Activity = (*env)->NewGlobalRef(env, activity);
+    }
+    else
+    {
+        OIC_LOG(INFO, CA_ADAPTER_UTILS_TAG, "activity is already set");
+    }
+}
+
+jobject *CANativeGetActivity()
+{
+    return g_Activity;
+}
+#endif //__ANDROID__
+#endif //JAVA__
+
+void CALogAdapterStateInfo(CATransportAdapter_t adapter, CANetworkStatus_t state)
+{
+    OIC_LOG(DEBUG, CA_ADAPTER_UTILS_TAG, "CALogAdapterStateInfo");
+    OIC_LOG(DEBUG, ANALYZER_TAG, "=================================================");
+    CALogAdapterTypeInfo(adapter);
+    if (CA_INTERFACE_UP == state)
+    {
+        OIC_LOG(DEBUG, ANALYZER_TAG, "adapter status is changed to CA_INTERFACE_UP");
+    }
+    else
+    {
+        OIC_LOG(DEBUG, ANALYZER_TAG, "adapter status is changed to CA_INTERFACE_DOWN");
+    }
+    OIC_LOG(DEBUG, ANALYZER_TAG, "=================================================");
+}
+
+void CALogSendStateInfo(CATransportAdapter_t adapter,
+                        const char *addr, uint16_t port, ssize_t sentLen,
+                        bool isSuccess, const char* message)
+{
+#ifndef TB_LOG
+    OC_UNUSED(addr);
+    OC_UNUSED(port);
+    OC_UNUSED(sentLen);
+    OC_UNUSED(message);
+#endif
+
+    OIC_LOG(DEBUG, CA_ADAPTER_UTILS_TAG, "CALogSendStateInfo");
+    OIC_LOG(DEBUG, ANALYZER_TAG, "=================================================");
+
+    if (true == isSuccess)
+    {
+        OIC_LOG_V(DEBUG, ANALYZER_TAG, "Send Success, sent length = [%" PRIdPTR "]", sentLen);
+    }
+    else
+    {
+        OIC_LOG_V(DEBUG, ANALYZER_TAG, "Send Failure, error message  = [%s]",
+                  message != NULL ? message : "no message");
+    }
+
+    CALogAdapterTypeInfo(adapter);
+    OIC_LOG_V(DEBUG, ANALYZER_TAG, "Address = [%s]:[%d]", addr, port);
+    OIC_LOG(DEBUG, ANALYZER_TAG, "=================================================");
+}
+
+void CALogAdapterTypeInfo(CATransportAdapter_t adapter)
+{
+    switch(adapter)
+    {
+        case CA_ADAPTER_IP:
+            OIC_LOG(DEBUG, ANALYZER_TAG, "Transport Type = [OC_ADAPTER_IP]");
+            break;
+        case CA_ADAPTER_TCP:
+            OIC_LOG(DEBUG, ANALYZER_TAG, "Transport Type = [OC_ADAPTER_TCP]");
+            break;
+        case CA_ADAPTER_GATT_BTLE:
+            OIC_LOG(DEBUG, ANALYZER_TAG, "Transport Type = [OC_ADAPTER_GATT_BTLE]");
+            break;
+        case CA_ADAPTER_RFCOMM_BTEDR:
+            OIC_LOG(DEBUG, ANALYZER_TAG, "Transport Type = [OC_ADAPTER_RFCOMM_BTEDR]");
+            break;
+        default:
+            OIC_LOG_V(DEBUG, ANALYZER_TAG, "Transport Type = [%d]", adapter);
+            break;
+    }
+}
+
+CAResult_t CAGetIpv6AddrScopeInternal(const char *addr, CATransportFlags_t *scopeLevel)
+{
+    if (!addr || !scopeLevel)
+    {
+        return CA_STATUS_INVALID_PARAM;
+    }
+    // check addr is ipv6
+    struct in6_addr inAddr6;
+    if (1 == inet_pton(AF_INET6, addr, &inAddr6))
+    {
+        // check addr is multicast
+        if (IN6_IS_ADDR_MULTICAST(&inAddr6))
+        {
+            *scopeLevel = (CATransportFlags_t)(inAddr6.s6_addr[1] & 0xf);
+            return CA_STATUS_OK;
+        }
+        else
+        {
+            // check addr is linklocal or loopback
+            if (IN6_IS_ADDR_LINKLOCAL(&inAddr6) || IN6_IS_ADDR_LOOPBACK(&inAddr6))
+            {
+                *scopeLevel = CA_SCOPE_LINK;
+                return CA_STATUS_OK;
+            }
+            // check addr is sitelocal
+            else if (IN6_IS_ADDR_SITELOCAL(&inAddr6))
+            {
+                *scopeLevel = CA_SCOPE_SITE;
+                return CA_STATUS_OK;
+            }
+            else
+            {
+                *scopeLevel = CA_SCOPE_GLOBAL;
+                return CA_STATUS_OK;
+            }
+        }
+    }
+    else
+    {
+        OIC_LOG(ERROR, CA_ADAPTER_UTILS_TAG, "Failed at parse ipv6 address using inet_pton");
+        return CA_STATUS_FAILED;
+    }
+}
+
+static bool CACheckLSRegistered()
+{
+    if (g_pLSHandle)
+    {
+        OIC_LOG(INFO, CA_ADAPTER_UTILS_TAG, "Luna service is already registered");
+        return true;
+    }
+    else
+    {
+        OIC_LOG(INFO, CA_ADAPTER_UTILS_TAG, "Luna service is not registered");
+        return false;
+    }
+}
+
+static bool CACreateLSServiceName()
+{
+    FILE *fp = NULL;
+    char lunaServiceBuff[MAX_LS_NAME_SIZE];
+    size_t readSize = 0;
+    char *command = NULL;
+    command = g_strdup_printf("ls-monitor -l | grep %d | awk '{print $2}'", getpid());
+
+    OIC_LOG_V(INFO, CA_ADAPTER_UTILS_TAG, "PID : %d", getpid());
+
+    // Get service Name by pid
+    fp = popen(command, "r");
+    if (NULL == fp)
+    {
+        OIC_LOG(ERROR, CA_ADAPTER_UTILS_TAG, "Failed to open ls-monitor");
+        exit(1);
+    }
+
+    readSize = fread((void*)lunaServiceBuff, sizeof(char), MAX_LS_NAME_SIZE - 1, fp);
+    OIC_LOG_V(INFO, CA_ADAPTER_UTILS_TAG, "lunaServiceBuff : %s, readSize: %d", lunaServiceBuff, readSize);
+    if (0 == readSize)
+    {
+        OIC_LOG(ERROR, CA_ADAPTER_UTILS_TAG, "This process does not have Luna service");
+        g_free(command);
+        pclose(fp);
+        return false;
+    }
+    lunaServiceBuff[readSize]='0';
+
+    g_lsServiceName = g_strdup_printf("%s-iotivity%d", g_strndup(lunaServiceBuff, readSize-1), getpid());
+
+    pclose( fp);
+
+    return true;
+}
+
+static void CATriggerCreateLSServiceName()
+{
+    for (int i = 0; i < MAX_GET_LS_SERVICE_NAME_COUNT; i++)
+    {
+        if (CACreateLSServiceName())
+        {
+            OIC_LOG_V(DEBUG, CA_ADAPTER_UTILS_TAG, "Luna service name : %s", g_lsServiceName);
+            break;
+        }
+
+        sleep(1);
+    }
+}
+
+static void CAStartLSMainLoop(void * data)
+{
+    OIC_LOG(DEBUG, CA_ADAPTER_UTILS_TAG, "CAStartLSMainLoop");
+
+    LSError lserror;
+    LSErrorInit(&lserror);
+
+
+    g_isLSRegistering = true;
+    OIC_LOG(DEBUG, CA_ADAPTER_UTILS_TAG, "CAStartLSMainLoop Break 1");
+    if (g_lsServiceName == NULL)
+    {
+        OIC_LOG(ERROR, CA_ADAPTER_UTILS_TAG, "Failed to create Luna service name");
+        return;
+    }
+
+    g_loopContext = g_main_context_new();
+    g_mainLoop = g_main_loop_new(g_loopContext, FALSE);
+    g_main_context_push_thread_default(g_loopContext);
+
+    if (!g_mainLoop)
+    {
+        OIC_LOG(ERROR, CA_ADAPTER_UTILS_TAG, "Failed to create main loop");
+        return;
+    }
+
+    if (!LSRegister(g_lsServiceName, &g_pLSHandle, &lserror))
+    {
+        OIC_LOG(ERROR, CA_ADAPTER_UTILS_TAG, "Failed to register LS Handle");
+        return;
+    }
+
+    if (!LSGmainAttach(g_pLSHandle, g_mainLoop, &lserror))
+    {
+        OIC_LOG(ERROR, CA_ADAPTER_UTILS_TAG, "Failed to attach main loop");
+        return;
+    }
+
+    g_isLSRegistering = false;
+    g_main_loop_run(g_mainLoop);
+
+    g_main_context_unref(g_loopContext);
+    g_main_loop_unref(g_mainLoop);
+}
+
+CAResult_t CAInitializeLS(ca_thread_pool_t handle)
+{
+    OIC_LOG(DEBUG, CA_ADAPTER_UTILS_TAG, "CAInitializeLS");
+
+    CAResult_t result = CA_STATUS_FAILED;
+
+    if (CACheckLSRegistered())
+       return CA_STATUS_OK;
+
+    if (g_isLSRegistering)
+    {
+        OIC_LOG(DEBUG, CA_ADAPTER_UTILS_TAG, "Wait for registering LS service");
+        sleep(1);
+    }
+
+    CATriggerCreateLSServiceName();
+
+    result = ca_thread_pool_add_task(handle, CAStartLSMainLoop, NULL);
+    if (CA_STATUS_OK != result)
+    {
+        OIC_LOG(ERROR, CA_ADAPTER_UTILS_TAG, "LS thread_pool_add_task failed");
+        return result;
+    }
+
+    for (int i = 0; i < MAX_GET_LS_SERVICE_NAME_COUNT; i++)
+    {
+        if (CACheckLSRegistered())
+        {
+            result = CA_STATUS_OK;
+            break;
+        }
+        else
+        {
+            sleep(1);
+            result = CA_STATUS_FAILED;
+        }
+    }
+    return result;
+}
+
+void CATerminateLS()
+{
+    OIC_LOG(INFO, CA_ADAPTER_UTILS_TAG, "CATerminateLS");
+    LSError lserror;
+    LSErrorInit(&lserror);
+
+    if (g_pLSHandle)
+    {
+        OIC_LOG(DEBUG, CA_ADAPTER_UTILS_TAG, "g_pLSHandle is not null");
+        if (!LSUnregister(g_pLSHandle, &lserror))
+        {
+            OIC_LOG(DEBUG, CA_ADAPTER_UTILS_TAG, "Failed to unregister Luna service");
+            LSErrorPrint(&lserror, stderr);
+            LSErrorFree(&lserror);
+        }
+        g_pLSHandle = NULL;
+    }
+
+    g_main_loop_quit(g_mainLoop);
+}
+
+LSHandle* CAGetLSHandle()
+{
+    OIC_LOG(DEBUG, CA_ADAPTER_UTILS_TAG, "CAGetLSHandle");
+    return g_pLSHandle;
+}
+
diff --git a/resource/csdk/connectivity/src/ip_adapter/caipadapter.c b/resource/csdk/connectivity/src/ip_adapter/caipadapter.c
index 5d2cf9a..9b5ba29 100644
--- a/resource/csdk/connectivity/src/ip_adapter/caipadapter.c
+++ b/resource/csdk/connectivity/src/ip_adapter/caipadapter.c
@@ -345,6 +345,10 @@ CAResult_t CAInitializeIP(CARegisterConnectivityCallback registerCallback,
     OIC_LOG(DEBUG, TAG, "WSAStartup Succeeded");
 #endif
 
+#ifdef __webos__
+    CAIPSetMonitorThreadPoolHandle(handle);
+#endif // __webos__
+
     g_networkChangeCallback = netCallback;
     g_networkPacketCallback = networkPacketCallback;
     g_errorCallback = errorCallback;
diff --git a/resource/csdk/connectivity/src/ip_adapter/webos/SConscript b/resource/csdk/connectivity/src/ip_adapter/webos/SConscript
new file mode 100644
index 0000000..d5097f5
--- /dev/null
+++ b/resource/csdk/connectivity/src/ip_adapter/webos/SConscript
@@ -0,0 +1,35 @@
+#******************************************************************
+#
+# Copyright (c) 2018 LG Electronics, Inc.
+#
+#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+
+#######################################################
+#       Build IP adapter for webOS
+#######################################################
+import os
+
+Import('connectivity_env')
+
+connectivity_env.ParseConfig("pkg-config --cflags --libs glib-2.0")
+connectivity_env.ParseConfig("pkg-config --cflags --libs luna-service2")
+connectivity_env.ParseConfig("pkg-config --cflags --libs pbnjson_c")
+
+connectivity_env.AppendUnique(CA_SRC=[File('caipnwmonitor.c')])
+
+connectivity_env.AppendUnique(CPPDEFINES=['__webos__'])
diff --git a/resource/csdk/connectivity/src/ip_adapter/webos/caipnwmonitor.c b/resource/csdk/connectivity/src/ip_adapter/webos/caipnwmonitor.c
new file mode 100644
index 0000000..b1e5f6a
--- /dev/null
+++ b/resource/csdk/connectivity/src/ip_adapter/webos/caipnwmonitor.c
@@ -0,0 +1,672 @@
+/*******************************************************************
+ *
+ * Copyright (c) 2018 LG Electronics, Inc.
+ * Copyright 2014 Samsung Electronics All Rights Reserved.
+ *
+ *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+ */
+
+#include "caipinterface.h"
+
+#include <stdio.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/select.h>
+#include <ifaddrs.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <arpa/inet.h>
+#include <netinet/in.h>
+#include <net/if.h>
+#include <netdb.h>
+#include <errno.h>
+
+#include <linux/netlink.h>
+#include <linux/rtnetlink.h>
+
+#include <luna-service2/lunaservice.h>
+#include <pbnjson.h>
+#include "caipnwmonitor.h"
+#include "octhread.h"
+#include "caadapterutils.h"
+#include "logger.h"
+#include "oic_malloc.h"
+#include "oic_string.h"
+#include <coap/utlist.h>
+
+#define TAG "OIC_CA_IP_MONITOR"
+#define LS_CONNECTIONMANAGER_GETSTATUS_URI "luna://com.webos.service.connectionmanager/getstatus"
+
+typedef struct _CONNECTION_STATUS {
+    bool isConnectWired;
+    bool isConnectWiFi;
+} CONNECTION_STATUS_T;
+
+CONNECTION_STATUS_T gConnectionStates;
+
+/*
+ * Enable or disable log for network changed event
+ */
+#define NETWORK_INTERFACE_CHANGED_LOGGING 1
+
+/**
+ * Mutex for synchronizing access to cached interface and IP address information.
+ */
+static oc_mutex g_networkMonitorContextMutex = NULL;
+
+/**
+ * Used to storing network interface.
+ */
+static u_arraylist_t *g_netInterfaceList = NULL;
+
+/**
+ * Used to storing adapter changes callback interface.
+ */
+static struct CAIPCBData_t *g_adapterCallbackList = NULL;
+
+/**
+ * Used to monitoring network changes over luna bus which webos uses for IPC
+ */
+static ca_thread_pool_t g_ipMonitorThreadPool = NULL;
+
+/**
+ * Initialize the network interface monitoring list.
+ */
+static CAResult_t CAIPInitializeNetworkMonitorList();
+
+/**
+ * Destroy the network interface monitoring list.
+ */
+static void CAIPDestroyNetworkMonitorList();
+
+/**
+ * Compare the interface with the already added interface in list.
+ */
+static bool CACmpNetworkList(uint32_t ifiindex);
+
+/**
+ * Add new network interface in list.
+ */
+static CAResult_t CAAddNetworkMonitorList(CAInterface_t *ifitem);
+
+/**
+ * Remove network interface from list.
+ */
+static void CARemoveNetworkMonitorList(int ifiindex);
+
+/**
+ * Pass the changed network status through the stored callback.
+ */
+static void CAIPPassNetworkChangesToAdapter(CANetworkStatus_t status);
+
+/**
+ * Create new interface item.
+ */
+static CAInterface_t *CANewInterfaceItem(int index, const char *name, int family,
+                                         const char *addr, int flags);
+
+static CAResult_t CAIPInitializeNetworkMonitorList()
+{
+    if (!g_networkMonitorContextMutex)
+    {
+        g_networkMonitorContextMutex = oc_mutex_new();
+        if (!g_networkMonitorContextMutex)
+        {
+            OIC_LOG(ERROR, TAG, "oc_mutex_new has failed");
+            return CA_STATUS_FAILED;
+        }
+    }
+
+    if (!g_netInterfaceList)
+    {
+        g_netInterfaceList = u_arraylist_create();
+        if (!g_netInterfaceList)
+        {
+            OIC_LOG(ERROR, TAG, "u_arraylist_create has failed");
+            CAIPDestroyNetworkMonitorList();
+            return CA_STATUS_FAILED;
+        }
+    }
+    return CA_STATUS_OK;
+}
+
+static void CAIPDestroyNetworkMonitorList()
+{
+    if (g_netInterfaceList)
+    {
+        u_arraylist_destroy(g_netInterfaceList);
+        g_netInterfaceList = NULL;
+    }
+
+    if (g_networkMonitorContextMutex)
+    {
+        oc_mutex_free(g_networkMonitorContextMutex);
+        g_networkMonitorContextMutex = NULL;
+    }
+}
+
+static bool CACmpNetworkList(uint32_t ifiindex)
+{
+#if NETWORK_INTERFACE_CHANGED_LOGGING
+    OIC_LOG_V(DEBUG, TAG, "IN %s: ifiindex = %ul", __func__, ifiindex);
+#endif
+    if (!g_netInterfaceList)
+    {
+        OIC_LOG(ERROR, TAG, "g_netInterfaceList is NULL");
+        return false;
+    }
+
+    oc_mutex_lock(g_networkMonitorContextMutex);
+
+    size_t list_length = u_arraylist_length(g_netInterfaceList);
+    for (size_t list_index = 0; list_index < list_length; list_index++)
+    {
+        CAInterface_t *currItem = (CAInterface_t *) u_arraylist_get(g_netInterfaceList,
+                                                                    list_index);
+        if (currItem->index == ifiindex)
+        {
+            oc_mutex_unlock(g_networkMonitorContextMutex);
+            return true;
+        }
+    }
+    oc_mutex_unlock(g_networkMonitorContextMutex);
+    OIC_LOG_V(DEBUG, TAG, "OUT %s", __func__);
+    return false;
+}
+
+static CAResult_t CAAddNetworkMonitorList(CAInterface_t *ifitem)
+{
+    OIC_LOG_V(DEBUG, TAG, "IN %s", __func__);
+    VERIFY_NON_NULL(g_netInterfaceList, TAG, "g_netInterfaceList is NULL");
+    VERIFY_NON_NULL(ifitem, TAG, "ifitem is NULL");
+
+    oc_mutex_lock(g_networkMonitorContextMutex);
+    bool result = u_arraylist_add(g_netInterfaceList, (void *) ifitem);
+    if (!result)
+    {
+        OIC_LOG(ERROR, TAG, "u_arraylist_add failed.");
+        oc_mutex_unlock(g_networkMonitorContextMutex);
+        return CA_STATUS_FAILED;
+    }
+    oc_mutex_unlock(g_networkMonitorContextMutex);
+    OIC_LOG_V(DEBUG, TAG, "OUT %s", __func__);
+    return CA_STATUS_OK;
+}
+
+static void CARemoveNetworkMonitorList(int ifiindex)
+{
+    VERIFY_NON_NULL_VOID(g_netInterfaceList, TAG, "g_netInterfaceList is NULL");
+
+    oc_mutex_lock(g_networkMonitorContextMutex);
+
+    size_t list_length = u_arraylist_length(g_netInterfaceList);
+    for (size_t list_index = 0; list_index < list_length; list_index++)
+    {
+        CAInterface_t *removedifitem = (CAInterface_t *) u_arraylist_get(
+                g_netInterfaceList, list_index);
+        if (removedifitem && ((int)removedifitem->index) == ifiindex)
+        {
+            if (u_arraylist_remove(g_netInterfaceList, list_index))
+            {
+                OICFree(removedifitem);
+                oc_mutex_unlock(g_networkMonitorContextMutex);
+                return;
+            }
+            continue;
+        }
+    }
+    oc_mutex_unlock(g_networkMonitorContextMutex);
+    return;
+}
+
+static bool get_connection_status_cb(LSHandle *sh, LSMessage *message, void *ctx)
+{
+    OIC_LOG(DEBUG, TAG, "Callback for com.webos.service.connectionmanager/getstatus is invoked...");
+
+    jvalue_ref parsedObj = {0};
+    jschema_ref input_schema = jschema_parse(j_cstr_to_buffer("{}"), DOMOPT_NOOPT, NULL);
+
+    if (!input_schema)
+        return false;
+
+    JSchemaInfo schemaInfo;
+    jschema_info_init(&schemaInfo, input_schema, NULL, NULL);
+    parsedObj = jdom_parse(j_cstr_to_buffer(LSMessageGetPayload(message)), DOMOPT_NOOPT, &schemaInfo);
+    jschema_release(&input_schema);
+
+    if (jis_null(parsedObj))
+        return true;
+
+    const char *payload = jvalue_tostring(parsedObj, input_schema);
+
+    OIC_LOG_V(DEBUG, TAG, "Paylod: %s", payload);
+
+    jvalue_ref wiredObj={0}, wifiObj ={0}, wiredStateObj={0}, wifiStateObj={0};
+
+    if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("wired"), &wiredObj))
+    {
+        if (jobject_get_exists(wiredObj, J_CSTR_TO_BUF("state"), &wiredStateObj))
+        {
+            if (jstring_equal2(wiredStateObj, J_CSTR_TO_BUF("connected")) && !gConnectionStates.isConnectWired)
+            {
+                gConnectionStates.isConnectWired = true;
+                CAIPPassNetworkChangesToAdapter(CA_INTERFACE_UP);
+                OIC_LOG(INFO, TAG, "Wired LAN is connected...");
+            }
+            else if (jstring_equal2(wiredStateObj, J_CSTR_TO_BUF("disconnected")) && gConnectionStates.isConnectWired)
+            {
+                gConnectionStates.isConnectWired = false;
+                CAIPPassNetworkChangesToAdapter(CA_INTERFACE_DOWN);
+                OIC_LOG(INFO, TAG, "Wired LAN is disconnected...");
+            }
+        }
+    }
+
+    if (jobject_get_exists(parsedObj, J_CSTR_TO_BUF("wifi"), &wifiObj))
+    {
+        if (jobject_get_exists(wifiObj, J_CSTR_TO_BUF("state"), &wifiStateObj))
+        {
+            if (jstring_equal2(wifiStateObj, J_CSTR_TO_BUF("connected")) && !gConnectionStates.isConnectWiFi)
+            {
+                gConnectionStates.isConnectWiFi = true;
+                CAIPPassNetworkChangesToAdapter(CA_INTERFACE_UP);
+                OIC_LOG(INFO, TAG, "Wi-Fi is connected...");
+            }
+            else if (jstring_equal2(wifiStateObj, J_CSTR_TO_BUF("disconnected")) && gConnectionStates.isConnectWiFi)
+            {
+                gConnectionStates.isConnectWiFi = false;
+                CAIPPassNetworkChangesToAdapter(CA_INTERFACE_DOWN);
+                OIC_LOG(DEBUG, TAG, "Wi-Fi is disconnected...");
+            }
+        }
+    }
+
+    return true;
+}
+
+static void CANetworkMonitorHandler()
+{
+    OIC_LOG(DEBUG, TAG, "CANetworkMonitorHandler");
+    LSError lserror;
+    LSErrorInit(&lserror);
+
+    if (!CAGetLSHandle())
+    {
+        OIC_LOG(ERROR, TAG, "Luna service handle is null");
+        exit(1);
+    }
+
+    if(!LSCall(CAGetLSHandle(), LS_CONNECTIONMANAGER_GETSTATUS_URI,
+                            "{\"subscribe\":true}",
+                            get_connection_status_cb, NULL, NULL, &lserror))
+    {
+        OIC_LOG(ERROR, TAG, "com.webos.service.connectionmanager/getstatus failed");
+        LSErrorPrint(&lserror, stderr);
+    }
+    else
+    {
+        OIC_LOG(INFO, TAG, "com.webos.service.connectionmanager/getstatus succeeds");
+    }
+}
+
+CAResult_t CAIPStartNetworkMonitor(CAIPAdapterStateChangeCallback callback,
+                                   CATransportAdapter_t adapter)
+{
+    CAResult_t res = CA_STATUS_FAILED;
+
+    res = CAInitializeLS(g_ipMonitorThreadPool);
+    if (CA_STATUS_OK != res)
+    {
+        OIC_LOG(ERROR, TAG, "Failed to register LS in IP monitor");
+        return res;
+    }
+
+    CANetworkMonitorHandler();
+
+    res = CAIPInitializeNetworkMonitorList();
+    if (CA_STATUS_OK == res)
+    {
+        return CAIPSetNetworkMonitorCallback(callback, adapter);
+    }
+
+    return res;
+}
+
+CAResult_t CAIPStopNetworkMonitor(CATransportAdapter_t adapter)
+{
+    gboolean ret = false;
+    LSError lserror;
+    LSErrorInit(&lserror);
+
+    CAIPDestroyNetworkMonitorList();
+
+    CATerminateLS();
+
+    return CAIPUnSetNetworkMonitorCallback(adapter);
+}
+
+int CAGetPollingInterval(int interval)
+{
+    return interval;
+}
+
+static void CAIPPassNetworkChangesToAdapter(CANetworkStatus_t status)
+{
+    OIC_LOG_V(DEBUG, TAG, "IN %s: status = %d", __func__, status);
+    CAIPCBData_t *cbitem = NULL;
+    LL_FOREACH(g_adapterCallbackList, cbitem)
+    {
+        if (cbitem && cbitem->adapter)
+        {
+            cbitem->callback(cbitem->adapter, status);
+            CALogAdapterStateInfo(cbitem->adapter, status);
+        }
+    }
+    OIC_LOG_V(DEBUG, TAG, "OUT %s", __func__);
+}
+
+CAResult_t CAIPSetNetworkMonitorCallback(CAIPAdapterStateChangeCallback callback,
+                                         CATransportAdapter_t adapter)
+{
+    if (!callback)
+    {
+        OIC_LOG(ERROR, TAG, "callback is null");
+        return CA_STATUS_INVALID_PARAM;
+    }
+
+    CAIPCBData_t *cbitem = NULL;
+    LL_FOREACH(g_adapterCallbackList, cbitem)
+    {
+        if (cbitem && adapter == cbitem->adapter && callback == cbitem->callback)
+        {
+            OIC_LOG(DEBUG, TAG, "this callback is already added");
+            return CA_STATUS_OK;
+        }
+    }
+
+    cbitem = (CAIPCBData_t *)OICCalloc(1, sizeof(*cbitem));
+    if (!cbitem)
+    {
+        OIC_LOG(ERROR, TAG, "Malloc failed");
+        return CA_STATUS_FAILED;
+    }
+
+    cbitem->adapter = adapter;
+    cbitem->callback = callback;
+    LL_APPEND(g_adapterCallbackList, cbitem);
+
+    return CA_STATUS_OK;
+}
+
+CAResult_t CAIPUnSetNetworkMonitorCallback(CATransportAdapter_t adapter)
+{
+    CAIPCBData_t *cbitem = NULL;
+    CAIPCBData_t *tmpCbitem = NULL;
+    LL_FOREACH_SAFE(g_adapterCallbackList, cbitem, tmpCbitem)
+    {
+        if (cbitem && adapter == cbitem->adapter)
+        {
+            OIC_LOG(DEBUG, TAG, "remove specific callback");
+            LL_DELETE(g_adapterCallbackList, cbitem);
+            OICFree(cbitem);
+            return CA_STATUS_OK;
+        }
+    }
+    return CA_STATUS_OK;
+}
+
+static CAInterface_t *CANewInterfaceItem(int index, const char *name, int family,
+                                         const char *addr, int flags)
+{
+    OIC_LOG_V(DEBUG, TAG, "IN %s:"
+              "index = %d, name = \"%s\", family = %d, addr = \"%s\", flags = %d",
+              __func__, index, name, family, addr, flags);
+    CAInterface_t *ifitem = (CAInterface_t *)OICCalloc(1, sizeof (CAInterface_t));
+    if (!ifitem)
+    {
+        OIC_LOG(ERROR, TAG, "Malloc failed");
+        return NULL;
+    }
+
+    OICStrcpy(ifitem->name, sizeof (ifitem->name), name);
+    ifitem->index = index;
+    ifitem->family = family;
+    OICStrcpy(ifitem->addr, sizeof (ifitem->addr), addr);
+    ifitem->flags = flags;
+
+    OIC_LOG_V(DEBUG, TAG, "OUT %s", __func__);
+    return ifitem;
+}
+
+u_arraylist_t *CAFindInterfaceChange()
+{
+    u_arraylist_t *iflist = NULL;
+    char buf[4096] = { 0 };
+    struct nlmsghdr *nh = NULL;
+    struct sockaddr_nl sa = { .nl_family = 0 };
+    struct iovec iov = { .iov_base = buf,
+                         .iov_len = sizeof (buf) };
+    struct msghdr msg = { .msg_name = (void *)&sa,
+                          .msg_namelen = sizeof (sa),
+                          .msg_iov = &iov,
+                          .msg_iovlen = 1 };
+
+    ssize_t len = recvmsg(caglobals.ip.netlinkFd, &msg, 0);
+
+    for (nh = (struct nlmsghdr *)buf; NLMSG_OK(nh, len); nh = NLMSG_NEXT(nh, len))
+    {
+        if (nh != NULL && (nh->nlmsg_type != RTM_DELADDR && nh->nlmsg_type != RTM_NEWADDR))
+        {
+            continue;
+        }
+
+        if (RTM_DELADDR == nh->nlmsg_type)
+        {
+            struct ifaddrmsg *ifa = (struct ifaddrmsg *)NLMSG_DATA (nh);
+            if (ifa)
+            {
+                int ifiIndex = ifa->ifa_index;
+                bool isFound = CACmpNetworkList(ifiIndex);
+                if (isFound)
+                {
+                    CARemoveNetworkMonitorList(ifiIndex);
+                }
+            }
+            continue;
+        }
+
+        // Netlink message type is RTM_NEWADDR.
+        struct ifaddrmsg *ifa = (struct ifaddrmsg *)NLMSG_DATA (nh);
+        if (ifa)
+        {
+            int ifiIndex = ifa->ifa_index;
+            iflist = CAIPGetInterfaceInformation(ifiIndex);
+            if (!iflist)
+            {
+                OIC_LOG_V(ERROR, TAG, "get interface info failed: %s", strerror(errno));
+                return NULL;
+            }
+        }
+    }
+    return iflist;
+}
+
+u_arraylist_t *CAIPGetInterfaceInformation(int desiredIndex)
+{
+#if NETWORK_INTERFACE_CHANGED_LOGGING
+    OIC_LOG_V(DEBUG, TAG, "IN %s: desiredIndex = %d", __func__, desiredIndex);
+#endif
+    if (desiredIndex < 0)
+    {
+        OIC_LOG_V(ERROR, TAG, "invalid index : %d", desiredIndex);
+        return NULL;
+    }
+
+    u_arraylist_t *iflist = u_arraylist_create();
+    if (!iflist)
+    {
+        OIC_LOG_V(ERROR, TAG, "Failed to create iflist: %s", strerror(errno));
+        return NULL;
+    }
+
+    struct ifaddrs *ifp = NULL;
+    if (-1 == getifaddrs(&ifp))
+    {
+        OIC_LOG_V(ERROR, TAG, "Failed to get ifaddrs: %s", strerror(errno));
+        u_arraylist_destroy(iflist);
+        return NULL;
+    }
+
+    struct ifaddrs *ifa = NULL;
+#if NETWORK_INTERFACE_CHANGED_LOGGING
+    OIC_LOG(DEBUG, TAG, "Iterating over interface addresses.");
+#endif
+    for (ifa = ifp; ifa; ifa = ifa->ifa_next)
+    {
+        if (!ifa->ifa_addr)
+        {
+            continue;
+        }
+        int family = ifa->ifa_addr->sa_family;
+        if ((ifa->ifa_flags & IFF_LOOPBACK) || (AF_INET != family && AF_INET6 != family))
+        {
+            continue;
+        }
+
+        int ifindex = if_nametoindex(ifa->ifa_name);
+        if (desiredIndex && (ifindex != desiredIndex))
+        {
+            continue;
+        }
+
+        size_t length = u_arraylist_length(iflist);
+        int already = false;
+#if NETWORK_INTERFACE_CHANGED_LOGGING
+        OIC_LOG_V(DEBUG, TAG, "Iterating over %" PRIuPTR " interfaces.", length);
+#endif
+        for (size_t i = 0; i < length; i++)
+        {
+#if NETWORK_INTERFACE_CHANGED_LOGGING
+            OIC_LOG_V(DEBUG, TAG, "Checking interface %" PRIuPTR ".", i);
+#endif
+            CAInterface_t *ifitem = (CAInterface_t *)u_arraylist_get(iflist, i);
+
+            if (ifitem
+                && (int)ifitem->index == ifindex
+                && ifitem->family == (uint16_t)family)
+            {
+                already = true;
+                break;
+            }
+        }
+        if (already)
+        {
+            continue;
+        }
+
+        CAInterface_t *ifitem = (CAInterface_t *)OICCalloc(1, sizeof(CAInterface_t));
+        if (!ifitem)
+        {
+            OIC_LOG(ERROR, TAG, "Malloc failed");
+            goto exit;
+        }
+
+        OICStrcpy(ifitem->name, INTERFACE_NAME_MAX, ifa->ifa_name);
+        ifitem->index = ifindex;
+        ifitem->family = family;
+        ifitem->flags = ifa->ifa_flags;
+
+        if (ifitem->family == AF_INET6)
+        {
+            struct sockaddr_in6 *in6 = (struct sockaddr_in6*) ifa->ifa_addr;
+            inet_ntop(ifitem->family, (void *)&(in6->sin6_addr), ifitem->addr,
+                      sizeof(ifitem->addr));
+        }
+        else if (ifitem->family == AF_INET)
+        {
+            struct sockaddr_in *in = (struct sockaddr_in*) ifa->ifa_addr;
+            inet_ntop(ifitem->family, (void *)&(in->sin_addr), ifitem->addr,
+                      sizeof(ifitem->addr));
+        }
+
+        bool result = u_arraylist_add(iflist, ifitem);
+        if (!result)
+        {
+            OIC_LOG(ERROR, TAG, "u_arraylist_add failed.");
+            goto exit;
+        }
+
+        bool isFound = CACmpNetworkList(ifitem->index);
+        if (!isFound)
+        {
+            CAInterface_t *newifitem = CANewInterfaceItem(ifitem->index, ifitem->name, ifitem->family,
+                                                          ifitem->addr, ifitem->flags);
+            CAResult_t ret = CAAddNetworkMonitorList(newifitem);
+            if (CA_STATUS_OK != ret)
+            {
+                OICFree(newifitem);
+                goto exit;
+            }
+            OIC_LOG_V(DEBUG, TAG, "Added interface: %s (%d)", ifitem->name, ifitem->family);
+        }
+    }
+    freeifaddrs(ifp);
+#if NETWORK_INTERFACE_CHANGED_LOGGING
+    OIC_LOG_V(DEBUG, TAG, "OUT %s", __func__);
+#endif
+    return iflist;
+
+exit:
+    freeifaddrs(ifp);
+    u_arraylist_destroy(iflist);
+#if NETWORK_INTERFACE_CHANGED_LOGGING
+    OIC_LOG_V(DEBUG, TAG, "OUT %s", __func__);
+#endif
+    return NULL;
+}
+
+CAResult_t CAGetLinkLocalZoneIdInternal(uint32_t ifindex, char **zoneId)
+{
+    if (!zoneId || (*zoneId != NULL))
+    {
+        return CA_STATUS_INVALID_PARAM;
+    }
+
+    *zoneId = (char *)OICCalloc(IF_NAMESIZE, sizeof(char));
+    if (!(*zoneId))
+    {
+        OIC_LOG(ERROR, TAG, "OICCalloc failed in CAGetLinkLocalZoneIdInternal");
+        return CA_MEMORY_ALLOC_FAILED;
+    }
+
+    if (!if_indextoname(ifindex, *zoneId))
+    {
+        OIC_LOG(ERROR, TAG, "if_indextoname failed in CAGetLinkLocalZoneIdInternal");
+        OICFree(*zoneId);
+        *zoneId = NULL;
+        return CA_STATUS_FAILED;
+    }
+
+    OIC_LOG_V(DEBUG, TAG, "Given ifindex is %d parsed zoneId is %s", ifindex, *zoneId);
+    return CA_STATUS_OK;
+}
+
+void CAIPSetMonitorThreadPoolHandle(ca_thread_pool_t handle)
+{
+    g_ipMonitorThreadPool = handle;
+}
diff --git a/resource/csdk/logger/SConscript b/resource/csdk/logger/SConscript
index bfdfd2c..5665a4d 100644
--- a/resource/csdk/logger/SConscript
+++ b/resource/csdk/logger/SConscript
@@ -21,6 +21,11 @@ else:
 if env.get('OIC_SUPPORT_TIZEN_TRACE') == 'True':
     env.AppendUnique(CPPDEFINES=['OIC_SUPPORT_TIZEN_TRACE'])
 
+if env.get('TARGET_OS') == 'webos':
+    env.AppendUnique(CPPDEFINES=['__webos__'])
+    env.ParseConfig("pkg-config --cflags --libs PmLogLib")
+    env.ParseConfig("pkg-config --cflags --libs glib-2.0")
+
 local_env = env.Clone()
 
 ######################################################################
diff --git a/resource/csdk/logger/src/logger.c b/resource/csdk/logger/src/logger.c
index e7a80d8..e11c873 100644
--- a/resource/csdk/logger/src/logger.c
+++ b/resource/csdk/logger/src/logger.c
@@ -55,6 +55,13 @@
 #include "string.h"
 #include "logger_types.h"
 
+#ifdef __webos__
+#include <PmLogLib.h>
+#include <glib.h>
+
+PmLogContext gLogLibContext;
+#endif // __webos__
+
 // log level
 static int g_level = DEBUG;
 // private log messages are not logged unless they have been explicitly enabled by calling OCSetLogLevel().
@@ -86,10 +93,12 @@ static oc_log_level LEVEL_XTABLE[] = {OC_LOG_DEBUG, OC_LOG_INFO,
     static android_LogPriority LEVEL[] =
     {ANDROID_LOG_DEBUG, ANDROID_LOG_INFO, ANDROID_LOG_WARN, ANDROID_LOG_ERROR, ANDROID_LOG_FATAL};
 #endif
-#elif defined(__linux__) || defined(__APPLE__) || defined(__msys_nt__)
+#elif (defined(__linux__) && !defined(__webos__)) || defined(__APPLE__) || defined(__msys_nt__)
     static const char * LEVEL[] __attribute__ ((unused)) = {"\e[0;32mDEBUG\033[0m", "\e[0;33mINFO\033[0m", "\e[0;35mWARNING\033[0m", "\e[0;31mERROR\033[0m", "\e[0;31mFATAL\033[0m"};
 #elif defined(_MSC_VER)
     static const char * LEVEL[] = {"DEBUG", "INFO", "WARNING", "ERROR", "FATAL"};
+#elif defined (__linux__) && (__webos__)
+    static const char * LEVEL[] = {"DEBUG", "INFO", "WARNING", "ERROR", "FATAL"};
 #elif defined ARDUINO
 #include <stdarg.h>
 #include "Arduino.h"
@@ -149,6 +158,78 @@ static bool AdjustAndVerifyLogLevel(int* level)
     return true;
 }
 
+#ifdef __webos__
+char *replaceValue(char *strInput, const char *strTarget, const char *strChange)
+{
+    char* strResult;
+    char* strTemp;
+    int i = 0;
+    int nCount = 0;
+    int nTargetLength = strlen(strTarget);
+
+    if (nTargetLength < 1)
+        return strInput;
+
+    int nChangeLength = strlen(strChange);
+
+    if (nChangeLength != nTargetLength)
+    {
+        for (i = 0; strInput[i] != '\0';)
+        {
+            if (memcmp(&strInput[i], strTarget, nTargetLength) == 0)
+            {
+                nCount++;
+                i += nTargetLength;
+            }
+            else i++;
+        }
+    }
+    else
+    {
+        i = strlen(strInput);
+    }
+    strResult = (char *) malloc(i + 1 + nCount * (nChangeLength - nTargetLength));
+    if (strResult == NULL) return NULL;
+
+    strTemp = strResult;
+    while (*strInput)
+    {
+        if (memcmp(strInput, strTarget, nTargetLength) == 0)
+        {
+            memcpy(strTemp, strChange, nChangeLength);
+            strTemp += nChangeLength;
+            strInput  += nTargetLength;
+        }
+        else
+        {
+            *strTemp++ = *strInput++;
+        }
+    }
+
+    *strTemp = '\0';
+
+    return strResult;
+}
+
+static void webos_log_write(PmLogContext context, int level, const char *tag, const char *logStr)
+{
+    char *strResult = NULL;
+    strResult = replaceValue(logStr, "\t", "    ");
+
+    if (!g_strcmp0(LEVEL[level], "DEBUG"))
+        PmLogDebug(context, "%s: %s", tag, strResult);
+    else if (!g_strcmp0(LEVEL[level], "INFO"))
+        PmLogInfo(context, "INFO", 0, "%s: %s", tag, strResult);
+    else if (!g_strcmp0(LEVEL[level], "WARNING"))
+        PmLogWarning(context, "WARNING", 0, "%s: %s", tag, strResult);
+    else if (!g_strcmp0(LEVEL[level], "ERROR"))
+        PmLogError(context, "ERROR", 0, "%s: %s", tag, strResult);
+    else if (!g_strcmp0(LEVEL[level], "FATAL"))
+        PmLogCritical(context, "CRITICAL", 0, "%s: %s", tag, strResult);
+    free(strResult);
+}
+#endif // __webos__
+
 #ifndef ARDUINO
 
 /**
@@ -282,6 +363,11 @@ void OCLog(int level, const char * tag, const char * logStr)
             break;
     }
 
+   #ifdef __webos__
+    PmLogGetContext("IoTivity", &gLogLibContext);
+    webos_log_write(gLogLibContext, level, tag, logStr);
+   #endif // __webos__
+
    #ifdef __ANDROID__
 
    #ifdef ADB_SHELL
@@ -289,7 +375,6 @@ void OCLog(int level, const char * tag, const char * logStr)
    #else
        __android_log_write(LEVEL[level], tag, logStr);
    #endif
-
    #else
        if (logCtx && logCtx->write_level)
        {
@@ -328,10 +413,13 @@ void OCLog(int level, const char * tag, const char * logStr)
                ms = now.tv_usec * 1000;
            }
    #endif
+   #ifdef __webos__
+   #else
            printf("%02d:%02d.%03d %s: %s: %s\n", min, sec, ms, LEVEL[level], tag, logStr);
-       }
-   #endif
-   }
+   #endif // __webos__
+    }
+   #endif // __ANDROID__
+}
 #endif //__TIZEN__
 #endif //ARDUINO
 #ifdef ARDUINO
diff --git a/resource/csdk/resource-directory/SConscript b/resource/csdk/resource-directory/SConscript
index f28a5f3..29322ba 100644
--- a/resource/csdk/resource-directory/SConscript
+++ b/resource/csdk/resource-directory/SConscript
@@ -70,7 +70,7 @@ if target_os == 'android':
     if not env.get('RELEASE'):
         rd_env.AppendUnique(LIBS=['log'])
 
-if target_os in ['linux', 'tizen']:
+if target_os in ['linux', 'tizen', 'webos']:
     rd_env.ParseConfig('pkg-config --cflags --libs sqlite3')
 else:
     rd_env.AppendUnique(CPPPATH=['../../../extlibs/sqlite3'])
@@ -87,7 +87,7 @@ if 'SERVER' in rd_mode:
         RD_SRC_DIR + 'internal/rd_database.c',
         RD_SRC_DIR + 'rd_server.c',
     ]
-    if target_os not in ['linux', 'tizen', 'windows']:
+    if target_os not in ['linux', 'tizen', 'windows', 'webos']:
         rd_src_c += ['../../../extlibs/sqlite3/sqlite3.c']
 
 if 'CLIENT' in rd_mode:
diff --git a/resource/csdk/security/SConscript b/resource/csdk/security/SConscript
index 2daa1ae..3cb79ad 100644
--- a/resource/csdk/security/SConscript
+++ b/resource/csdk/security/SConscript
@@ -62,10 +62,10 @@ if target_os in ['windows', 'msys_nt']:
     libocsrm_env.AppendUnique(CCFLAGS=['/W4'])
 
 if libocsrm_env.get('SECURED') == '1':
-    if target_os in ['linux', 'android', 'tizen', 'msys_nt', 'windows']:
+    if target_os in ['linux', 'android', 'tizen', 'msys_nt', 'windows', 'webos']:
         SConscript('provisioning/SConscript', 'libocsrm_env')
 
-    if target_os in ['linux', 'windows', 'darwin']:
+    if target_os in ['linux', 'windows', 'darwin', 'webos']:
         SConscript('tool/SConscript', 'libocsrm_env')
 
 # As in the source code, it includes arduino Time library (C++)
@@ -95,6 +95,11 @@ if env.get('LOGGING'):
 if env.get('MULTIPLE_OWNER') == '1':
     libocsrm_env.AppendUnique(CPPDEFINES=['MULTIPLE_OWNER'])
 
+if target_os in ['webos']:
+    libocsrm_env.ParseConfig("pkg-config --cflags --libs glib-2.0")
+    libocsrm_env.ParseConfig("pkg-config --cflags --libs luna-service2")
+    libocsrm_env.ParseConfig("pkg-config --cflags --libs pbnjson_c")
+
 ######################################################################
 # Source files and Targets
 ######################################################################
diff --git a/resource/csdk/security/provisioning/src/SConscript b/resource/csdk/security/provisioning/src/SConscript
index 47b186b..bca061d 100644
--- a/resource/csdk/security/provisioning/src/SConscript
+++ b/resource/csdk/security/provisioning/src/SConscript
@@ -80,7 +80,7 @@ if provisioning_lib_env.get('WITH_TCP') == True and provisioning_lib_env.get('WI
         'cloud/csr.c'
     ]
 
-if target_os in ['linux', 'tizen']:
+if target_os in ['linux', 'tizen', 'webos']:
     provisioning_lib_env.ParseConfig('pkg-config --cflags --libs sqlite3')
 else:
     provisioning_lib_env.AppendUnique(CPPPATH=['#/extlibs/sqlite3'])
diff --git a/resource/csdk/stack/SConscript b/resource/csdk/stack/SConscript
index e027f27..ee25839 100644
--- a/resource/csdk/stack/SConscript
+++ b/resource/csdk/stack/SConscript
@@ -104,7 +104,7 @@ if env.get('SECURED') == '1':
 # c_common calls into mbedcrypto.
 liboctbstack_env.AppendUnique(LIBS=['mbedcrypto'])
 
-if target_os in ['android', 'linux', 'tizen', 'msys_nt', 'windows']:
+if target_os in ['android', 'linux', 'tizen', 'msys_nt', 'windows', 'webos']:
     if target_os not in ['windows', 'msys_nt']:
         liboctbstack_env.PrependUnique(LIBS=['connectivity_abstraction'])
     else:
@@ -187,7 +187,7 @@ else:
             liboctbstack_env.Textfile(
                 target='octbstack.def', source=[File('octbstack_temp3.def')])
 
-if target_os in ['tizen', 'linux']:
+if target_os in ['tizen', 'linux', 'webos']:
     liboctbstack_env.ParseConfig("pkg-config --cflags --libs uuid")
     liboctbstack_env.ParseConfig('pkg-config --cflags --libs sqlite3')
 
@@ -220,7 +220,7 @@ if 'CLIENT' in rd_mode or 'SERVER' in rd_mode:
 
     if 'SERVER' in rd_mode:
         liboctbstack_env.AppendUnique(CPPDEFINES=['RD_SERVER'])
-        if target_os in ['tizen']:
+        if target_os in ['tizen', 'webos']:
             liboctbstack_env.ParseConfig('pkg-config --cflags --libs sqlite3')
         else:
             liboctbstack_env.AppendUnique(CPPPATH=['#extlibs/sqlite3'])
@@ -250,7 +250,7 @@ if with_tcp == True:
 
 if 'SERVER' in rd_mode:
     liboctbstack_src.append(OCTBSTACK_SRC + 'oicresourcedirectory.c')
-    if target_os not in ['linux', 'tizen', 'windows']:
+    if target_os not in ['linux', 'tizen', 'windows', 'webos']:
         liboctbstack_src.append('#extlibs/sqlite3/sqlite3.c')
 
 if ((target_os in ['windows']) and (liboctbstack_env.get('MSVC_UWP_APP') == '1')):
diff --git a/resource/csdk/stack/samples/SConscript b/resource/csdk/stack/samples/SConscript
index f5e9a60..3ab245f 100644
--- a/resource/csdk/stack/samples/SConscript
+++ b/resource/csdk/stack/samples/SConscript
@@ -39,3 +39,8 @@ elif target_os == 'arduino':
 elif target_os == 'msys_nt':
     # Build secure samples. Using linux samples for now.
     SConscript('linux/secure/SConscript', 'stacksamples_env')
+elif target_os == 'webos':
+    if stacksamples_env.get('SECURED') == '1':
+        SConscript('webos/secure/SConscript', 'stacksamples_env')
+    else:
+        SConscript('webos/unsecure/SConscript', 'stacksamples_env')
diff --git a/resource/csdk/stack/samples/webos/com.example.app.iotivity/appinfo.json b/resource/csdk/stack/samples/webos/com.example.app.iotivity/appinfo.json
new file mode 100644
index 0000000..c0218a7
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/com.example.app.iotivity/appinfo.json
@@ -0,0 +1,11 @@
+{
+    "id": "com.example.app.iotivity",
+    "version": "1.0.0",
+    "vendor": "LGE",
+    "type": "web",
+    "main": "index.html",
+    "title": "IoTivity Sampler",
+    "icon": "icon.png",
+    "uiRevision": 2,
+    "requiredPermissions": ["all"]
+}
\ No newline at end of file
diff --git a/resource/csdk/stack/samples/webos/com.example.app.iotivity/npm-shrinkwrap.json b/resource/csdk/stack/samples/webos/com.example.app.iotivity/npm-shrinkwrap.json
new file mode 100644
index 0000000..097210d
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/com.example.app.iotivity/npm-shrinkwrap.json
@@ -0,0 +1,258 @@
+{
+  "name": "com.example.app.iotivity",
+  "version": "1.0.0",
+  "dependencies": {
+    "@enact/core": {
+      "version": "1.15.0",
+      "from": "@enact/core@^1.8.0",
+      "resolved": "https://registry.npmjs.org/@enact/core/-/core-1.15.0.tgz"
+    },
+    "@enact/i18n": {
+      "version": "1.15.0",
+      "from": "@enact/i18n@^1.8.0",
+      "resolved": "https://registry.npmjs.org/@enact/i18n/-/i18n-1.15.0.tgz"
+    },
+    "@enact/moonstone": {
+      "version": "1.15.0",
+      "from": "@enact/moonstone@^1.8.0",
+      "resolved": "https://registry.npmjs.org/@enact/moonstone/-/moonstone-1.15.0.tgz"
+    },
+    "@enact/spotlight": {
+      "version": "1.15.0",
+      "from": "@enact/spotlight@^1.8.0",
+      "resolved": "https://registry.npmjs.org/@enact/spotlight/-/spotlight-1.15.0.tgz"
+    },
+    "@enact/ui": {
+      "version": "1.15.0",
+      "from": "@enact/ui@^1.8.0",
+      "resolved": "https://registry.npmjs.org/@enact/ui/-/ui-1.15.0.tgz"
+    },
+    "@enact/webos": {
+      "version": "1.15.0",
+      "from": "@enact/webos@^1.8.0",
+      "resolved": "https://registry.npmjs.org/@enact/webos/-/webos-1.15.0.tgz"
+    },
+    "asap": {
+      "version": "2.0.6",
+      "from": "asap@~2.0.3",
+      "resolved": "https://registry.npmjs.org/asap/-/asap-2.0.6.tgz"
+    },
+    "change-emitter": {
+      "version": "0.1.6",
+      "from": "change-emitter@^0.1.2",
+      "resolved": "https://registry.npmjs.org/change-emitter/-/change-emitter-0.1.6.tgz"
+    },
+    "classnames": {
+      "version": "2.2.5",
+      "from": "classnames@~2.2.5",
+      "resolved": "https://registry.npmjs.org/classnames/-/classnames-2.2.5.tgz"
+    },
+    "core-js": {
+      "version": "1.2.7",
+      "from": "core-js@^1.0.0",
+      "resolved": "https://registry.npmjs.org/core-js/-/core-js-1.2.7.tgz"
+    },
+    "create-react-class": {
+      "version": "15.6.3",
+      "from": "create-react-class@^15.6.0",
+      "resolved": "https://registry.npmjs.org/create-react-class/-/create-react-class-15.6.3.tgz"
+    },
+    "dom-walk": {
+      "version": "0.1.1",
+      "from": "dom-walk@^0.1.0",
+      "resolved": "https://registry.npmjs.org/dom-walk/-/dom-walk-0.1.1.tgz"
+    },
+    "eases": {
+      "version": "1.0.8",
+      "from": "eases@~1.0.8",
+      "resolved": "https://registry.npmjs.org/eases/-/eases-1.0.8.tgz"
+    },
+    "encoding": {
+      "version": "0.1.12",
+      "from": "encoding@^0.1.11",
+      "resolved": "https://registry.npmjs.org/encoding/-/encoding-0.1.12.tgz"
+    },
+    "fbjs": {
+      "version": "0.8.16",
+      "from": "fbjs@^0.8.16",
+      "resolved": "https://registry.npmjs.org/fbjs/-/fbjs-0.8.16.tgz"
+    },
+    "for-each": {
+      "version": "0.3.2",
+      "from": "for-each@^0.3.2",
+      "resolved": "https://registry.npmjs.org/for-each/-/for-each-0.3.2.tgz"
+    },
+    "global": {
+      "version": "4.3.2",
+      "from": "global@~4.3.0",
+      "resolved": "https://registry.npmjs.org/global/-/global-4.3.2.tgz"
+    },
+    "hoist-non-react-statics": {
+      "version": "1.2.0",
+      "from": "hoist-non-react-statics@^1.0.0",
+      "resolved": "https://registry.npmjs.org/hoist-non-react-statics/-/hoist-non-react-statics-1.2.0.tgz"
+    },
+    "iconv-lite": {
+      "version": "0.4.19",
+      "from": "iconv-lite@~0.4.13",
+      "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.4.19.tgz"
+    },
+    "invariant": {
+      "version": "2.2.4",
+      "from": "invariant@~2.2.2",
+      "resolved": "https://registry.npmjs.org/invariant/-/invariant-2.2.4.tgz"
+    },
+    "is-function": {
+      "version": "1.0.1",
+      "from": "is-function@^1.0.1",
+      "resolved": "https://registry.npmjs.org/is-function/-/is-function-1.0.1.tgz"
+    },
+    "is-stream": {
+      "version": "1.1.0",
+      "from": "is-stream@^1.0.1",
+      "resolved": "https://registry.npmjs.org/is-stream/-/is-stream-1.1.0.tgz"
+    },
+    "isomorphic-fetch": {
+      "version": "2.2.1",
+      "from": "isomorphic-fetch@^2.1.1",
+      "resolved": "https://registry.npmjs.org/isomorphic-fetch/-/isomorphic-fetch-2.2.1.tgz"
+    },
+    "js-tokens": {
+      "version": "3.0.2",
+      "from": "js-tokens@^3.0.0",
+      "resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-3.0.2.tgz"
+    },
+    "lodash": {
+      "version": "4.17.5",
+      "from": "lodash@^4.17.5",
+      "resolved": "https://registry.npmjs.org/lodash/-/lodash-4.17.5.tgz"
+    },
+    "lodash-es": {
+      "version": "4.17.7",
+      "from": "lodash-es@^4.17.5",
+      "resolved": "https://registry.npmjs.org/lodash-es/-/lodash-es-4.17.7.tgz"
+    },
+    "loose-envify": {
+      "version": "1.3.1",
+      "from": "loose-envify@^1.0.0",
+      "resolved": "https://registry.npmjs.org/loose-envify/-/loose-envify-1.3.1.tgz"
+    },
+    "min-document": {
+      "version": "2.19.0",
+      "from": "min-document@^2.19.0",
+      "resolved": "https://registry.npmjs.org/min-document/-/min-document-2.19.0.tgz"
+    },
+    "node-fetch": {
+      "version": "1.7.3",
+      "from": "node-fetch@^1.0.1",
+      "resolved": "https://registry.npmjs.org/node-fetch/-/node-fetch-1.7.3.tgz"
+    },
+    "object-assign": {
+      "version": "4.1.1",
+      "from": "object-assign@^4.1.1",
+      "resolved": "https://registry.npmjs.org/object-assign/-/object-assign-4.1.1.tgz"
+    },
+    "parse-headers": {
+      "version": "2.0.1",
+      "from": "parse-headers@^2.0.0",
+      "resolved": "https://registry.npmjs.org/parse-headers/-/parse-headers-2.0.1.tgz"
+    },
+    "process": {
+      "version": "0.5.2",
+      "from": "process@~0.5.1",
+      "resolved": "https://registry.npmjs.org/process/-/process-0.5.2.tgz"
+    },
+    "promise": {
+      "version": "7.3.1",
+      "from": "promise@^7.1.1",
+      "resolved": "https://registry.npmjs.org/promise/-/promise-7.3.1.tgz"
+    },
+    "prop-types": {
+      "version": "15.6.1",
+      "from": "prop-types@^15.5.10",
+      "resolved": "https://registry.npmjs.org/prop-types/-/prop-types-15.6.1.tgz"
+    },
+    "ramda": {
+      "version": "0.24.1",
+      "from": "ramda@~0.24.1",
+      "resolved": "https://registry.npmjs.org/ramda/-/ramda-0.24.1.tgz"
+    },
+    "react": {
+      "version": "15.6.2",
+      "from": "react@^15.6.1",
+      "resolved": "https://registry.npmjs.org/react/-/react-15.6.2.tgz"
+    },
+    "react-dom": {
+      "version": "15.6.2",
+      "from": "react-dom@^15.6.1",
+      "resolved": "https://registry.npmjs.org/react-dom/-/react-dom-15.6.2.tgz"
+    },
+    "react-redux": {
+      "version": "5.0.7",
+      "from": "react-redux@^5.0.7",
+      "resolved": "https://registry.npmjs.org/react-redux/-/react-redux-5.0.7.tgz",
+      "dependencies": {
+        "hoist-non-react-statics": {
+          "version": "2.5.0",
+          "from": "hoist-non-react-statics@^2.5.0",
+          "resolved": "https://registry.npmjs.org/hoist-non-react-statics/-/hoist-non-react-statics-2.5.0.tgz"
+        }
+      }
+    },
+    "recompose": {
+      "version": "0.23.5",
+      "from": "recompose@~0.23.5",
+      "resolved": "https://registry.npmjs.org/recompose/-/recompose-0.23.5.tgz"
+    },
+    "redux": {
+      "version": "3.7.2",
+      "from": "redux@^3.7.2",
+      "resolved": "https://registry.npmjs.org/redux/-/redux-3.7.2.tgz"
+    },
+    "redux-thunk": {
+      "version": "2.2.0",
+      "from": "redux-thunk@^2.2.0",
+      "resolved": "https://registry.npmjs.org/redux-thunk/-/redux-thunk-2.2.0.tgz"
+    },
+    "setimmediate": {
+      "version": "1.0.5",
+      "from": "setimmediate@^1.0.5",
+      "resolved": "https://registry.npmjs.org/setimmediate/-/setimmediate-1.0.5.tgz"
+    },
+    "symbol-observable": {
+      "version": "1.2.0",
+      "from": "symbol-observable@^1.0.4",
+      "resolved": "https://registry.npmjs.org/symbol-observable/-/symbol-observable-1.2.0.tgz"
+    },
+    "trim": {
+      "version": "0.0.1",
+      "from": "trim@0.0.1",
+      "resolved": "https://registry.npmjs.org/trim/-/trim-0.0.1.tgz"
+    },
+    "ua-parser-js": {
+      "version": "0.7.17",
+      "from": "ua-parser-js@^0.7.9",
+      "resolved": "https://registry.npmjs.org/ua-parser-js/-/ua-parser-js-0.7.17.tgz"
+    },
+    "warning": {
+      "version": "3.0.0",
+      "from": "warning@~3.0.0",
+      "resolved": "https://registry.npmjs.org/warning/-/warning-3.0.0.tgz"
+    },
+    "whatwg-fetch": {
+      "version": "2.0.3",
+      "from": "whatwg-fetch@>=0.10.0",
+      "resolved": "https://registry.npmjs.org/whatwg-fetch/-/whatwg-fetch-2.0.3.tgz"
+    },
+    "xhr": {
+      "version": "2.4.1",
+      "from": "xhr@~2.4.0",
+      "resolved": "https://registry.npmjs.org/xhr/-/xhr-2.4.1.tgz"
+    },
+    "xtend": {
+      "version": "4.0.1",
+      "from": "xtend@^4.0.0",
+      "resolved": "https://registry.npmjs.org/xtend/-/xtend-4.0.1.tgz"
+    }
+  }
+}
diff --git a/resource/csdk/stack/samples/webos/com.example.app.iotivity/package.json b/resource/csdk/stack/samples/webos/com.example.app.iotivity/package.json
new file mode 100644
index 0000000..c09a70a
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/com.example.app.iotivity/package.json
@@ -0,0 +1,45 @@
+{
+  "name": "com.example.app.iotivity",
+  "version": "1.0.0",
+  "description": "iotivity sample app with enact framework",
+  "author": "jy.jeong@lge.com",
+  "main": "src/index.js",
+  "scripts": {
+    "serve": "enact serve",
+    "pack": "enact pack",
+    "pack-p": "enact pack -p",
+    "watch": "enact pack --watch",
+    "clean": "enact clean",
+    "lint": "enact lint .",
+    "license": "enact license",
+    "test": "enact test start --single-run --browsers PhantomJS",
+    "test-json": "enact test start --single-run --browsers PhantomJS --reporters json",
+    "test-watch": "enact test start --browsers PhantomJS"
+  },
+  "license": "LGE",
+  "private": true,
+  "repository": "",
+  "enact": {
+    "isomorphic": true,
+    "ri": {
+      "baseSize": 24
+    }
+  },
+  "eslintConfig": {
+    "extends": "enact"
+  },
+  "dependencies": {
+    "@enact/core": "^1.8.0",
+    "@enact/i18n": "^1.8.0",
+    "@enact/moonstone": "^1.8.0",
+    "@enact/spotlight": "^1.8.0",
+    "@enact/ui": "^1.8.0",
+    "@enact/webos": "^1.8.0",
+    "prop-types": "^15.5.10",
+    "react": "^15.6.1",
+    "react-dom": "^15.6.1",
+    "react-redux": "^5.0.7",
+    "redux": "^3.7.2",
+    "redux-thunk": "^2.2.0"
+  }
+}
diff --git a/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.client/client-lowlevel.js b/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.client/client-lowlevel.js
new file mode 100644
index 0000000..590c7c6
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.client/client-lowlevel.js
@@ -0,0 +1,249 @@
+/* ******************************************************************
+ *
+ * Copyright (c) 2018 LG Electronics, Inc.
+ *
+ *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+ */
+var intervalId, handleReceptacle = {}, iotivity = require("iotivity-node/lowlevel");
+var StorageHandler = require("iotivity-node/lib/CustomStorageHandler");
+var observeHandles = [];
+var observeCount = 0;
+
+returnNoResponse = function(callback) {
+    setTimeout(function() {
+        console.log("No response");
+        callback({});
+        clearInterval( intervalId );
+        iotivity.OCStop();
+    }, 5000, null);
+};
+
+function assembleRequestUrl( eps, path ) {
+    var endpoint;
+    var endpointIndex;
+    var result;
+    for ( endpointIndex in eps ) {
+        endpoint = eps[ endpointIndex ];
+        if ( endpoint.tps  === "coaps" ) {
+            result = ( endpoint.tps + "://" +
+            ( endpoint.family & iotivity.OCTransportFlags.OC_IP_USE_V6 ? "[" : "" ) +
+            endpoint.addr.replace( /[%].*$/, "" ) +
+            ( endpoint.family & iotivity.OCTransportFlags.OC_IP_USE_V6 ? "]" : "" ) +
+            ":" + endpoint.port ) + path;
+            console.log( "GET request to " + result );
+            return result;
+        }
+    }
+    throw new Error( "No secure endpoint found!" );
+}
+
+module.exports.startDiscovery = function(callback) {
+
+    console.log("Issuing discovery request");
+
+    iotivity.OCInit(null, 0, iotivity.OCMode.OC_CLIENT );
+    clearInterval( intervalId );
+    intervalId = setInterval(function() {
+        iotivity.OCProcess();
+    }, 1000);
+
+    // Discover resources and list them
+    iotivity.OCDoResource(
+
+        // The bindings fill in this object
+        handleReceptacle,
+
+        iotivity.OCMethod.OC_REST_DISCOVER,
+
+        // Standard path for discovering resources
+        iotivity.OC_MULTICAST_DISCOVERY_URI,
+
+        // There is no destination
+        null,
+
+        // There is no payload
+        null,
+        iotivity.OCConnectivityType.CT_DEFAULT,
+        iotivity.OCQualityOfService.OC_HIGH_QOS,
+        function(handle, response) {
+            console.log("Discovery response: "+ JSON.stringify(response, null, 4));
+            callback(response);
+            return iotivity.OCStackApplicationResult.OC_STACK_KEEP_TRANSACTION;
+        },
+
+        // There are no header options
+        null
+    );
+
+    returnNoResponse(callback);
+};
+
+module.exports.getResource = function(uri, destination, question, callback) {
+
+    console.log("Sending GET request");
+    var getHandleReceptacle = {};
+    var payload = {
+        "type":iotivity.OCPayloadType.PAYLOAD_TYPE_REPRESENTATION,
+        "values":{"question":question}
+    };
+
+    var getResourceHandler = function( handle, response ) {
+        var resources = response && response.payload && response.payload.resources,
+            resourceCount = resources ? resources.length : 0;
+
+        for (var index = 0; index < resourceCount; index++ ) {
+            if ( resources[ index ].uri === uri ) {
+                iotivity.OCDoResource(
+                    getHandleReceptacle,
+                    iotivity.OCMethod.OC_REST_GET,
+                    assembleRequestUrl( resources[ index ].eps, uri),
+                    destination,
+                    payload,
+                    iotivity.OCConnectivityType.CT_DEFAULT,
+                    iotivity.OCQualityOfService.OC_HIGH_QOS,
+                    function( handle, response ){
+                        console.log( "Received response to GET request:" );
+                        console.log( JSON.stringify( response, null, 4 ) );
+                        callback( response );
+                        setTimeout(function() {
+                            clearInterval( intervalId );
+                            iotivity.OCStop();
+                        }, 1000, null);
+                        return iotivity.OCStackApplicationResult.OC_STACK_DELETE_TRANSACTION;
+                    },
+                    null
+                );
+            }
+        }
+        return iotivity.OCStackApplicationResult.OC_STACK_DELETE_TRANSACTION;
+    };
+
+    iotivity.OCRegisterPersistentStorageHandler(StorageHandler("oic_svr_db_client.dat"));
+    iotivity.OCInit(null, 0, iotivity.OCMode.OC_CLIENT_SERVER );
+    clearInterval( intervalId );
+    intervalId = setInterval(function() {
+        iotivity.OCProcess();
+    }, 1000);
+
+    iotivity.OCDoResource(
+        getHandleReceptacle,
+        iotivity.OCMethod.OC_REST_DISCOVER,
+        iotivity.OC_MULTICAST_DISCOVERY_URI,
+        null,
+        null,
+        iotivity.OCConnectivityType.CT_DEFAULT,
+        iotivity.OCQualityOfService.OC_HIGH_QOS,
+        getResourceHandler,
+        null
+    );
+
+    returnNoResponse(callback);
+};
+
+module.exports.deleteResource = function(uri, destination, callback) {
+
+    console.log("Sending DELETE request");
+    var deleteHandleReceptacle = {};
+    var deleteResponseHandler = function( handle, response ) {
+        console.log( "Received response to DELETE request:" );
+        console.log( JSON.stringify( response, null, 4 ) );
+        callback( response );
+        return iotivity.OCStackApplicationResult.OC_STACK_DELETE_TRANSACTION;
+    };
+
+    iotivity.OCRegisterPersistentStorageHandler(StorageHandler("oic_svr_db_client.dat"));
+    iotivity.OCInit(null, 0, iotivity.OCMode.OC_CLIENT_SERVER );
+    clearInterval( intervalId );
+    intervalId = setInterval(function() {
+        iotivity.OCProcess();
+    }, 1000);
+
+    iotivity.OCDoResource(
+        deleteHandleReceptacle,
+        iotivity.OCMethod.OC_REST_DELETE,
+        uri,
+        destination,
+        null,
+        iotivity.OCConnectivityType.CT_DEFAULT,
+        iotivity.OCQualityOfService.OC_HIGH_QOS,
+        deleteResponseHandler,
+        null
+    );
+
+    returnNoResponse(callback);
+};
+
+module.exports.observeResource = function(uri, destination, callback) {
+
+    console.log( "Observing " + uri );
+    var observeHandleReceptacle = {};
+    var observeResponseHandler = function( handle, response ) {
+        console.log( "Received response to OBSERVE request:" );
+        console.log( JSON.stringify( response, null, 4 ) );
+        callback(response);
+        return iotivity.OCStackApplicationResult.OC_STACK_KEEP_TRANSACTION;
+    };
+
+    iotivity.OCRegisterPersistentStorageHandler(StorageHandler("oic_svr_db_client.dat"));
+    iotivity.OCInit(null, 0, iotivity.OCMode.OC_CLIENT_SERVER );
+    clearInterval( intervalId );
+    intervalId = setInterval(function() {
+        iotivity.OCProcess();
+    }, 1000);
+
+    iotivity.OCDoResource(
+        observeHandleReceptacle,
+        iotivity.OCMethod.OC_REST_OBSERVE,
+        uri,
+        destination,
+        null,
+        iotivity.OCConnectivityType.CT_DEFAULT,
+        iotivity.OCQualityOfService.OC_HIGH_QOS,
+        observeResponseHandler,
+        null
+    );
+
+    observeHandles[observeCount] = {
+        uri: uri,
+        handle: observeHandleReceptacle.handle
+    };
+    observeCount++;
+};
+
+module.exports.cancelObservation = function(uri) {
+    console.log( "Cancel observation " + uri );
+
+    for (var index = 0; index < observeCount; index++){
+        if (observeHandles[index].uri === uri){
+            iotivity.OCCancel(observeHandles[index].handle, iotivity.OCQualityOfService.OC_HIGH_QOS, null );
+            observeCount--;
+            observeHandles.splice(index, 1);
+            break;
+        }
+    }
+
+    clearInterval( intervalId );
+    iotivity.OCStop();
+};
+
+//Exit gracefully when node service is killed
+process.on( "exit", function() {
+    // Tear down the processing loop and stop iotivity
+    clearInterval( intervalId );
+    iotivity.OCStop();
+    console.log("=== client teardown ===");
+} );
\ No newline at end of file
diff --git a/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.client/client.txt b/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.client/client.txt
new file mode 100644
index 0000000..6461d12
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.client/client.txt
@@ -0,0 +1,310 @@
+API Docs - com.example.service.iotivity.client
+
+
+discoverResources
+
+    Discovering available resources from all devices.
+
+    @b Syntax
+    luna://com.example.service.iotivity.client/discoverResources
+
+    @code
+    {
+    }
+    @endcode
+    @param
+        Parameter   |Requirement    |Type   | Description
+        ----------------------------------------------------------
+        none
+    @return
+    <b> For a call: </b>
+    @code
+    {
+        "returnValue"   : boolean,
+        "discoveryResponse" : object,
+    }
+
+    @endcode
+    @param              returnValue
+    Indicates if the call was succesful.
+    @param              discoveryResponse
+    List of discoverd resources.
+
+        Parameter         |Requirement    |Type   | Description
+        ----------------------------------------------------------
+        returnValue       |Required       |boolean| true means success, false means faild
+        discoveryResponse |Required       |object | list of all resources from all devices
+
+    @b Examples:
+    @code
+    luna-send -n 5 -f luna://com.example.service.iotivity.client/discoverResources '{}'
+    @endcode
+
+    Example response for a succesful call:
+    @code
+    {
+        "discoveryResponse": {
+            ...
+        },
+        "returnValue": true
+    }
+    @endcode
+
+
+
+getResource
+
+    Fetch the value of resource from specified URI
+
+    @b Syntax \n
+    luna://com.example.service.iotivity.client/getResource
+
+    @code
+    {
+    }
+    @endcode
+    @param
+        Parameter   |Requirement    |Type   | Description
+        ----------------------------------------------------------
+        uri         |Required       |string |
+        destination |Required       |object | target device address include adapter, flags, ifindex, port and addr
+        question    |Required       |string | payload with specifiied question
+    @return
+    <b> For a call: </b>
+    @code
+    {
+        "returnValue"   : boolean,
+        "response" : object,
+        "errorText" : string
+    }
+
+    @endcode
+    @param              returnValue
+    Indicates if the call was succesful or not.
+    @param              response
+    Detailed information.
+    @param              errorText
+    Describes the error if call was not succesful.
+
+        Parameter         |Requirement    |Type   | Description
+        ----------------------------------------------------------
+        returnValue       |Required       |boolean| true means success, false means faild
+        response          |Optional       |object | value of requested resource
+        errorText         |Optional       |object | value of error text
+
+    @b Examples:
+    @code
+    luna-send -n 1 -f luna://com.example.service.iotivity.client/getResource '{"uri":"/a/fan", "question":"abc","destination": {"adapter": 1,"flags": 32,"ifindex": 2,"port": 54406,"addr": "fe80::ba27:ebff:fe04:f661%eth0"}}'
+    @endcode
+
+    Example response for a succesful call:
+    @code
+    {
+        "returnValue": true,
+        "response": {
+            "devAddr": {
+                "adapter": 1,
+                "flags": 82,
+                "ifindex": 0,
+                "port": 34711,
+                "addr": "10.177.242.177"
+            },
+            "connType": 65618,
+            "addr": {
+                "adapter": 1,
+                "flags": 82,
+                "ifindex": 0,
+                "port": 34711,
+                "addr": "10.177.242.177"
+            },
+            "sequenceNumber": 16777216,
+            "result": 0,
+            "identity": [
+                49,
+                49,
+                49,
+                49,
+                49,
+                49,
+                49,
+                49,
+                49,
+                49,
+                49,
+                49,
+                49,
+                49,
+                49,
+                49
+            ],
+            "payload": {
+                "type": 4,
+                "values": {
+                    "answer": "123"
+                }
+            },
+            "resourceUri": "/a/fan"
+        }
+    }
+    @endcode
+
+
+deleteResource
+
+    Delete resource from specified URI
+
+    @b Syntax
+    luna://com.example.service.iotivity.client/deleteResource
+
+    @code
+    {
+    }
+    @endcode
+    @param
+        Parameter   |Requirement    |Type   | Description
+        ----------------------------------------------------------
+        uri         |Required       |string | uri which is removed
+        destination |Required       |object | target device address include adapter, flags, ifindex, port and addr
+    @return
+    <b> For a call: </b>
+    @code
+    {
+        "returnValue"   : boolean,
+        "response" : object,
+        "errorText" : string
+    }
+
+    @endcode
+    @param              returnValue
+    Indicates if the call was succesful.
+    @param              response
+    Detailed information for removed resources.
+    @param              errorText
+    Describes the error if call was not succesful.
+
+        Parameter         |Requirement    |Type   | Description
+        ----------------------------------------------------------
+        returnValue       |Required       |boolean| true means success, false means faild
+        response          |Optional       |object | value of requested resource
+        errorText         |Optional       |string | value of error text
+    @remarks
+    The \e returnValue will be true as long as the syntax is correct, even if the process ID is not a valid one.
+
+    @b Examples:
+    @code
+    luna-send -n 1 -f luna://com.example.service.iotivity.client/deleteResource '{"uri":"/a/fan","destination":{"adapter":1,"flags":32,"ifindex":0,"port":35128,"addr":"fe80::ba27:ebff:fe04:f661%eth0"}}'
+    @endcode
+
+    Example response for a succesful call:
+    @code
+    {
+        "returnValue": true,
+        "response": {
+            "sequenceNumber": 16777216,
+            "identity": [
+            ],
+            "devAddr": {
+                "adapter": 1,
+                "flags": 32,
+                "ifindex": 2,
+                "port": 35128,
+                "addr": "fe80::ba27:ebff:fe04:f661%eth0"
+            },
+            "connType": 65568,
+            "result": 2,
+            "addr": {
+                "adapter": 1,
+                "flags": 32,
+                "ifindex": 2,
+                "port": 35128,
+                "addr": "fe80::ba27:ebff:fe04:f661%eth0"
+            },
+            "resourceUri": "/a/fan"
+        }
+    }
+    @endcode
+
+
+observeResource
+
+    Observe the value of resource from specified URI
+
+    @b Syntax \n
+    luna://com.example.service.iotivity.client/observeResource
+
+    @code
+    {
+    }
+    @endcode
+    @param
+        Parameter   |Requirement    |Type   | Description
+        ----------------------------------------------------------
+        subscribe   |Required       |boolean |
+        uri         |Required       |string |
+        destination |Required       |object | target device address include adapter, flags, ifindex, port and addr
+    @return
+    <b> For a call: </b>
+    @code
+    {
+        "returnValue"   : boolean,
+        "response" : object,
+        "errorText" : string
+    }
+
+    @endcode
+    @param              returnValue
+    Indicates if the call was succesful.
+    @param              response
+    Detailed information for removed resources.
+    @param              errorText
+    Describes the error if call was not succesful.
+
+        Parameter         |Requirement    |Type   | Description
+        ----------------------------------------------------------
+        returnValue       |Required       |boolean| true means success, false means faild
+        response          |Required       |object | value of requested resource
+        errorText         |Optional       |string | value of error text
+    @remarks
+    The \e returnValue will be true as long as the syntax is correct, even if the process ID is not a valid one.
+
+    @b Examples:
+    @code
+    luna-send -n 1 -f luna://com.example.service.iotivity.client/observeResource '{"uri":"/a/fan","destination":{"adapter":1,"flags":32,"ifindex":0,"port":58941,"addr":"fe80::ba27:ebff:fe04:f661%eth0"},"subscribe":true}'
+    @endcode
+
+    Example response for a succesful call:
+    @code
+    {
+        "subscribed": true,
+        "returnValue": true,
+        "response": {
+            "devAddr": {
+                "adapter": 1,
+                "flags": 32,
+                "ifindex": 2,
+                "port": 58941,
+                "addr": "fe80::ba27:ebff:fe04:f661%eth0"
+            },
+            "connType": 65568,
+            "addr": {
+                "adapter": 1,
+                "flags": 32,
+                "ifindex": 2,
+                "port": 58941,
+                "addr": "fe80::ba27:ebff:fe04:f661%eth0"
+            },
+            "sequenceNumber": 23,
+            "result": 0,
+            "identity": [
+            ],
+            "payload": {
+                "type": 4,
+                "values": {
+                    "someOtherValue": "Espoo",
+                    "someValue": 18
+                }
+            },
+            "resourceUri": "/a/fan"
+        }
+    }
+    @endcode
diff --git a/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.client/com.example.service.iotivity.client.json b/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.client/com.example.service.iotivity.client.json
new file mode 100644
index 0000000..b353e54
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.client/com.example.service.iotivity.client.json
@@ -0,0 +1,3 @@
+{
+  "services" : ["com.example.service.iotivity.client"]
+}
diff --git a/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.client/files/sysbus/com.example.service.iotivity.client.api.json b/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.client/files/sysbus/com.example.service.iotivity.client.api.json
new file mode 100644
index 0000000..b0cfca9
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.client/files/sysbus/com.example.service.iotivity.client.api.json
@@ -0,0 +1,14 @@
+{
+  "public": [
+	"com.example.service.iotivity.client/discoverResources",
+	"com.example.service.iotivity.client/getResource",
+	"com.example.service.iotivity.client/observeResource",
+	"com.example.service.iotivity.client/deleteResource",
+  ],
+  "private": [
+	"com.example.service.iotivity.client/discoverResources",
+	"com.example.service.iotivity.client/getResource",
+	"com.example.service.iotivity.client/observeResource",
+	"com.example.service.iotivity.client/deleteResource",
+  ]
+}
\ No newline at end of file
diff --git a/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.client/files/sysbus/com.example.service.iotivity.client.manifest.json b/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.client/files/sysbus/com.example.service.iotivity.client.manifest.json
new file mode 100644
index 0000000..e62142f
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.client/files/sysbus/com.example.service.iotivity.client.manifest.json
@@ -0,0 +1,13 @@
+{
+    "roleFiles": [
+        "/usr/share/luna-service2/roles.d/com.example.service.iotivity.client.role.json"
+    ],
+    "id": "com.example.service.iotivity.client",
+    "version": "1.0.0",
+    "clientPermissionFiles": [
+        "/usr/share/luna-service2/client-permissions.d/com.example.service.iotivity.client.perm.json"
+    ],
+    "serviceFiles": [
+        "/usr/share/luna-service2/services.d/com.example.service.iotivity.client.service"
+    ]
+}
\ No newline at end of file
diff --git a/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.client/files/sysbus/com.example.service.iotivity.client.perm.json b/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.client/files/sysbus/com.example.service.iotivity.client.perm.json
new file mode 100644
index 0000000..35fcfd9
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.client/files/sysbus/com.example.service.iotivity.client.perm.json
@@ -0,0 +1,3 @@
+{
+  "com.example.service.iotivity.client*" : ["activities.manage", "networking.internal"]
+}
diff --git a/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.client/files/sysbus/com.example.service.iotivity.client.role.json b/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.client/files/sysbus/com.example.service.iotivity.client.role.json
new file mode 100644
index 0000000..d00c1ce
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.client/files/sysbus/com.example.service.iotivity.client.role.json
@@ -0,0 +1,12 @@
+{
+    "appId" : "com.example.service.iotivity.client",
+    "allowedNames" : ["com.example.service.iotivity.client*"],
+    "type" : "regular",
+    "permissions" : [
+	{
+	    "service" : "com.example.service.iotivity.client*",
+	    "inbound" : ["*"],
+	    "outbound" : ["*"]
+	}
+    ]
+}
diff --git a/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.client/files/sysbus/com.example.service.iotivity.client.service b/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.client/files/sysbus/com.example.service.iotivity.client.service
new file mode 100644
index 0000000..14518d5
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.client/files/sysbus/com.example.service.iotivity.client.service
@@ -0,0 +1,23 @@
+#******************************************************************
+#
+# Copyright (c) 2018 LG Electronics, Inc.
+#
+#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+[D-BUS Service]
+Name = com.example.service.iotivity.client*
+Exec = /usr/bin/run-js-service /usr/palm/services/com.example.service.iotivity.client
diff --git a/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.client/main.js b/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.client/main.js
new file mode 100644
index 0000000..c7f9417
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.client/main.js
@@ -0,0 +1,474 @@
+/* ******************************************************************
+ *
+ * Copyright (c) 2018 LG Electronics, Inc.
+ *
+ *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+ */
+var Service = require('webos-service');
+var service = new Service('com.example.service.iotivity.client');
+
+var subscriptions = {};
+
+var client = require('./client-lowlevel');
+
+function isEmpty(obj) {
+    for ( var key in obj) {
+        if (obj.hasOwnProperty(key))
+            return false;
+    }
+    return true;
+};
+
+function subscriptionCallback(response) {
+    for (var i in subscriptions){
+        if (subscriptions.hasOwnProperty(i)) {
+            var s = subscriptions[i];
+            s.respond({
+                response : response,
+                returnValue : true,
+                subscribed : true
+            });
+        }
+    }
+};
+
+function validateUri(_uri){
+    if(_uri.charAt(0)!="/")
+        return "/"+_uri;
+    else return _uri;
+}
+
+/*
+    Discovering available resources from all devices.
+
+    @b Syntax \n
+    luna://com.example.service.iotivity.client/discoverResources
+
+    @code
+    {
+    }
+    @endcode
+    @param
+        Parameter   |Requirement    |Type   | Description
+        ----------------------------------------------------------
+        none
+    @return
+    <b> For a call: </b>
+    @code
+    {
+        "returnValue"   : boolean,
+        "discoveryResponse" : object,
+    }
+
+    @endcode
+    @param              returnValue
+    Indicates if the call was succesful.
+    @param              discoveryResponse
+    List of discoverd resources.
+
+        Parameter         |Requirement    |Type   | Description
+        ----------------------------------------------------------
+        returnValue       |Required       |boolean| true means success, false means faild
+        discoveryResponse |Required       |object | list of all resources from all devices
+
+    @b Examples:
+    @code
+    luna-send -n 5 -f luna://com.example.service.iotivity.client/discoverResources '{}'
+    @endcode
+
+    Example response for a succesful call:
+    @code
+    {
+        "discoveryResponse": {
+            ...
+        },
+        "returnValue": true
+    }
+    @endcode
+*/
+service.register("discoverResources", function(message) {
+    client.startDiscovery(function(response) {
+        message.respond({
+            discoveryResponse : response,
+            returnValue : true
+        });
+    });
+});
+
+/*
+    Fetch the value of resource from specified URI
+
+    @b Syntax \n
+    luna://com.example.service.iotivity.client/getResource
+
+    @code
+    {
+    }
+    @endcode
+    @param
+        Parameter   |Requirement    |Type   | Description
+        ----------------------------------------------------------
+        uri         |Required       |string |
+        destination |Required       |object | target device address include adapter, flags, ifindex, port and addr
+        question    |Required       |string | payload with specifiied question
+    @return
+    <b> For a call: </b>
+    @code
+    {
+        "returnValue"   : boolean,
+        "response" : object,
+        "errorText" : string
+    }
+
+    @endcode
+    @param              returnValue
+    Indicates if the call was succesful or not.
+    @param              response
+    Detailed information.
+    @param              errorText
+    Describes the error if call was not succesful.
+
+        Parameter         |Requirement    |Type   | Description
+        ----------------------------------------------------------
+        returnValue       |Required       |boolean| true means success, false means faild
+        response          |Optional       |object | value of requested resource
+        errorText         |Optional       |object | value of error text
+
+    @b Examples:
+    @code
+    luna-send -n 1 -f luna://com.example.service.iotivity.client/getResource '{"uri":"/a/fan", "question":"abc","destination": {"adapter": 1,"flags": 32,"ifindex": 2,"port": 54406,"addr": "fe80::ba27:ebff:fe04:f661%eth0"}}'
+    @endcode
+
+    Example response for a succesful call:
+    @code
+    {
+        "returnValue": true,
+        "response": {
+            "devAddr": {
+                "adapter": 1,
+                "flags": 82,
+                "ifindex": 0,
+                "port": 34711,
+                "addr": "10.177.242.177"
+            },
+            "connType": 65618,
+            "addr": {
+                "adapter": 1,
+                "flags": 82,
+                "ifindex": 0,
+                "port": 34711,
+                "addr": "10.177.242.177"
+            },
+            "sequenceNumber": 16777216,
+            "result": 0,
+            "identity": [
+                49,
+                49,
+                49,
+                49,
+                49,
+                49,
+                49,
+                49,
+                49,
+                49,
+                49,
+                49,
+                49,
+                49,
+                49,
+                49
+            ],
+            "payload": {
+                "type": 4,
+                "values": {
+                    "answer": "123"
+                }
+            },
+            "resourceUri": "/a/fan"
+        }
+    }
+    @endcode
+*/
+service.register("getResource", function(message) {
+    var uri = message.payload.uri;
+    var question = message.payload.question;
+    var destination = message.payload.destination;
+
+    if(!uri){
+        message.respond({
+            errorText : "invalid uri",
+            returnValue : false
+        });
+        return;
+    }
+    else if(!destination
+        || !destination.adapter
+        || !destination.flags
+        || !destination.port
+        || !destination.addr ){
+        message.respond({
+            errorText : "invalid destination formats",
+            returnValue : false
+        });
+        return;
+    }
+    else if(!question){
+        message.respond({
+            errorText : "invalid question",
+            returnValue : false
+        });
+        return;
+    }
+
+    client.getResource(validateUri(uri), destination, question, function(response) {
+        message.respond({
+            response : response,
+            returnValue : true
+        });
+    });
+});
+
+/*
+    Delete resource from specified URI
+
+    @b Syntax \n
+    luna://com.example.service.iotivity.client/deleteResource
+
+    @code
+    {
+    }
+    @endcode
+    @param
+        Parameter   |Requirement    |Type   | Description
+        ----------------------------------------------------------
+        uri         |Required       |string | uri which is removed
+        destination |Required       |object | target device address include adapter, flags, ifindex, port and addr
+    @return
+    <b> For a call: </b>
+    @code
+    {
+        "returnValue"   : boolean,
+        "response" : object,
+        "errorText" : string
+    }
+
+    @endcode
+    @param              returnValue
+    Indicates if the call was succesful.
+    @param              response
+    Detailed information for removed resources.
+    @param              errorText
+    Describes the error if call was not succesful.
+
+        Parameter         |Requirement    |Type   | Description
+        ----------------------------------------------------------
+        returnValue       |Required       |boolean| true means success, false means faild
+        response          |Optional       |object | value of requested resource
+        errorText         |Optional       |string | value of error text
+    @remarks
+    The \e returnValue will be true as long as the syntax is correct, even if the process ID is not a valid one.
+
+    @b Examples:
+    @code
+    luna-send -n 1 -f luna://com.example.service.iotivity.client/deleteResource '{"uri":"/a/fan","destination":{"adapter":1,"flags":32,"ifindex":0,"port":35128,"addr":"fe80::ba27:ebff:fe04:f661%eth0"}}'
+    @endcode
+
+    Example response for a succesful call:
+    @code
+    {
+        "returnValue": true,
+        "response": {
+            "sequenceNumber": 16777216,
+            "identity": [
+            ],
+            "devAddr": {
+                "adapter": 1,
+                "flags": 32,
+                "ifindex": 2,
+                "port": 35128,
+                "addr": "fe80::ba27:ebff:fe04:f661%eth0"
+            },
+            "connType": 65568,
+            "result": 2,
+            "addr": {
+                "adapter": 1,
+                "flags": 32,
+                "ifindex": 2,
+                "port": 35128,
+                "addr": "fe80::ba27:ebff:fe04:f661%eth0"
+            },
+            "resourceUri": "/a/fan"
+        }
+    }
+    @endcode
+*/
+service.register("deleteResource", function(message) {
+    var uri = message.payload.uri;
+    var destination = message.payload.destination;
+    if(!uri){
+        message.respond({
+            errorText : "invalid uri",
+            returnValue : false
+        });
+        return;
+    }
+    else if(!destination
+        || !destination.adapter
+        || !destination.flags
+        || !destination.port
+        || !destination.addr ){
+        message.respond({
+            errorText : "invalid destination formats",
+            returnValue : false
+        });
+        return;
+    }
+    client.deleteResource(validateUri(uri), destination, function(response) {
+        message.respond({
+            response : response,
+            returnValue : true
+        });
+    });
+});
+
+/*
+    Observe the value of resource from specified URI
+
+    @b Syntax \n
+    luna://com.example.service.iotivity.client/observeResource
+
+    @code
+    {
+    }
+    @endcode
+    @param
+        Parameter   |Requirement    |Type   | Description
+        ----------------------------------------------------------
+        subscribe   |Required       |boolean |
+        uri         |Required       |string |
+        destination |Required       |object | target device address include adapter, flags, ifindex, port and addr
+    @return
+    <b> For a call: </b>
+    @code
+    {
+        "returnValue"   : boolean,
+        "response" : object,
+        "errorText" : string
+    }
+
+    @endcode
+    @param              returnValue
+    Indicates if the call was succesful.
+    @param              response
+    Detailed information for removed resources.
+    @param              errorText
+    Describes the error if call was not succesful.
+
+        Parameter         |Requirement    |Type   | Description
+        ----------------------------------------------------------
+        returnValue       |Required       |boolean| true means success, false means faild
+        response          |Required       |object | value of requested resource
+        errorText         |Optional       |string | value of error text
+    @remarks
+    The \e returnValue will be true as long as the syntax is correct, even if the process ID is not a valid one.
+
+    @b Examples:
+    @code
+    luna-send -n 1 -f luna://com.example.service.iotivity.client/observeResource '{"uri":"/a/fan","destination":{"adapter":1,"flags":32,"ifindex":0,"port":58941,"addr":"fe80::ba27:ebff:fe04:f661%eth0"},"subscribe":true}'
+    @endcode
+
+    Example response for a succesful call:
+    @code
+    {
+        "subscribed": true,
+        "returnValue": true,
+        "response": {
+            "devAddr": {
+                "adapter": 1,
+                "flags": 32,
+                "ifindex": 2,
+                "port": 58941,
+                "addr": "fe80::ba27:ebff:fe04:f661%eth0"
+            },
+            "connType": 65568,
+            "addr": {
+                "adapter": 1,
+                "flags": 32,
+                "ifindex": 2,
+                "port": 58941,
+                "addr": "fe80::ba27:ebff:fe04:f661%eth0"
+            },
+            "sequenceNumber": 23,
+            "result": 0,
+            "identity": [
+            ],
+            "payload": {
+                "type": 4,
+                "values": {
+                    "someOtherValue": "Espoo",
+                    "someValue": 18
+                }
+            },
+            "resourceUri": "/a/fan"
+        }
+    }
+    @endcode
+*/
+var clientObserve = service.register("observeResource");
+clientObserve.on("request", function(message) {
+    var uri = message.payload.uri;
+    var destination = message.payload.destination;
+    if(!uri){
+        message.respond({
+            errorText : "invalid uri",
+            returnValue : false,
+            subscribed : false
+        });
+        return;
+    }
+    else if(!destination
+        || !destination.adapter
+        || !destination.flags
+        || !destination.port
+        || !destination.addr ){
+        message.respond({
+            errorText : "invalid destination formats",
+            returnValue : false,
+            subscribed : false
+        });
+        return;
+    }
+    if (message.isSubscription) {
+        subscriptions[message.uniqueToken] = message;
+        client.observeResource(validateUri(uri), destination, subscriptionCallback);
+    } else {
+        message.respond({
+            returnValue : false,
+            subscribed : false,
+        });
+    }
+});
+clientObserve.on("cancel", function(message) {
+    delete subscriptions[message.uniqueToken];
+    var uri = message.payload.uri;
+    client.cancelObservation(uri);
+    message.respond({
+        returnValue : true,
+        subscribed : false
+    });
+});
\ No newline at end of file
diff --git a/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.client/oic_svr_db_client.json b/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.client/oic_svr_db_client.json
new file mode 100644
index 0000000..54aecee
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.client/oic_svr_db_client.json
@@ -0,0 +1,61 @@
+{
+    "acl": {
+        "aclist2": [
+            {
+                "aceid": 1,
+                "subject": { "conntype": "anon-clear" },
+                "resources": [
+                    { "href": "/oic/res" },
+                    { "href": "/oic/d" },
+                    { "href": "/oic/p" },
+                    { "href": "/oic/sec/doxm" }
+                ],
+                "permission": 2
+            },
+            {
+                "aceid": 2,
+                "subject": { "conntype": "auth-crypt" },
+                "resources": [
+                    { "href": "/oic/res" },
+                    { "href": "/oic/d" },
+                    { "href": "/oic/p" },
+                    { "href": "/oic/sec/doxm" }
+                ],
+                "permission": 2
+            }
+        ],
+        "rowneruuid" : "31393139-3139-3139-3139-313931393139"
+    },
+    "pstat": {
+        "dos": {"s": 3, "p": false},
+        "isop": true,
+        "rowneruuid": "31393139-3139-3139-3139-313931393139",
+        "cm": 0,
+        "tm": 0,
+        "om": 4,
+        "sm": 4
+        },
+    "doxm": {
+        "oxms": [0],
+        "oxmsel": 0,
+        "sct": 9,
+        "owned": true,
+        "deviceuuid": "31393139-3139-3139-3139-313931393139",
+        "devowneruuid": "31393139-3139-3139-3139-313931393139",
+        "rowneruuid": "31393139-3139-3139-3139-313931393139"
+    },
+    "cred": {
+        "creds": [
+            {
+                "credid": 1,
+                "subjectuuid": "31313131-3131-3131-3131-313131313131",
+                "credtype": 1,
+                "privatedata": {
+                    "data": "BBBBBBBBBBBBBBBB",
+                    "encoding": "oic.sec.encoding.raw"
+                }
+            }
+        ],
+        "rowneruuid": "31393139-3139-3139-3139-313931393139"
+    }
+}
diff --git a/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.client/package.json b/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.client/package.json
new file mode 100644
index 0000000..6b3539b
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.client/package.json
@@ -0,0 +1,4 @@
+{
+   "name" : "com.example.service.iotivity.client",
+   "main" : "main.js"
+}
diff --git a/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/com.example.service.iotivity.server.json b/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/com.example.service.iotivity.server.json
new file mode 100644
index 0000000..6ed74bd
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/com.example.service.iotivity.server.json
@@ -0,0 +1,3 @@
+{
+  "services" : ["com.example.service.iotivity.server"]
+}
diff --git a/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/files/sysbus/com.example.service.iotivity.server.api.json b/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/files/sysbus/com.example.service.iotivity.server.api.json
new file mode 100644
index 0000000..d7b55c9
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/files/sysbus/com.example.service.iotivity.server.api.json
@@ -0,0 +1,12 @@
+{
+    "public": [
+        "com.example.service.iotivity.server/startServer",
+        "com.example.service.iotivity.server/createResource",
+        "com.example.service.iotivity.server/deleteResource",
+    ],
+    "private": [
+        "com.example.service.iotivity.server/startServer",
+        "com.example.service.iotivity.server/createResource",
+        "com.example.service.iotivity.server/deleteResource",
+    ]
+}
diff --git a/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/files/sysbus/com.example.service.iotivity.server.manifest.json b/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/files/sysbus/com.example.service.iotivity.server.manifest.json
new file mode 100644
index 0000000..0234aef
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/files/sysbus/com.example.service.iotivity.server.manifest.json
@@ -0,0 +1,13 @@
+{
+    "roleFiles": [
+        "/usr/share/luna-service2/roles.d/com.example.service.iotivity.server.role.json"
+    ],
+    "id": "com.example.service.iotivity.server",
+    "version": "1.0.0",
+    "clientPermissionFiles": [
+        "/usr/share/luna-service2/client-permissions.d/com.example.service.iotivity.server.perm.json"
+    ],
+    "serviceFiles": [
+        "/usr/share/luna-service2/services.d/com.example.service.iotivity.server.service"
+    ]
+}
\ No newline at end of file
diff --git a/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/files/sysbus/com.example.service.iotivity.server.perm.json b/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/files/sysbus/com.example.service.iotivity.server.perm.json
new file mode 100644
index 0000000..d16dc76
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/files/sysbus/com.example.service.iotivity.server.perm.json
@@ -0,0 +1,3 @@
+{
+  "com.example.service.iotivity.server*" : ["activities.manage", "networking.internal"]
+}
diff --git a/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/files/sysbus/com.example.service.iotivity.server.role.json b/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/files/sysbus/com.example.service.iotivity.server.role.json
new file mode 100644
index 0000000..a5aaa09
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/files/sysbus/com.example.service.iotivity.server.role.json
@@ -0,0 +1,11 @@
+{
+    "appId" : "com.example.service.iotivity.server",
+    "allowedNames" : ["com.example.service.iotivity.server*"],
+    "type" : "regular",
+    "permissions" : [
+	{
+        "service" : "com.example.service.iotivity.server*",
+        "inbound" : ["*"],
+        "outbound" : ["*"]
+    }]
+}
diff --git a/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/files/sysbus/com.example.service.iotivity.server.service b/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/files/sysbus/com.example.service.iotivity.server.service
new file mode 100644
index 0000000..a98ea16
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/files/sysbus/com.example.service.iotivity.server.service
@@ -0,0 +1,23 @@
+#******************************************************************
+#
+# Copyright (c) 2018 LG Electronics, Inc.
+#
+#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+[D-BUS Service]
+Name = com.example.service.iotivity.server*
+Exec = /usr/bin/run-js-service /usr/palm/services/com.example.service.iotivity.server
diff --git a/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/main.js b/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/main.js
new file mode 100644
index 0000000..91dc157
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/main.js
@@ -0,0 +1,273 @@
+/* ******************************************************************
+ *
+ * Copyright (c) 2018 LG Electronics, Inc.
+ *
+ *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+ */
+var Service = require('webos-service');
+var service = new Service('com.example.service.iotivity.server');
+
+var subscriptions = {};
+
+var server = require('./server-lowlevel');
+
+function isEmpty(obj) {
+    for ( var key in obj) {
+        if (obj.hasOwnProperty(key))
+            return false;
+    }
+    return true;
+};
+
+function subscriptionCallback(response) {
+    for (var i in subscriptions){
+        if (subscriptions.hasOwnProperty(i)) {
+            var s = subscriptions[i];
+            s.respond({
+                response : response,
+                returnValue : true,
+                subscribed : true
+            });
+        }
+    }
+};
+
+function validateUri(_uri){
+    if(_uri.charAt(0)!="/")
+        return "/"+_uri;
+    else return _uri;
+}
+
+/*
+    To Start iotivity server with iotivity-node
+
+    @b Syntax \n
+    luna://com.example.service.iotivity.server/startServer
+
+    @code
+    {
+    }
+    @endcode
+    @param
+        Parameter   |Requirement    |Type    | Description
+        ----------------------------------------------------------
+        subscribe   |Required       |boolean |
+    @return
+    <b> For a call: </b>
+    @code
+    {
+        "returnValue"   : boolean,
+        "subscribed" : boolean,
+    }
+
+    @endcode
+    @param              returnValue
+    Indicates if the call was succesful or not.
+    @param              subscribed
+    Detailed information for removed resources.
+
+        Parameter         |Requirement    |Type   | Description
+        ----------------------------------------------------------
+        returnValue       |Required       |boolean| true means success, false means faild
+        subscribed        |Required       |boolean| value of requested resource
+    @remarks
+    The \e returnValue will be true as long as the syntax is correct, even if the process ID is not a valid one.
+
+    @b Examples:
+    @code
+    luna-send -i -f luna://com.example.service.iotivity.server/startServer '{"subscribe":true}'&
+    @endcode
+
+    Example response for a succesful call:
+    @code
+    {
+        "resources": [
+        ],
+        "subscribed": true,
+        "returnValue": true
+    }
+    {
+        "resources": [
+            {
+                "interfaces": [
+                    "oic.if.baseline"
+                ],
+                "types": [
+                    "core.fan"
+                ],
+                "uri": "a/fan"
+            }
+        ],
+        "subscribed": true,
+        "returnValue": true
+    }
+    @endcode
+*/
+var serverDiscoverable = service.register("startServer");
+serverDiscoverable.on("request", function(message) {
+    if (message.isSubscription) {
+        if (isEmpty(subscriptions)){
+            subscriptions[message.uniqueToken] = message;
+            server.startServer(subscriptionCallback);
+        } else {
+            subscriptions[message.uniqueToken] = message;
+        }
+    } else {
+        message.respond({
+            returnValue : false,
+            subscribed : false
+        });
+    }
+});
+serverDiscoverable.on("cancel", function(message) {
+    delete subscriptions[message.uniqueToken];
+    if (isEmpty(subscriptions))
+        server.stopServer();
+    message.respond({returnValue : true});
+});
+
+/*
+    To create resource
+
+    @b Syntax \n
+    luna://com.example.service.iotivity.server/createResource
+
+    @code
+    {
+    }
+    @endcode
+    @param
+        Parameter   |Requirement    |Type   | Description
+        ----------------------------------------------------------
+        uri         |Required       |string |
+        types       |Required       |string |
+        question    |Required       |string |
+        answer      |Required       |string |
+        observable  |Required       |boolean|
+    @return
+    <b> For a call: </b>
+    @code
+    {
+        "returnValue"   : boolean,
+    }
+
+    @endcode
+    @param              returnValue
+    Indicates if the call was succesful or not.
+    @param              subscribed
+    Detailed information for removed resources.
+
+        Parameter         |Requirement    |Type   | Description
+        ----------------------------------------------------------
+        returnValue       |Required       |boolean| true means success, false means faild
+    @remarks
+    The \e returnValue will be true as long as the syntax is correct, even if the process ID is not a valid one.
+
+    @b Examples:
+    @code
+    luna-send -1 -f luna://com.example.service.iotivity.server/createResource '{"uri":"a/fan","question":"abc","answer":"123","observable":true,"types":"core.fan"}'
+    @endcode
+
+    Example response for a succesful call:
+    @code
+    {
+        "returnValue": true
+    }
+    @endcode
+*/
+service.register("createResource", function(message){
+    var uri = message.payload.uri;
+    var types = message.payload.types;
+    var interfaces = message.payload.interfaces;
+    var observable = message.payload.observable;
+    var q = message.payload.question;
+    var a = message.payload.answer;
+
+    if( !uri || !types || !q || !a ){
+        message.respond({
+            errorText : "invalid destination formats",
+            returnValue : false,
+            subscribed : false
+        });
+    }
+    else{
+        server.createResource(validateUri(uri), types, q, a, observable, subscriptionCallback);
+        message.respond({ returnValue : true });
+    }
+});
+
+/*
+    To delete resource with specific URI
+
+    @b Syntax \n
+    luna://com.example.service.iotivity.server/deleteResource
+
+    @code
+    {
+    }
+    @endcode
+    @param
+        Parameter   |Requirement    |Type   | Description
+        ----------------------------------------------------------
+        uri         |Required       |string |
+
+    @return
+    <b> For a call: </b>
+    @code
+    {
+        "returnValue"   : boolean,
+    }
+
+    @endcode
+    @param              returnValue
+    Indicates if the call was succesful or not.
+    @param              subscribed
+    Detailed information for removed resources.
+
+        Parameter         |Requirement    |Type   | Description
+        ----------------------------------------------------------
+        returnValue       |Required       |boolean| true means success, false means faild
+    @remarks
+    The \e returnValue will be true as long as the syntax is correct, even if the process ID is not a valid one.
+
+    @b Examples:
+    @code
+    luna-send -1 -f luna://com.example.service.iotivity.server/deleteResource '{"uri":"/a/fan"}'
+    @endcode
+
+    Example response for a succesful call:
+    @code
+    {
+        "returnValue": true
+    }
+    @endcode
+*/
+service.register("deleteResource", function(message){
+    var uri = message.payload.uri;
+    if(!uri){
+        message.respond({
+            errorText : "invalid uri",
+            returnValue : false,
+            subscribed : false
+        });
+        return;
+    }
+    else{
+        server.deleteResource(validateUri(uri), subscriptionCallback);
+        message.respond({ returnValue : true });
+    }
+});
\ No newline at end of file
diff --git a/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/mock-sensor.js b/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/mock-sensor.js
new file mode 100644
index 0000000..cae7e6b
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/mock-sensor.js
@@ -0,0 +1,59 @@
+// Copyright 2016 Intel Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// This mock sensor implementation triggers an event with some data every once in a while
+
+// Return a random integer between 0 and @upperLimit
+function randomInteger( upperLimit ) {
+	return Math.round( Math.random() * upperLimit );
+}
+
+var _ = {
+    extend: require( "iotivity-node/node_modules/lodash.assignin" ),
+    bind: require( "iotivity-node/node_modules/lodash.bind" )
+};
+
+var possibleStrings = [
+    "Helsinki",
+    "Espoo",
+    "Tampere",
+    "Oulu",
+    "Mikkeli",
+    "Ii"
+];
+
+var MockSensor = function MockSensor() {
+    function trigger() {
+        this.emit( "change", this.currentData() );
+        setTimeout( _.bind( trigger, this ), randomInteger( 1000 ) + 1000 );
+    }
+    if ( !this._isMockSensor ) {
+        return new MockSensor();
+    }
+    setTimeout( _.bind( trigger, this ), randomInteger( 1000 ) + 1000 );
+};
+
+require( "util" ).inherits( MockSensor, require( "events" ).EventEmitter );
+
+_.extend( MockSensor.prototype, {
+    _isMockSensor: true,
+    currentData: function() {
+        return {
+            someValue: Math.round( Math.random() * 42 ),
+            someOtherValue: possibleStrings[ randomInteger( possibleStrings.length - 1 ) ]
+        };
+    }
+} );
+
+module.exports = MockSensor;
diff --git a/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/oic_svr_db_server.json b/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/oic_svr_db_server.json
new file mode 100644
index 0000000..384ffc4
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/oic_svr_db_server.json
@@ -0,0 +1,90 @@
+{
+    "acl": {
+        "aclist2": [
+            {
+                "aceid": 1,
+                "subject": { "conntype": "anon-clear" },
+                "resources": [
+                    { "href": "/oic/res" },
+                    { "href": "/oic/d" },
+                    { "href": "/oic/p" },
+                    { "href": "/oic/sec/doxm" }
+                ],
+                "permission": 2
+            },
+            {
+                "aceid": 2,
+                "subject": { "conntype": "auth-crypt" },
+                "resources": [
+                    { "href": "/oic/res" },
+                    { "href": "/oic/d" },
+                    { "href": "/oic/p" },
+                    { "href": "/oic/sec/doxm" }
+                ],
+                "permission": 2
+            },
+            {
+                "aceid": 3,
+                "subject": { "conntype": "anon-clear" },
+                "resources": [{ "href": "/a/fan" }],
+                "permission": 31
+            },
+            {
+                "aceid": 4,
+                "subject": { "conntype": "auth-crypt" },
+                "resources": [{ "href": "/a/fan" }],
+                "permission": 31
+            },
+            {
+                "aceid": 5,
+                "subject": { "uuid": "31393139-3139-3139-3139-313931393139" },
+                "resources": [{ "href": "/a/light" }],
+                "permission": 31
+            }
+        ],
+        "rowneruuid" : "31313131-3131-3131-3131-313131313131"
+    },
+    "pstat": {
+        "dos": {"s": 3, "p": false},
+        "isop": true,
+        "rowneruuid": "31313131-3131-3131-3131-313131313131",
+        "cm": 0,
+        "tm": 0,
+        "om": 4,
+        "sm": 4
+        },
+    "doxm": {
+        "oxms": [0],
+        "oxmsel": 0,
+        "sct": 9,
+        "owned": true,
+        "deviceuuid": "31313131-3131-3131-3131-313131313131",
+        "devowneruuid": "32323232-3232-3232-3232-323232323232",
+        "rowneruuid": "31313131-3131-3131-3131-313131313131"
+    },
+    "cred": {
+        "creds": [
+            {
+                "credid": 1,
+                "subjectuuid": "32323232-3232-3232-3232-323232323232",
+                "credtype": 1,
+                "period": "20150630T060000/20990920T220000",
+                "privatedata": {
+                    "data": "AAAAAAAAAAAAAAAA",
+                    "encoding": "oic.sec.encoding.raw"
+                }
+            },
+            {
+                "credid": 2,
+                "subjectuuid": "31393139-3139-3139-3139-313931393139",
+                "credtype": 1,
+                "period": "20150630T060000/20990920T220000",
+                "privatedata": {
+                    "data": "BBBBBBBBBBBBBBBB",
+                    "encoding": "oic.sec.encoding.raw"
+                }
+            }
+        ],
+        "rowneruuid": "32323232-3232-3232-3232-323232323232"
+    }
+}
diff --git a/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/package.json b/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/package.json
new file mode 100644
index 0000000..1dc5321
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/package.json
@@ -0,0 +1,4 @@
+{
+   "name" : "com.example.service.iotivity.server",
+   "main" : "main.js"
+}
diff --git a/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/server-lowlevel.js b/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/server-lowlevel.js
new file mode 100644
index 0000000..39a616e
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/server-lowlevel.js
@@ -0,0 +1,228 @@
+/* ******************************************************************
+ *
+ * Copyright (c) 2018 LG Electronics, Inc.
+ *
+ *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+ */
+var intervalId, initialResourceCount;
+var iotivity = require("iotivity-node/lowlevel");
+var StorageHandler = require("iotivity-node/lib/CustomStorageHandler");
+
+module.exports.startServer = function(resourceCallback) {
+    console.log("Starting OCF stack in server mode");
+
+    iotivity.OCRegisterPersistentStorageHandler(StorageHandler("oic_svr_db_server.dat"));
+
+    // Start iotivity and set up the processing loop
+    iotivity.OCInit(null, 0, iotivity.OCMode.OC_SERVER);
+
+    intervalId = setInterval(function() {
+        iotivity.OCProcess();
+    }, 1000);
+
+    iotivity.OCSetPropertyValue(iotivity.OCPayloadType.PAYLOAD_TYPE_DEVICE,
+                    iotivity.OC_RSRVD_SPEC_VERSION, "res.1.3.0");
+    iotivity.OCSetPropertyValue(iotivity.OCPayloadType.PAYLOAD_TYPE_DEVICE,
+                    iotivity.OC_RSRVD_DATA_MODEL_VERSION, "webosose.1.0.0");
+    iotivity.OCSetPropertyValue(iotivity.OCPayloadType.PAYLOAD_TYPE_DEVICE,
+                    iotivity.OC_RSRVD_DEVICE_NAME, "server.example");
+    iotivity.OCSetPropertyValue(iotivity.OCPayloadType.PAYLOAD_TYPE_PLATFORM,
+                    iotivity.OC_RSRVD_MFG_NAME, "lge-iotivity-node");
+
+    console.log("Server ready");
+
+    var countReceptacle = {};
+    var result = iotivity.OCGetNumberOfResources(countReceptacle);
+    initialResourceCount = countReceptacle.count;
+    updateServerStatus(resourceCallback);
+
+};
+
+module.exports.createResource = function(uri, types, q, a, observable, resourceCallback) {
+    console.log("Registering resources");
+
+    var handleReceptacle = {};
+    var observerIds = [];
+    var properties = iotivity.OCResourceProperty.OC_DISCOVERABLE
+        | iotivity.OCResourceProperty.OC_SECURE;
+
+    if(observable){
+        properties= properties|iotivity.OCResourceProperty.OC_OBSERVABLE;
+    }
+
+    var sensor = require( "./mock-sensor" )()
+        .on( "change", function( data ) {
+            if(observerIds.lenght>0) {
+                iotivity.OCNotifyListOfObservers(
+                    handleReceptacle.handle,
+                    observerIds,
+                    {
+                        type: iotivity.OCPayloadType.PAYLOAD_TYPE_REPRESENTATION,
+                        values: data
+                    },
+                    iotivity.OCQualityOfService.OC_HIGH_QOS );
+            }
+        }
+    );
+
+    iotivity.OCCreateResource(
+
+        // The bindings fill in this object
+        handleReceptacle,
+        types,
+        iotivity.OC_RSRVD_INTERFACE_DEFAULT,
+        uri,
+        function( flag, request ) {
+            console.log( "Entity handler called with flag = " + flag + " and the following request:" );
+            console.log( JSON.stringify( request, null, 4 ) );
+
+            // If we find the magic question in the request, we return the magic answer
+            if ( request && request.payload && request.payload.values &&
+                request.payload.values.question===q) {
+                iotivity.OCDoResponse( {
+                    requestHandle: request.requestHandle,
+                    resourceHandle: request.resource,
+                    ehResult: iotivity.OCEntityHandlerResult.OC_EH_OK,
+                    payload: {
+                        type: iotivity.OCPayloadType.PAYLOAD_TYPE_REPRESENTATION,
+                        values: {
+                            "answer": a
+                        }
+                    },
+                    resourceUri: uri,
+                    sendVendorSpecificHeaderOptions: []
+                } );
+
+                return iotivity.OCEntityHandlerResult.OC_EH_OK;
+            }
+            if ( request && request.method === iotivity.OCMethod.OC_REST_DELETE ) {
+
+                var result = iotivity.OCDeleteResource( handleReceptacle.handle );
+
+                console.log( "OCDeleteResource() has resulted in " + result );
+
+                iotivity.OCDoResponse( {
+                    requestHandle: request.requestHandle,
+                    resourceHandle: null,
+                    ehResult: result ?
+                        iotivity.OCEntityHandlerResult.OC_EH_ERROR :
+                        iotivity.OCEntityHandlerResult.OC_EH_RESOURCE_DELETED,
+                    payload: null,
+                    resourceUri: uri,
+                    sendVendorSpecificHeaderOptions: []
+                } );
+
+                return iotivity.OCEntityHandlerResult.OC_EH_OK;
+            }
+            if ( flag & iotivity.OCEntityHandlerFlag.OC_OBSERVE_FLAG ) {
+                if ( request.obsInfo.obsId !== 0 ) {
+                    if ( request.obsInfo.action === iotivity.OCObserveAction.OC_OBSERVE_REGISTER ) {
+
+                        // Add new observer to list.
+                        observerIds.push( request.obsInfo.obsId );
+                    } else if ( request.obsInfo.action ===
+                            iotivity.OCObserveAction.OC_OBSERVE_DEREGISTER ) {
+
+                        // Remove requested observer from list.
+                        observerIdIndex = observerIds.indexOf( request.obsInfo.obsId );
+                        if ( observerIdIndex >= 0 ) {
+                            observerIds.splice( observerIdIndex, 1 );
+                        }
+                    }
+                }
+            }
+            if ( request.requestHandle ) {
+                iotivity.OCDoResponse( {
+                    requestHandle: request.requestHandle,
+                    resourceHandle: request.resource,
+                    ehResult: iotivity.OCEntityHandlerResult.OC_EH_OK,
+                    payload: {
+                        type: iotivity.OCPayloadType.PAYLOAD_TYPE_REPRESENTATION,
+                        values: sensor.currentData()
+                    },
+                    resourceUri: uri,
+                    sendVendorSpecificHeaderOptions: []
+                } );
+            }
+
+        // By default we error out
+        return iotivity.OCEntityHandlerResult.OC_EH_OK;
+    }, properties);
+
+    console.log(uri + " resource ready");
+
+    updateServerStatus(resourceCallback);
+};
+
+function updateServerStatus(resourceCallback) {
+    var countReceptacle = {};
+    var result = iotivity.OCGetNumberOfResources(countReceptacle);
+    var resources = [];
+    for (var index = initialResourceCount; index < countReceptacle.count; index++) {
+        var resource = {};
+        resource.types = [];
+        resource.interfaces = [];
+
+        var handle = iotivity.OCGetResourceHandle(index);
+        resource.uri = iotivity.OCGetResourceUri(handle);
+
+        var countRecep = {};
+        result = iotivity.OCGetNumberOfResourceTypes(handle, countRecep);
+        for (var i = 0; i < countRecep.count; i++) {
+            resource.types[i] = iotivity.OCGetResourceTypeName(handle, i);
+        }
+
+        result = iotivity.OCGetNumberOfResourceInterfaces(handle, countRecep);
+        for (i = 0; i < countRecep.count; i++) {
+            resource.interfaces[i] = iotivity.OCGetResourceInterfaceName(handle, i);
+        }
+
+        resources[index - initialResourceCount] = resource;
+    }
+    resourceCallback(resources);
+};
+
+module.exports.stopServer = function() {
+    // Tear down the processing loop and stop iotivity
+    clearInterval(intervalId);
+    iotivity.OCStop();
+    console.log("=== server teardown ===");
+};
+
+module.exports.deleteResource = function(uri, resourceCallback) {
+    var countReceptacle = {};
+    var handle;
+
+    var result = iotivity.OCGetNumberOfResources(countReceptacle);
+    var count = countReceptacle.count;
+    for (var index = initialResourceCount; index < count; index++) {
+        handle = iotivity.OCGetResourceHandle(index);
+        if (uri == null) {
+            iotivity.OCDeleteResource(handle);
+            index--;
+            count--;
+            continue;
+        }
+
+        if (uri == iotivity.OCGetResourceUri(handle)) {
+            iotivity.OCDeleteResource(handle);
+            break;
+        }
+    }
+
+    updateServerStatus(resourceCallback);
+};
diff --git a/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/server.txt b/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/server.txt
new file mode 100644
index 0000000..3514482
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/com.example.app.iotivity/services/com.example.service.iotivity.server/server.txt
@@ -0,0 +1,167 @@
+API Docs - com.exampel.service.iotivity.server
+
+
+startServer
+
+    To Start iotivity server with iotivity-node
+
+    @b Syntax \n
+    luna://com.example.service.iotivity.server/startServer
+
+    @code
+    {
+    }
+    @endcode
+    @param
+        Parameter   |Requirement    |Type    | Description
+        ----------------------------------------------------------
+        subscribe   |Required       |boolean |
+    @return
+    <b> For a call: </b>
+    @code
+    {
+        "returnValue"   : boolean,
+        "subscribed" : boolean,
+    }
+
+    @endcode
+    @param              returnValue
+    Indicates if the call was succesful or not.
+    @param              subscribed
+    Detailed information for removed resources.
+
+        Parameter         |Requirement    |Type   | Description
+        ----------------------------------------------------------
+        returnValue       |Required       |boolean| true means success, false means faild
+        subscribed        |Required       |boolean| value of requested resource
+    @remarks
+    The \e returnValue will be true as long as the syntax is correct, even if the process ID is not a valid one.
+
+    @b Examples:
+    @code
+    luna-send -i -f luna://com.example.service.iotivity.server/startServer '{"subscribe":true}'&
+    @endcode
+
+    Example response for a succesful call:
+    @code
+    {
+        "resources": [
+        ],
+        "subscribed": true,
+        "returnValue": true
+    }
+    {
+        "resources": [
+            {
+                "interfaces": [
+                    "oic.if.baseline"
+                ],
+                "types": [
+                    "core.fan"
+                ],
+                "uri": "a/fan"
+            }
+        ],
+        "subscribed": true,
+        "returnValue": true
+    }
+    @endcode
+
+
+createResource
+
+    To create resource
+
+    @b Syntax \n
+    luna://com.example.service.iotivity.server/createResource
+
+    @code
+    {
+    }
+    @endcode
+    @param
+        Parameter   |Requirement    |Type   | Description
+        ----------------------------------------------------------
+        uri         |Required       |string |
+        types       |Required       |string |
+        question    |Required       |string |
+        answer      |Required       |string |
+        observable  |Optional       |boolean|
+    @return
+    <b> For a call: </b>
+    @code
+    {
+        "returnValue"   : boolean,
+    }
+
+    @endcode
+    @param              returnValue
+    Indicates if the call was succesful or not.
+    @param              subscribed
+    Detailed information for removed resources.
+
+        Parameter         |Requirement    |Type   | Description
+        ----------------------------------------------------------
+        returnValue       |Required       |boolean| true means success, false means faild
+    @remarks
+    The \e returnValue will be true as long as the syntax is correct, even if the process ID is not a valid one.
+
+    @b Examples:
+    @code
+    luna-send -1 -f luna://com.example.service.iotivity.server/createResource '{"uri":"a/fan","question":"abc","answer":"123","observable":true,"types":"core.fan"}'
+    @endcode
+
+    Example response for a succesful call:
+    @code
+    {
+        "returnValue": true
+    }
+    @endcode
+
+
+deleteResource
+
+    To delete resource with specific URI
+
+    @b Syntax \n
+    luna://com.example.service.iotivity.server/deleteResource
+
+    @code
+    {
+    }
+    @endcode
+    @param
+        Parameter   |Requirement    |Type   | Description
+        ----------------------------------------------------------
+        uri         |Required       |string |
+
+    @return
+    <b> For a call: </b>
+    @code
+    {
+        "returnValue"   : boolean,
+    }
+
+    @endcode
+    @param              returnValue
+    Indicates if the call was succesful or not.
+    @param              subscribed
+    Detailed information for removed resources.
+
+        Parameter         |Requirement    |Type   | Description
+        ----------------------------------------------------------
+        returnValue       |Required       |boolean| true means success, false means faild
+    @remarks
+    The \e returnValue will be true as long as the syntax is correct, even if the process ID is not a valid one.
+
+    @b Examples:
+    @code
+    luna-send -1 -f luna://com.example.service.iotivity.server/deleteResource '{"uri":"/a/fan"}'
+    @endcode
+
+    Example response for a succesful call:
+    @code
+    {
+        "returnValue": true
+    }
+    @endcode
\ No newline at end of file
diff --git a/resource/csdk/stack/samples/webos/com.example.app.iotivity/src/App/App.js b/resource/csdk/stack/samples/webos/com.example.app.iotivity/src/App/App.js
new file mode 100644
index 0000000..1a86b3f
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/com.example.app.iotivity/src/App/App.js
@@ -0,0 +1,26 @@
+import MoonstoneDecorator from '@enact/moonstone/MoonstoneDecorator';
+import Panels from '@enact/moonstone/Panels';
+import React from 'react';
+
+import MainPanel from '../views/MainPanel';
+
+class App extends React.Component {
+    constructor (props) {
+        super(props);
+	}
+	closeHandler() {
+		window.close();
+	}
+    render(props) {
+		const onClose = this.closeHandler.bind(this);
+		return (
+      		<div {...props}>
+            	<Panels onApplicationClose={onClose} >
+                	<MainPanel />
+            	</Panels>
+        	</div>
+    	);
+	}
+}
+
+export default MoonstoneDecorator(App);
diff --git a/resource/csdk/stack/samples/webos/com.example.app.iotivity/src/App/package.json b/resource/csdk/stack/samples/webos/com.example.app.iotivity/src/App/package.json
new file mode 100755
index 0000000..498cf52
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/com.example.app.iotivity/src/App/package.json
@@ -0,0 +1,3 @@
+{
+    "main": "App.js"
+}
diff --git a/resource/csdk/stack/samples/webos/com.example.app.iotivity/src/actions/ActionCreators.js b/resource/csdk/stack/samples/webos/com.example.app.iotivity/src/actions/ActionCreators.js
new file mode 100644
index 0000000..f3cc86f
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/com.example.app.iotivity/src/actions/ActionCreators.js
@@ -0,0 +1,269 @@
+import * as actions from './ActionTypes';
+import LS2Request from '@enact/webos/LS2Request';
+
+const ls2instances = {};
+
+export const LS2RequestSingleton = {
+    instance: function (skey, preventRepeat) {
+        if (preventRepeat && ls2instances[skey]) {
+            return false;
+        }
+
+        ls2instances[skey] = ls2instances[skey] || new LS2Request();
+        return ls2instances[skey];
+    },
+    deleteInstance: function (skey) {
+        ls2instances[skey] = null;
+    }
+};
+
+export function actionUpdateServerState (tf) {
+    return {
+        type: actions.UPDATE_SERVER,
+        payload: {"enabled":tf}
+    };
+}
+
+export function actionUpdateDiscoveredList (res) {
+    if(!res.addr){
+        setTimeout(function() {
+            const ls = LS2RequestSingleton.instance('discoverResources');
+            if (ls) {
+                ls.cancel();
+                LS2RequestSingleton.deleteInstance('discoverResources');
+            }
+        }, 5000, null)
+        return {
+            type: actions.SHOW_RESOURCES_LIST,
+            payload: res
+        };
+    }
+    else{
+        return {
+            type: actions.UPDATE_DISCOVERED_RESOURCES,
+            payload: res
+        };
+    }
+}
+
+export function actionResetDiscoveredList () {
+    return {
+        type: actions.RESET_DISCOVERED_RESOURCES,
+    };
+}
+
+export function actionEnableServerResourceControlUI(){
+    return {
+        type: actions.SHOW_SERVER_RESOURCE_CONTROL_UI,
+    };
+}
+
+export function actionDisableServerResourceControlUI(){
+    return {
+        type: actions.HIDE_SERVER_RESOURCE_CONTROL_UI,
+    };
+}
+
+export function actionEnableClientResourceControlUI(){
+    return {
+        type: actions.SHOW_CLIENT_RESOURCE_CONTROL_UI,
+    };
+}
+
+export function actionDisableClientResourceControlUI(){
+    return {
+        type: actions.HIDE_CLIENT_RESOURCE_CONTROL_UI,
+    };
+}
+
+export function actionUpdateGetResourceResults(result){
+    return {
+        type: actions.UPDATE_GET_RESOURCE_RESULTS,
+        payload: result
+    };
+}
+
+export function actionUpdateObserveResourceResults(result){
+    return {
+        type: actions.UPDATE_OBSERVE_RESOURCE_RESULTS,
+        payload: result
+    };
+}
+
+export const createToast = params => {
+    console.log('createToast');
+    return new LS2Request().send({
+        service: 'luna://com.webos.notification/',
+        method: 'createToast',
+        parameters:{noaction:true, message:params},
+        onComplete: (res) => {
+            console.log(res);
+            return;
+        }
+    });
+};
+
+export const startServer = (dispatch) =>  {
+    const ls = LS2RequestSingleton.instance('startServer', true);
+    if (ls) {
+        ls.send({
+            service: 'luna://com.example.service.iotivity.server/',
+            method: 'startServer',
+            parameters: {
+                subscribe: true
+            },
+            onComplete: (res) => {
+                if (res.subscribed) {
+                    dispatch(actionUpdateServerState(true));
+                    return;
+                }
+            },
+        });
+    }
+};
+
+export const stopServer = (dispatch) =>  {
+    const ls = LS2RequestSingleton.instance('startServer');
+    if (ls) {
+        ls.cancel();
+        dispatch(actionUpdateServerState(false));
+        dispatch(actionResetDiscoveredList([]));
+        LS2RequestSingleton.deleteInstance('startServer');
+    }
+};
+
+export const discoverResources = (dispatch) =>  {
+    const ls = LS2RequestSingleton.instance('discoverResources', true);
+    if (ls) {
+        ls.send({
+            service: 'luna://com.example.service.iotivity.client/',
+            method: 'discoverResources',
+            parameters: {
+                subscribe: true
+            },
+            onComplete: (res) => {
+                dispatch(actionUpdateDiscoveredList(res.discoveryResponse));
+            },
+        });
+    }
+};
+
+export const resetDiscoveredList = (dispatch) =>  {
+    const ls = LS2RequestSingleton.instance('discoverResources');
+    const ls2 = LS2RequestSingleton.instance('observeResource');
+    if (ls) {
+        ls.cancel();
+        dispatch(actionResetDiscoveredList([]));
+        LS2RequestSingleton.deleteInstance('discoverResources');
+    }
+    if (ls2) {
+        ls2.cancel();
+        dispatch(actionResetDiscoveredList([]));
+        LS2RequestSingleton.deleteInstance('observeResource');
+    }
+};
+
+export const createResource = params => dispatch => {
+    console.log('createResource');
+    return new LS2Request().send({
+        service: 'luna://com.example.service.iotivity.server/',
+        method: 'createResource',
+        parameters:params,
+        onComplete: (res) => {
+            if(res.returnValue){
+                createToast(params.uri +" resource is ready");
+                console.log(res);
+                dispatch(actionEnableServerResourceControlUI());
+				return;
+            }
+        }
+    });
+};
+
+export const deleteResource = params => dispatch => {
+    console.log('deleteServerResource');
+    return new LS2Request().send({
+        service: 'luna://com.example.service.iotivity.server/',
+        method: 'deleteResource',
+        parameters:params,
+        onComplete: (res) => {
+            if(res.returnValue){
+                createToast(params.uri +" resource is deleted");
+                console.log(res);
+                dispatch(actionEnableServerResourceControlUI());
+                return;
+            }
+        }
+    });
+};
+
+export const getResource = params => dispatch => {
+    console.log('getResource');
+    return new LS2Request().send({
+        service: 'luna://com.example.service.iotivity.client/',
+        method: 'getResource',
+        parameters:params,
+        onComplete: (res) => {
+            console.log(res);
+            if(res.response.payload){
+                dispatch(actionUpdateGetResourceResults(res.response));
+            }
+            else{
+                createToast("Fail to get resource");
+                dispatch(actionEnableClientResourceControlUI());
+            }
+            return;
+        }
+    });
+};
+
+export const requestDeleteResource = params => dispatch => {
+    console.log('requestDeleteResource');
+    return new LS2Request().send({
+        service: 'luna://com.example.service.iotivity.client/',
+        method: 'deleteResource',
+        parameters:params,
+        onComplete: (res) => {
+            if(res.returnValue){
+                createToast(params.uri +" resource is deleted");
+                console.log(res);
+                dispatch(actionDisableClientResourceControlUI());
+                return;
+            }
+        }
+    });
+};
+
+export const observeResource = params => dispatch => {
+    const ls = LS2RequestSingleton.instance('observeResource', true);
+    if (ls) {
+        ls.send({
+            service: 'luna://com.example.service.iotivity.client/',
+            method: 'observeResource',
+            parameters: {
+                subscribe:true,
+                uri:params.uri,
+                destination:params.destination
+            },
+            onComplete: (res) => {
+                console.log(res);
+                if(res.response.payload){
+                    dispatch(actionUpdateGetResourceResults(res.response));
+                }
+                else{
+                    createToast("Fail to observe resource");
+                    dispatch(actionEnableClientResourceControlUI());
+                }
+                return;
+            }
+        });
+    }
+};
+
+export const stopObserveResource = () =>  {
+    const ls = LS2RequestSingleton.instance('observeResource');
+    if (ls) {
+        ls.cancel();
+        LS2RequestSingleton.deleteInstance('observeResource');
+    }
+};
diff --git a/resource/csdk/stack/samples/webos/com.example.app.iotivity/src/actions/ActionTypes.js b/resource/csdk/stack/samples/webos/com.example.app.iotivity/src/actions/ActionTypes.js
new file mode 100644
index 0000000..0db73d2
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/com.example.app.iotivity/src/actions/ActionTypes.js
@@ -0,0 +1,10 @@
+export const UPDATE_SERVER = 'UPDATE_SERVER';
+export const UPDATE_DISCOVERED_RESOURCES = 'UPDATE_DISCOVERED_RESOURCES';
+export const RESET_DISCOVERED_RESOURCES = 'RESET_DISCOVERED_RESOURCES';
+export const HIDE_SERVER_RESOURCE_CONTROL_UI = 'HIDE_SERVER_RESOURCE_CONTROL_UI';
+export const SHOW_SERVER_RESOURCE_CONTROL_UI = 'SHOW_SERVER_RESOURCE_CONTROL_UI';
+export const HIDE_CLIENT_RESOURCE_CONTROL_UI = 'HIDE_CLIENT_RESOURCE_CONTROL_UI';
+export const SHOW_CLIENT_RESOURCE_CONTROL_UI = 'SHOW_CLIENT_RESOURCE_CONTROL_UI';
+export const UPDATE_GET_RESOURCE_RESULTS='UPDATE_GET_RESOURCE_RESULTS';
+export const UPDATE_OBSERVE_RESOURCE_RESULTS='UPDATE_OBSERVE_RESOURCE_RESULTS';
+export const SHOW_RESOURCES_LIST='SHOW_RESOURCES_LIST';
\ No newline at end of file
diff --git a/resource/csdk/stack/samples/webos/com.example.app.iotivity/src/index.js b/resource/csdk/stack/samples/webos/com.example.app.iotivity/src/index.js
new file mode 100644
index 0000000..b475c4a
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/com.example.app.iotivity/src/index.js
@@ -0,0 +1,40 @@
+import React from 'react';
+import {render} from 'react-dom';
+import {createStore, applyMiddleware, compose} from 'redux';
+import {Provider} from 'react-redux';
+import reducer from './reducer/Reducer';
+import thunkMiddleware from 'redux-thunk';
+
+import App from './App';
+
+const composeEnhancers = (typeof window === 'object' && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__) || compose;
+
+function configureStore (initialState) {
+    const ret = createStore(
+        reducer,
+        initialState,
+        composeEnhancers(
+            applyMiddleware(thunkMiddleware)
+        )
+    );
+
+    return ret;
+}
+
+const store = configureStore();
+
+let appElement = (
+    <Provider store={store}>
+        <App />
+    </Provider>
+);
+
+// In a browser environment, render instead of exporting
+if (typeof window !== 'undefined') {
+    render(
+        appElement,
+        document.getElementById('root')
+    );
+}
+
+export default appElement;
diff --git a/resource/csdk/stack/samples/webos/com.example.app.iotivity/src/reducer/Reducer.js b/resource/csdk/stack/samples/webos/com.example.app.iotivity/src/reducer/Reducer.js
new file mode 100644
index 0000000..bc83572
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/com.example.app.iotivity/src/reducer/Reducer.js
@@ -0,0 +1,45 @@
+import * as actions from './../actions/ActionTypes';
+
+const initialState = {
+    serverEnabled:false,
+    discoveredResources:null,
+    showDiscoveredResources:false,
+    enableServerResourceControlUI:true,
+    enableClientResourceControlUI:true,
+    detailResourceInfo:null,
+};
+
+let arr=[];
+
+export function reducer (state = initialState, action) {
+    switch (action.type) {
+        case actions.UPDATE_SERVER:
+            return Object.assign({}, state, {serverEnabled: action.payload.enabled});
+        case actions.UPDATE_DISCOVERED_RESOURCES:
+            if(action.payload.addr){
+                arr.push(action.payload);
+                return Object.assign({}, state, {discoveredResources: arr});
+            }
+            return state;
+        case actions.SHOW_RESOURCES_LIST:
+            return Object.assign({}, state, {showDiscoveredResources: true});
+        case actions.RESET_DISCOVERED_RESOURCES:
+            arr=[];
+            return Object.assign({}, state, {showDiscoveredResources: false, discoveredResources: null, detailResourceInfo:null});
+        case actions.HIDE_SERVER_RESOURCE_CONTROL_UI:
+            return Object.assign({}, state, {enableServerResourceControlUI: false});
+        case actions.SHOW_SERVER_RESOURCE_CONTROL_UI:
+            return Object.assign({}, state, {enableServerResourceControlUI: true});
+        case actions.HIDE_CLIENT_RESOURCE_CONTROL_UI:
+            return Object.assign({}, state, {enableClientResourceControlUI: false});
+        case actions.SHOW_CLIENT_RESOURCE_CONTROL_UI:
+            return Object.assign({}, state, {enableClientResourceControlUI: true, detailResourceInfo:null});
+        case actions.UPDATE_GET_RESOURCE_RESULTS:
+        case actions.UPDATE_OBSERVE_RESOURCE_RESULTS:
+            return Object.assign({}, state, {detailResourceInfo: action.payload.payload});
+        default:
+            return state;
+    }
+}
+
+export default reducer;
diff --git a/resource/csdk/stack/samples/webos/com.example.app.iotivity/src/views/Client.js b/resource/csdk/stack/samples/webos/com.example.app.iotivity/src/views/Client.js
new file mode 100644
index 0000000..deb07c0
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/com.example.app.iotivity/src/views/Client.js
@@ -0,0 +1,204 @@
+import React from 'react';
+import {connect} from 'react-redux';
+import PropTypes from 'prop-types';
+
+import Button from '@enact/moonstone/Button';
+import Divider from '@enact/moonstone/Divider';
+import CheckboxItem from '@enact/moonstone/CheckboxItem';
+import BodyText from '@enact/moonstone/BodyText';
+import SpotlightContainerDecorator from '@enact/moonstone/Scroller';
+import ExpandableInput from '@enact/moonstone/ExpandableInput';
+
+import * as ActionCreators from '../actions/ActionCreators';
+
+import Changeable from '@enact/ui/Changeable';
+import {Group} from '@enact/ui/Group';
+import {Layout} from '@enact/ui/Layout';
+
+const SelectableGroup = Changeable({mutable: true}, Group);
+let discoveredItems=[];
+
+class Client extends React.Component {
+    constructor (props) {
+        super(props);
+        this.state = {
+            isSelectDiscoveredItem:false,
+            selectedDiscoveredItemIndex:null,
+            resourceUri:null,
+            resourceQuestion:null,
+            requestResourceCompleted:true,
+        };
+    }
+    componentWillReceiveProps (props) {
+        console.log(props);
+        if(props.discoveredResources&&props.discoveredResources.length>0){
+            discoveredItems=[];
+            for(let i=0; i<props.discoveredResources.length; i++){
+                discoveredItems.push({
+                    value:props.discoveredResources[i],
+                    children:props.discoveredResources[i].addr.addr+" (port:"+props.discoveredResources[i].addr.port+")",
+                });
+            }
+        }
+        else {
+            discoveredItems=[];
+            this.setState({
+                isSelectDiscoveredItem:false,
+            });
+        }
+    }
+    resourceUriChanged(ev){
+        this.setState({
+            resourceUri: ev.value,
+            requestResourceCompleted:false,
+        });
+        console.log(this.state.resourceUri);
+    }
+    resourceQuestionChanged(ev){
+        this.setState({
+            resourceQuestion: ev.value,
+            requestResourceCompleted:false,
+        });
+        console.log(this.state.resourceQuestion);
+    }
+    getResource(){
+        let param={
+            uri:this.state.resourceUri,
+            question:this.state.resourceQuestion,
+            destination:this.state.selectedDiscoveredItemIndex.addr
+        }
+        this.props.actionDisableClientResourceControlUI();
+        this.props.getResource(param);
+        this.setState({
+            resourceUri: null,
+            resourceQuestion: null,
+            requestResourceCompleted:true,
+            isSelectDiscoveredItem:false,
+            selectedDiscoveredItemIndex: null,
+        });
+    }
+    requestDeleteResource(){
+        let param={
+            uri:this.state.resourceUri,
+            destination:this.state.selectedDiscoveredItemIndex.addr
+        }
+        this.props.actionDisableClientResourceControlUI();
+        this.props.requestDeleteResource(param);
+        this.setState({
+            resourceUri: null,
+            resourceQuestion: null,
+            resourceCompleted:true,
+            isSelectDiscoveredItem:false,
+            selectedDiscoveredItemIndex: null,
+        });
+    }
+    requestObserveResource(){
+        let param={
+            uri:this.state.resourceUri,
+            destination:this.state.selectedDiscoveredItemIndex.addr,
+        }
+        this.props.actionDisableClientResourceControlUI();
+        this.props.requestObserveResource(param);
+        this.setState({
+            resourceUri: null,
+            resourceQuestion: null,
+            resourceCompleted:true,
+            isSelectDiscoveredItem:false,
+            selectedDiscoveredItemIndex: null,
+        });
+    }
+    onSelectedResource (ev){
+        console.log(ev);
+        for(let i=0 ; i<this.props.discoveredResources.length; i++){
+            if(JSON.stringify(this.props.discoveredResources[i]).indexOf(ev.data.slice(0,30))>0){
+                console.log(this.props.discoveredResources[i]);
+                this.setState({
+                    isSelectDiscoveredItem:true,
+                    selectedDiscoveredItemIndex:this.props.discoveredResources[i]
+                });
+                console.log(this.state.selectedDiscoveredItemIndex);
+            }
+        }
+        this.props.actionEnableClientResourceControlUI();
+    }
+    render() {
+        const {discoveredResources,showDiscoveredResources,enableClientResourceControlUI,detailResourceInfo,...rest} = this.props;
+        const onToggleHandler=this.onSelectedResource.bind(this);
+        const onResourceUriChanged = this.resourceUriChanged.bind(this);
+        const onResourceQuestionChanged = this.resourceQuestionChanged.bind(this);
+        const onGetResourceTapped = this.getResource.bind(this);
+        const onDeleteResourceTapped = this.requestDeleteResource.bind(this);
+        const onObserveResourceTapped = this.requestObserveResource.bind(this);
+        return(
+            <div>
+                <Layout align="start">
+                    {showDiscoveredResources?
+                    <SpotlightContainerDecorator focusableScrollbar style={{"height":210+"px"}} direction="both" horizontalScrollbar="auto" verticalScrollbar="auto">
+                        <SelectableGroup
+                            childComponent={CheckboxItem}
+                            onSelect={onToggleHandler}
+                            selectedProp="selected"
+                            select="radio"
+                        >
+                        {discoveredItems}
+                        </SelectableGroup>
+                        <div style={{"paddingTop": 9+"px"}} >
+                            <Button small onClick={this.props.resetDiscoveredList}>OK</Button>
+                        </div>
+
+                    </SpotlightContainerDecorator>
+                    :<Button small onClick={this.props.discoverResources}>Discover Resources</Button>
+                    }
+                </Layout>
+                <Divider />
+                <Layout align="start">
+                    {this.state.isSelectDiscoveredItem&&enableClientResourceControlUI?
+                    <SpotlightContainerDecorator focusableScrollbar style={{"height":600+"px"}} direction="both" horizontalScrollbar="auto" verticalScrollbar="auto">
+                        <div>{JSON.stringify(this.state.selectedDiscoveredItemIndex.payload,null,4)}</div>
+                        <ExpandableInput title="uri" onChange={onResourceUriChanged} />
+                        <ExpandableInput title="question" onChange={onResourceQuestionChanged} />
+                        <div style={{"paddingTop": 9+"px"}}>
+                            <Button disabled={this.state.resourceUri&&this.state.resourceQuestion?false:true} small onClick={onGetResourceTapped}>get resource</Button>
+                            <Button disabled={this.state.resourceUri?false:true} small onClick={onDeleteResourceTapped}>delete resource</Button>
+                            <Button disabled={this.state.resourceUri?false:true} small onClick={onObserveResourceTapped}>observe resource</Button>
+                        </div>
+                    </SpotlightContainerDecorator>
+                    :null}
+                    {detailResourceInfo?
+                    <SpotlightContainerDecorator focusableScrollbar style={{"height":600+"px"}} direction="both" horizontalScrollbar="auto" verticalScrollbar="auto">
+                        <BodyText>{JSON.stringify(detailResourceInfo,null,4)}</BodyText>
+                    </SpotlightContainerDecorator>
+                    :null}
+                </Layout>
+            </div>
+        )
+    }
+}
+Client.propTypes = {
+    getResource: PropTypes.func,
+    requestDeleteResource: PropTypes.func,
+    requestObserveResource: PropTypes.func,
+    discoverResources: PropTypes.func,
+    resetDiscoveredList: PropTypes.func,
+    actionDisableCreateResourceUI: PropTypes.func,
+};
+const mapDispatchToProps = (dispatch) => {
+    return {
+        getResource: (params) => dispatch(ActionCreators.getResource(params)),
+        requestDeleteResource: (params) => dispatch(ActionCreators.requestDeleteResource(params)),
+        requestObserveResource: (params) => dispatch(ActionCreators.observeResource(params)),
+        discoverResources: () => ActionCreators.discoverResources(dispatch),
+        resetDiscoveredList: () => ActionCreators.resetDiscoveredList(dispatch),
+        actionDisableClientResourceControlUI: () => dispatch(ActionCreators.actionDisableClientResourceControlUI()),
+        actionEnableClientResourceControlUI: () => dispatch(ActionCreators.actionEnableClientResourceControlUI()),
+    };
+};
+let mapStateToProps = (state) => {
+    return {
+        discoveredResources:state.discoveredResources,
+        showDiscoveredResources:state.showDiscoveredResources,
+        detailResourceInfo:state.detailResourceInfo,
+        enableClientResourceControlUI:state.enableClientResourceControlUI,
+    };
+};
+export default connect(mapStateToProps, mapDispatchToProps)(Client);
diff --git a/resource/csdk/stack/samples/webos/com.example.app.iotivity/src/views/MainPanel.js b/resource/csdk/stack/samples/webos/com.example.app.iotivity/src/views/MainPanel.js
new file mode 100644
index 0000000..56a960d
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/com.example.app.iotivity/src/views/MainPanel.js
@@ -0,0 +1,31 @@
+import React from 'react';
+import kind from '@enact/core/kind';
+
+import {Panel, Header} from '@enact/moonstone/Panels';
+import Divider from '@enact/moonstone/Divider';
+
+import Server from './Server';
+import Client from './Client';
+
+import {Layout, Cell} from '@enact/ui/Layout';
+
+const MainPanel = kind({
+    name: 'MainPanel',
+    render: () => (
+        <Panel>
+            <Header title="iotivity sampler" type="compact" />
+            <Layout align="start">
+                <Cell>
+                    <Divider casing="word">Server role</Divider>
+                    <Server />
+                </Cell>
+                <Cell>
+                    <Divider casing="word">Client role</Divider>
+                    <Client />
+                </Cell>
+            </Layout>
+        </Panel>
+    )
+});
+
+export default MainPanel;
diff --git a/resource/csdk/stack/samples/webos/com.example.app.iotivity/src/views/Server.js b/resource/csdk/stack/samples/webos/com.example.app.iotivity/src/views/Server.js
new file mode 100644
index 0000000..b5b2ef8
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/com.example.app.iotivity/src/views/Server.js
@@ -0,0 +1,186 @@
+import React from 'react';
+import {connect} from 'react-redux';
+import PropTypes from 'prop-types';
+
+import {MarqueeText} from '@enact/moonstone/Marquee';
+import Button from '@enact/moonstone/Button';
+import Divider from '@enact/moonstone/Divider';
+import ExpandableList from '@enact/moonstone/ExpandableList';
+import ExpandableInput from '@enact/moonstone/ExpandableInput';
+import SwitchItem from '@enact/moonstone/SwitchItem';
+
+import * as ActionCreators from '../actions/ActionCreators';
+
+import {Layout, Cell} from '@enact/ui/Layout';
+
+class Server extends React.Component {
+    constructor (props) {
+        super(props);
+        this.state = {
+            resourceUri: null,
+            resourceType: null,
+            resourceQuestion: null,
+            resourceAnswer:null,
+            resourceUpdateCompleted:true,
+            resourceObservable:false,
+        };
+    }
+    resourceTypeChanged(ev){
+        this.setState({
+            resourceType: ev.data,
+            resourceUpdateCompleted:false,
+        });
+        console.log(this.state.resourceType);
+    }
+    resourceUriChanged(ev){
+        this.setState({
+            resourceUri: ev.value,
+            resourceUpdateCompleted:false,
+        });
+        console.log(this.state.resourceUri);
+    }
+    resourceQuestionChanged(ev){
+        this.setState({
+            resourceQuestion: ev.value,
+            resourceUpdateCompleted:false,
+        });
+        console.log(this.state.resourceQuestion);
+    }
+    resourceAnswerChanged(ev){
+        this.setState({
+            resourceAnswer: ev.value,
+            resourceUpdateCompleted:false,
+        });
+        console.log(this.state.resourceAnswer);
+    }
+    resourceObservableChanged(ev){
+        //console.log(ev);
+        this.setState({
+            resourceObservable: ev.selected,
+            resourceUpdateCompleted:false,
+        });
+        console.log(this.state.resourceObservable);
+    }
+    createResource(){
+        let param={
+            uri:this.state.resourceUri,
+            question:this.state.resourceQuestion,
+            answer:this.state.resourceAnswer,
+            types:this.state.resourceType,
+            observable:this.state.resourceObservable
+        }
+        this.props.actionDisableServerResourceControlUI();
+        this.props.createResource(param);
+        this.setState({
+            resourceUri: null,
+            resourceType: null,
+            resourceQuestion: null,
+            resourceAnswer:null,
+            resourceObservable:false,
+            resourceUpdateCompleted:true,
+        });
+    }
+    deleteResource(){
+        let param={
+            uri:this.state.resourceUri,
+        }
+        this.props.actionDisableServerResourceControlUI();
+        this.props.deleteResource(param);
+        this.setState({
+            resourceUri: null,
+            resourceType: null,
+            resourceQuestion: null,
+            resourceAnswer:null,
+            resourceUpdateCompleted:true,
+        });
+    }
+    render() {
+        const {serverEnabled, enableServerResourceControlUI} = this.props;
+        const onResourceUriChanged = this.resourceUriChanged.bind(this);
+        const onResourceQuestionChanged = this.resourceQuestionChanged.bind(this);
+        const onResourceAnswerChanged = this.resourceAnswerChanged.bind(this);
+        const onResourceTypeChanged = this.resourceTypeChanged.bind(this);
+        const onObservableResourceChanged = this.resourceObservableChanged.bind(this);
+        const onCreateResourceTapped = this.createResource.bind(this);
+        const onDeleteResourceTapped = this.deleteResource.bind(this);
+        return(
+            <div>
+                <Layout align="start">
+                    <Cell shrink>
+                        {serverEnabled?
+                            <Button small onClick={this.props.stopServer}>stop server</Button>
+                            :<Button small onClick={this.props.startServer}>start server</Button>
+                        }
+                    </Cell>
+                    <Cell>
+                        {serverEnabled?
+                            <div style={{"lineHeight":60+"px"}}>
+                                <MarqueeText marqueeOn="render">Server is running</MarqueeText>
+                            </div>
+                            :null
+                        }
+                    </Cell>
+                </Layout>
+                <Layout align="start">
+                    <Cell>
+                    <Divider />
+                    {(serverEnabled&&enableServerResourceControlUI)?
+                        <div>
+                            <ExpandableInput title="uri" onChange={onResourceUriChanged} />
+                            <ExpandableList
+                                closeOnSelect
+                                onSelect={onResourceTypeChanged}
+                                select={'radio'}
+                                title={'type'}
+                            >
+                            {[
+                                {disabled:false, children: 'core.fan'},
+                                {disabled:false, children: 'core.light'},
+                            ]}
+                            </ExpandableList>
+                            <ExpandableInput title="question" noneText="ex) How many angels can dance on the head of a pin?" onChange={onResourceQuestionChanged} />
+                            <ExpandableInput title="answer" noneText="ex) As many as wanting." onChange={onResourceAnswerChanged} />
+                            <SwitchItem disabled={false} onToggle={onObservableResourceChanged}>observable</SwitchItem>
+                            <div style={{"paddingTop": 9+"px"}}>
+                                <Button
+                                    disabled={this.state.resourceQuestion&&this.state.resourceAnswer&&this.state.resourceUri&&this.state.resourceType?false:true}
+                                    small
+                                    onClick={onCreateResourceTapped}>
+                                    create resource
+                                </Button>
+                                <Button disabled={this.state.resourceUri?false:true} small onClick={onDeleteResourceTapped}>delete resource</Button>
+                            </div>
+                        </div>
+                        :null
+                    }
+                    </Cell>
+                </Layout>
+            </div>
+        )
+    }
+}
+Server.propTypes = {
+    startServer: PropTypes.func,
+    stopServer: PropTypes.func,
+    createResource: PropTypes.func,
+    deleteResource: PropTypes.func,
+    actionDisableServerResourceControlUI: PropTypes.func,
+};
+const mapDispatchToProps = (dispatch) => {
+    return {
+        startServer: () => ActionCreators.startServer(dispatch),
+        stopServer: () => ActionCreators.stopServer(dispatch),
+        createResource: (params) => dispatch(ActionCreators.createResource(params)),
+        deleteResource: (params) => dispatch(ActionCreators.deleteResource(params)),
+        actionDisableServerResourceControlUI: () => dispatch(ActionCreators.actionDisableServerResourceControlUI()),
+    };
+};
+let mapStateToProps = (state) => {
+    return {
+        serverEnabled:state.serverEnabled,
+        discoveredResources:state.discoveredResources,
+        showDiscoveredResources:state.showDiscoveredResources,
+        enableServerResourceControlUI:state.enableServerResourceControlUI,
+    };
+};
+export default connect(mapStateToProps, mapDispatchToProps)(Server);
diff --git a/resource/csdk/stack/samples/webos/secure/SConscript b/resource/csdk/stack/samples/webos/secure/SConscript
new file mode 100644
index 0000000..a297dcd
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/secure/SConscript
@@ -0,0 +1,24 @@
+#******************************************************************
+#
+# Copyright (c) 2018 LG Electronics, Inc.
+#
+#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+Import('stacksamples_env')
+
+SConscript('ocserverbasicops/SConscript', 'stacksamples_env')
+SConscript('occlientbasicops/SConscript', 'stacksamples_env')
diff --git a/resource/csdk/stack/samples/webos/secure/common.cpp b/resource/csdk/stack/samples/webos/secure/common.cpp
new file mode 100644
index 0000000..7341789
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/secure/common.cpp
@@ -0,0 +1,143 @@
+/*******************************************************************
+ *
+ * Copyright (c) 2018 LG Electronics, Inc.
+ * Copyright 2014 Intel Mobile Communications GmbH All Rights Reserved.
+ *
+ *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+ */
+
+#include "common.h"
+
+#include "ocstack.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+
+
+/// This example is using experimental API, so there is no guarantee of support for future release,
+/// nor any there any guarantee that breaking changes will not occur across releases.
+#include "logger.h"
+
+#define TAG "sample-common"
+
+const char *getResult(OCStackResult result) {
+    switch (result) {
+    case OC_STACK_OK:
+        return "OC_STACK_OK";
+    case OC_STACK_RESOURCE_CREATED:
+        return "OC_STACK_RESOURCE_CREATED";
+    case OC_STACK_RESOURCE_DELETED:
+        return "OC_STACK_RESOURCE_DELETED";
+    case OC_STACK_CONTINUE:
+        return "OC_STACK_CONTINUE";
+    case OC_STACK_RESOURCE_CHANGED:
+        return "OC_STACK_RESOURCE_CHANGED";
+    case OC_STACK_INVALID_URI:
+        return "OC_STACK_INVALID_URI";
+    case OC_STACK_INVALID_QUERY:
+        return "OC_STACK_INVALID_QUERY";
+    case OC_STACK_INVALID_IP:
+        return "OC_STACK_INVALID_IP";
+    case OC_STACK_INVALID_PORT:
+        return "OC_STACK_INVALID_PORT";
+    case OC_STACK_INVALID_CALLBACK:
+        return "OC_STACK_INVALID_CALLBACK";
+    case OC_STACK_INVALID_METHOD:
+        return "OC_STACK_INVALID_METHOD";
+    case OC_STACK_INVALID_PARAM:
+        return "OC_STACK_INVALID_PARAM";
+    case OC_STACK_INVALID_OBSERVE_PARAM:
+        return "OC_STACK_INVALID_OBSERVE_PARAM";
+    case OC_STACK_NO_MEMORY:
+        return "OC_STACK_NO_MEMORY";
+    case OC_STACK_COMM_ERROR:
+        return "OC_STACK_COMM_ERROR";
+    case OC_STACK_TIMEOUT:
+        return "OC_STACK_TIMEOUT";
+    case OC_STACK_ADAPTER_NOT_ENABLED:
+        return "OC_STACK_ADAPTER_NOT_ENABLED";
+    case OC_STACK_NOTIMPL:
+        return "OC_STACK_NOTIMPL";
+    case OC_STACK_NO_RESOURCE:
+        return "OC_STACK_NO_RESOURCE";
+    case OC_STACK_RESOURCE_ERROR:
+        return "OC_STACK_RESOURCE_ERROR";
+    case OC_STACK_SLOW_RESOURCE:
+        return "OC_STACK_SLOW_RESOURCE";
+    case OC_STACK_DUPLICATE_REQUEST:
+        return "OC_STACK_DUPLICATE_REQUEST";
+    case OC_STACK_NO_OBSERVERS:
+        return "OC_STACK_NO_OBSERVERS";
+    case OC_STACK_OBSERVER_NOT_FOUND:
+        return "OC_STACK_OBSERVER_NOT_FOUND";
+    case OC_STACK_VIRTUAL_DO_NOT_HANDLE:
+        return "OC_STACK_VIRTUAL_DO_NOT_HANDLE";
+    case OC_STACK_INVALID_OPTION:
+        return "OC_STACK_INVALID_OPTION";
+    case OC_STACK_MALFORMED_RESPONSE:
+        return "OC_STACK_MALFORMED_RESPONSE";
+    case OC_STACK_INVALID_REQUEST_HANDLE:
+        return "OC_STACK_INVALID_REQUEST_HANDLE";
+    case OC_STACK_INVALID_DEVICE_INFO:
+        return "OC_STACK_INVALID_DEVICE_INFO";
+    case OC_STACK_INVALID_JSON:
+        return "OC_STACK_INVALID_JSON";
+    case OC_STACK_UNAUTHORIZED_REQ:
+        return "OC_STACK_UNAUTHORIZED_REQ";
+    case OC_STACK_TOO_LARGE_REQ:
+        return "OC_STACK_TOO_LARGE_REQ";
+    #ifdef WITH_PRESENCE
+    case OC_STACK_PRESENCE_STOPPED:
+        return "OC_STACK_PRESENCE_STOPPED";
+    case OC_STACK_PRESENCE_TIMEOUT:
+        return "OC_STACK_PRESENCE_TIMEOUT";
+    case OC_STACK_PRESENCE_DO_NOT_HANDLE:
+        return "OC_STACK_PRESENCE_DO_NOT_HANDLE";
+    #endif
+    case OC_STACK_USER_DENIED_REQ:
+        return "OC_STACK_USER_DENIED_REQ";
+    case OC_STACK_NOT_ACCEPTABLE:
+        return "OC_STACK_NOT_ACCEPTABLE";
+    case OC_STACK_FORBIDDEN_REQ:
+        return "OC_STACK_FORBIDDEN_REQ";
+    case OC_STACK_INTERNAL_SERVER_ERROR:
+        return "OC_STACK_INTERNAL_SERVER_ERROR";
+    case OC_STACK_GATEWAY_TIMEOUT:
+        return "OC_STACK_GATEWAY_TIMEOUT";
+    case OC_STACK_SERVICE_UNAVAILABLE:
+        return "OC_STACK_SERVICE_UNAVAILABLE";
+    case OC_STACK_ERROR:
+        return "OC_STACK_ERROR";
+    default:
+        return "UNKNOWN";
+    }
+}
+
+void StripNewLineChar(char* str) {
+    int i = 0;
+    if (str)
+    {
+        while( str[i])
+        {
+            if (str[i] == '\n')
+                str[i] = '\0';
+            i++;
+        }
+    }
+}
+
diff --git a/resource/csdk/stack/samples/webos/secure/common.h b/resource/csdk/stack/samples/webos/secure/common.h
new file mode 100644
index 0000000..ed773b1
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/secure/common.h
@@ -0,0 +1,36 @@
+/*******************************************************************
+ *
+ * Copyright (c) 2018 LG Electronics, Inc.
+ * Copyright 2014 Intel Mobile Communications GmbH All Rights Reserved.
+ *
+ *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+ */
+
+#ifndef OCSAMPLE_COMMON_H_
+#define OCSAMPLE_COMMON_H_
+
+#include "ocstack.h"
+
+/* Get the result in string format. */
+const char *getResult(OCStackResult result);
+
+/* Removes the new line character from a NULL terminated C string. */
+void StripNewLineChar(char* str);
+
+#endif //OCSAMPLE_COMMON_H_
+
+
diff --git a/resource/csdk/stack/samples/webos/secure/files/sysbus/occlientbasicops.api.json b/resource/csdk/stack/samples/webos/secure/files/sysbus/occlientbasicops.api.json
new file mode 100644
index 0000000..2c63c08
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/secure/files/sysbus/occlientbasicops.api.json
@@ -0,0 +1,2 @@
+{
+}
diff --git a/resource/csdk/stack/samples/webos/secure/files/sysbus/occlientbasicops.manifest.json b/resource/csdk/stack/samples/webos/secure/files/sysbus/occlientbasicops.manifest.json
new file mode 100644
index 0000000..e2f1130
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/secure/files/sysbus/occlientbasicops.manifest.json
@@ -0,0 +1,16 @@
+{
+    "serviceFiles": [
+        "/usr/share/luna-service2/services.d/occlientbasicops.service"
+    ],
+    "roleFiles": [
+        "/usr/share/luna-service2/roles.d/occlientbasicops.role.json"
+    ],
+    "apiPermissionFiles": [
+        "/usr/share/luna-service2/api-permissions.d/occlientbasicops.api.json"
+    ],
+    "version": "1.0.0",
+    "id": "occlientbasicops",
+    "clientPermissionFiles": [
+        "/usr/share/luna-service2/client-permissions.d/occlientbasicops.perm.json"
+    ]
+}
diff --git a/resource/csdk/stack/samples/webos/secure/files/sysbus/occlientbasicops.perm.json b/resource/csdk/stack/samples/webos/secure/files/sysbus/occlientbasicops.perm.json
new file mode 100644
index 0000000..37aab83
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/secure/files/sysbus/occlientbasicops.perm.json
@@ -0,0 +1,5 @@
+{
+    "org.ocf.webossample.occlientbasicops*": [
+        "networking.internal"
+    ]
+}
diff --git a/resource/csdk/stack/samples/webos/secure/files/sysbus/occlientbasicops.role.json b/resource/csdk/stack/samples/webos/secure/files/sysbus/occlientbasicops.role.json
new file mode 100644
index 0000000..53606eb
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/secure/files/sysbus/occlientbasicops.role.json
@@ -0,0 +1,11 @@
+{
+    "exeName":"/usr/palm/services/org.ocf.webossample.occlientbasicops/occlientbasicops",
+    "type":"regular",
+    "allowedNames":["org.ocf.webossample.occlientbasicops*"],
+    "permissions": [
+        {
+            "service":"org.ocf.webossample.occlientbasicops*",
+            "outbound":["com.webos.service.connectionmanager"]
+        }
+    ]
+}
diff --git a/resource/csdk/stack/samples/webos/secure/files/sysbus/occlientbasicops.service b/resource/csdk/stack/samples/webos/secure/files/sysbus/occlientbasicops.service
new file mode 100644
index 0000000..cedab9e
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/secure/files/sysbus/occlientbasicops.service
@@ -0,0 +1,24 @@
+#******************************************************************
+#
+# Copyright (c) 2018 LG Electronics, Inc.
+#
+#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+[D-BUS Service]
+Name=org.ocf.webossample.occlientbasicops*
+Exec=/usr/palm/services/org.ocf.webossample.occlientbasicops/occlientbasicops
+Type=static
diff --git a/resource/csdk/stack/samples/webos/secure/files/sysbus/ocserverbasicops.api.json b/resource/csdk/stack/samples/webos/secure/files/sysbus/ocserverbasicops.api.json
new file mode 100644
index 0000000..2c63c08
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/secure/files/sysbus/ocserverbasicops.api.json
@@ -0,0 +1,2 @@
+{
+}
diff --git a/resource/csdk/stack/samples/webos/secure/files/sysbus/ocserverbasicops.manifest.json b/resource/csdk/stack/samples/webos/secure/files/sysbus/ocserverbasicops.manifest.json
new file mode 100644
index 0000000..8dadac8
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/secure/files/sysbus/ocserverbasicops.manifest.json
@@ -0,0 +1,16 @@
+{
+    "serviceFiles": [
+        "/usr/share/luna-service2/services.d/ocserverbasicops.service"
+    ],
+    "roleFiles": [
+        "/usr/share/luna-service2/roles.d/ocserverbasicops.role.json"
+    ],
+    "apiPermissionFiles": [
+        "/usr/share/luna-service2/api-permissions.d/ocserverbasicops.api.json"
+    ],
+    "version": "1.0.0",
+    "id": "ocserverbasicops",
+    "clientPermissionFiles": [
+        "/usr/share/luna-service2/client-permissions.d/ocserverbasicops.perm.json"
+    ]
+}
diff --git a/resource/csdk/stack/samples/webos/secure/files/sysbus/ocserverbasicops.perm.json b/resource/csdk/stack/samples/webos/secure/files/sysbus/ocserverbasicops.perm.json
new file mode 100644
index 0000000..212f0cd
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/secure/files/sysbus/ocserverbasicops.perm.json
@@ -0,0 +1,5 @@
+{
+    "org.ocf.webossample.ocserverbasicops*": [
+        "networking.internal"
+    ]
+}
diff --git a/resource/csdk/stack/samples/webos/secure/files/sysbus/ocserverbasicops.role.json b/resource/csdk/stack/samples/webos/secure/files/sysbus/ocserverbasicops.role.json
new file mode 100644
index 0000000..be1346b
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/secure/files/sysbus/ocserverbasicops.role.json
@@ -0,0 +1,11 @@
+{
+    "exeName":"/usr/palm/services/org.ocf.webossample.ocserverbasicops/ocserverbasicops",
+    "type":"regular",
+    "allowedNames":["org.ocf.webossample.ocserverbasicops*"],
+    "permissions": [
+        {
+            "service":"org.ocf.webossample.ocserverbasicops*",
+            "outbound":["com.webos.service.connectionmanager"]
+        }
+    ]
+}
diff --git a/resource/csdk/stack/samples/webos/secure/files/sysbus/ocserverbasicops.service b/resource/csdk/stack/samples/webos/secure/files/sysbus/ocserverbasicops.service
new file mode 100644
index 0000000..399712f
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/secure/files/sysbus/ocserverbasicops.service
@@ -0,0 +1,24 @@
+#******************************************************************
+#
+# Copyright (c) 2018 LG Electronics, Inc.
+#
+#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+[D-BUS Service]
+Name=org.ocf.webossample.ocserverbasicops*
+Exec=/usr/palm/services/org.ocf.webossample.ocserverbasicops/ocserverbasicops
+Type=static
diff --git a/resource/csdk/stack/samples/webos/secure/occlientbasicops/SConscript b/resource/csdk/stack/samples/webos/secure/occlientbasicops/SConscript
new file mode 100644
index 0000000..74e1596
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/secure/occlientbasicops/SConscript
@@ -0,0 +1,107 @@
+#******************************************************************
+#
+# Copyright (c) 2018 LG Electronics, Inc.
+# Copyright 2014 Intel Mobile Communications GmbH All Rights Reserved.
+#
+#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+Import('stacksamples_env')
+
+samples_env = stacksamples_env.Clone()
+
+######################################################################
+# Build flags
+######################################################################
+samples_env.PrependUnique(CPPPATH=[
+    '../../../../../logger/include',
+    '../../../../../include',
+    '../../../../../stack/include',
+    '../../../../../security/include',
+    '../../../../../../oc_logger/include',
+    '../'
+])
+
+target_os = samples_env.get('TARGET_OS')
+if target_os not in ['windows']:
+    samples_env.AppendUnique(CXXFLAGS=['-std=c++0x', '-Wall', '-pthread'])
+
+    # Note: 'pthread' is in libc for android.
+    if target_os != 'android':
+        samples_env.AppendUnique(LIBS=['pthread'])
+    samples_env.Append(LINKFLAGS=['-Wl,--no-as-needed'])
+
+if target_os in ['windows', 'msys_nt']:
+    samples_env.PrependUnique(LIBS=['coap', 'ocsrm'])
+else:
+    samples_env.PrependUnique(LIBS=['connectivity_abstraction', 'coap', 'm'])
+
+samples_env.PrependUnique(LIBS=['octbstack'])
+
+if samples_env.get('SECURED') == '1':
+    samples_env.AppendUnique(LIBS=['mbedtls', 'mbedx509', 'mbedcrypto'])
+
+if target_os == 'android':
+    samples_env.AppendUnique(CXXFLAGS=['-frtti', '-fexceptions'])
+    samples_env.AppendUnique(LIBS=['gnustl_shared'])
+    samples_env.AppendUnique(
+        CPPDEFINES=['_GLIBCXX_USE_C99=1', '_GLIBCXX_HAVE_WCSTOF=1'])
+
+    if not samples_env.get('RELEASE'):
+        samples_env.AppendUnique(LIBS=['log'])
+
+if target_os in ['darwin', 'ios']:
+    samples_env.AppendUnique(CPPDEFINES=['_DARWIN_C_SOURCE'])
+
+samples_env.AppendUnique(CPPDEFINES=['TB_LOG'])
+
+samples_env.ParseConfig("pkg-config --cflags --libs glib-2.0")
+samples_env.ParseConfig("pkg-config --cflags --libs luna-service2")
+samples_env.ParseConfig("pkg-config --cflags --libs pbnjson_c")
+
+######################################################################
+# Source files and Targets
+######################################################################
+
+occlientbasicops = samples_env.Program(
+    'occlientbasicops', ['../common.cpp', 'occlientbasicops.cpp'])
+
+ocsamples = [occlientbasicops]
+Alias("samples", ocsamples)
+samples_env.AppendTarget('samples')
+
+src_dir = samples_env.get('SRC_DIR')
+sec_samples_src_dir = src_dir + '/resource/csdk/stack/samples/linux/secure/'
+sec_samples_build_dir = samples_env.get(
+    'BUILD_DIR') + '/resource/csdk/stack/samples/linux/secure'
+
+samples_env.Alias(
+    "install",
+    samples_env.Install(sec_samples_build_dir,
+                        sec_samples_src_dir + 'oic_svr_db_client_devowner.json'))
+samples_env.Alias(
+    "install",
+    samples_env.Install(sec_samples_build_dir,
+                        sec_samples_src_dir + 'oic_svr_db_client_nondevowner.json'))
+
+samples_env.Alias(
+    "install",
+    samples_env.Install(sec_samples_build_dir,
+                        sec_samples_src_dir + 'oic_svr_db_client_devowner.dat'))
+samples_env.Alias(
+    "install",
+    samples_env.Install(sec_samples_build_dir,
+                        sec_samples_src_dir + 'oic_svr_db_client_nondevowner.dat'))
diff --git a/resource/csdk/stack/samples/webos/secure/occlientbasicops/logging.h b/resource/csdk/stack/samples/webos/secure/occlientbasicops/logging.h
new file mode 100644
index 0000000..455b268
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/secure/occlientbasicops/logging.h
@@ -0,0 +1,69 @@
+/*******************************************************************
+ *
+ * Copyright (c) 2018 LG Electronics, Inc.
+ *
+ *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+ */
+
+#ifndef __LOGGING_H__
+#define __LOGGING_H__
+
+#include <PmLogLib.h>
+
+extern PmLogContext gLogContext;
+
+/* Logging for ocserverbasciops context ********
+ * The parameters needed are
+ * msgid - unique message id
+ * kvcount - count for key-value pairs
+ * ... - key-value pairs and free text. key-value pairs are formed using PMLOGKS or PMLOGKFV
+ * e.g.)
+ * WCALOG_CRITICAL(msgid, 2, PMLOGKS("key1", "value1"), PMLOGKFV("key2", "%d", value2), "free text message");
+ **********************************************/
+#define OCSAMPLE_LOG_CRITICAL(msgid, kvcount, ...) \
+        PmLogCritical(gLogContext, msgid, kvcount, ##__VA_ARGS__)
+
+#define OCSAMPLE_LOG_ERROR(msgid, kvcount, ...) \
+        PmLogError(gLogContext, msgid, kvcount,##__VA_ARGS__)
+
+#define OCSAMPLE_LOG_WARNING(msgid, kvcount, ...) \
+        PmLogWarning(gLogContext, msgid, kvcount, ##__VA_ARGS__)
+
+#define OCSAMPLE_LOG_INFO(msgid, kvcount, ...) \
+        PmLogInfo(gLogContext, msgid, kvcount, ##__VA_ARGS__)
+
+#define OCSAMPLE_LOG_DEBUG(...) \
+        PmLogDebug(gLogContext, ##__VA_ARGS__)
+
+#define OCSAMPLE_LOG_ESCAPED_ERRMSG(msgid, errmsg) \
+    do { \
+    gchar *escaped_errtext = g_strescape(errmsg, NULL); \
+    WCALOG_ERROR(msgid, 1, PMLOGKS("Error", escaped_errtext), ""); \
+    g_free(escaped_errtext); \
+    } while(0)
+
+#define OCSAMPLE_LOG_ADDR_INFOMSG(msgid, name, addr) \
+    do { \
+    gchar straddr[16]; \
+    snprintf(straddr, 16, "%p", addr); \
+    WCALOG_INFO(msgid, 1, PMLOGKS(name, straddr), ""); \
+    } while(0)
+
+/** list of MSGID's */
+#define MSGID_WIFI_SRVC_REGISTER_FAIL                   "WIFI_SRVC_REGISTER_FAIL"
+
+#endif // __LOGGING_H__
diff --git a/resource/csdk/stack/samples/webos/secure/occlientbasicops/occlientbasicops.cpp b/resource/csdk/stack/samples/webos/secure/occlientbasicops/occlientbasicops.cpp
new file mode 100644
index 0000000..c0afc91
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/secure/occlientbasicops/occlientbasicops.cpp
@@ -0,0 +1,612 @@
+/*******************************************************************
+ *
+ * Copyright (c) 2018 LG Electronics, Inc.
+ * Copyright 2014 Intel Mobile Communications GmbH All Rights Reserved.
+ *
+ *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+ */
+
+#include "iotivity_config.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <signal.h>
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#include <iostream>
+#include <sstream>
+#include <getopt.h>
+#include "ocstack.h"
+#include "occlientbasicops.h"
+#include "ocpayload.h"
+#include "sample_payload_logging.h"
+#include "oic_string.h"
+#include "common.h"
+
+
+/// This example is using experimental API, so there is no guarantee of support for future release,
+/// nor any there any guarantee that breaking changes will not occur across releases.
+#include "logger.h"
+
+#include <luna-service2/lunaservice.h>
+#include <pbnjson.h>
+#include <pthread.h>
+#include "logging.h"
+
+pthread_t threadId_client;
+PmLogContext gLogContext;
+
+#define TAG "occlientbasicops"
+static int UnicastDiscovery = 0;
+static int TestCase = 0;
+static int ConnType = 0;
+static int DevOwner = 0;
+static int WithTcp = 0;
+
+static char DISCOVERY_QUERY[] = "%s/oic/res";
+OCConnectivityType discoveryReqConnType = CT_ADAPTER_IP;
+
+static std::string coapServerResource;
+static int coapSecureResource;
+static OCConnectivityType ocConnType;
+
+//Secure Virtual Resource database for Iotivity Client application
+//It contains Client's Identity and the PSK credentials
+//of other devices which the client trusts
+static char CRED_FILE_DEVOWNER[] = "oic_svr_db_client_devowner.dat";
+static char CRED_FILE_NONDEVOWNER[] = "oic_svr_db_client_nondevowner.dat";
+
+//Standard uri prefix for secure virtual resources
+const char * OIC_STD_URI_PREFIX = "/oic/";
+
+const char * COAPS_STR = "coaps";
+#ifdef __WITH_TLS__
+const char * COAPS_TCP_STR = "coaps+tcp";
+#endif
+
+int gQuitFlag = 0;
+const char * COAPS_TCP_STR = "coaps+tcp";
+
+static LSHandle *pLsHandle = NULL;
+static GMainLoop *mainloop = NULL;
+static const char *gResourceUri = "/a/led";
+
+/* SIGINT handler: set gQuitFlag to 1 for graceful termination */
+void handleSigInt(int signum)
+{
+    if (signum == SIGINT)
+    {
+        gQuitFlag = 1;
+        g_main_loop_quit(mainloop);
+    }
+}
+
+OCPayload *putPayload()
+{
+    OCRepPayload *payload = OCRepPayloadCreate();
+
+    if (!payload)
+    {
+        std::cout << "Failed to create put payload object" << std::endl;
+        std::exit(1);
+    }
+
+    OCRepPayloadSetPropInt(payload, "power", 15);
+    OCRepPayloadSetPropBool(payload, "state", true);
+
+    return (OCPayload *) payload;
+}
+
+static void PrintUsage()
+{
+    printf("Usage : occlientbasicops -u <0|1> -t <1|2|3> -c <0|1>\n");
+    printf("-u <0|1> : Perform multicast/unicast discovery of resources\n");
+    printf("-t 1 : Discover Resources\n");
+    printf("-t 2 : Discover Resources and\n"
+            " Initiate Nonconfirmable Get/Put/Post Requests\n");
+    printf("-t 3 : Discover Resources and Initiate Confirmable Get/Put/Post Requests\n");
+    printf("-c 0 : Default auto-selection\n");
+    printf("-c 1 : IP Connectivity Type\n");
+    printf("-d 0 : Client as Non Device Owner\n");
+    printf("-d 1 : Client as Device Owner\n");
+    printf("-p 0 : Use UDP protocol\n");
+    printf("-p 1 : Use TCP protocol\n");
+}
+
+OCStackResult InvokeOCDoResource(std::ostringstream &query,
+                                 OCMethod method,
+                                 const OCDevAddr *dest,
+                                 OCQualityOfService qos,
+                                 OCClientResponseHandler cb,
+                                 OCHeaderOption *options, uint8_t numOptions)
+{
+    OCStackResult ret;
+    OCCallbackData cbData;
+
+    cbData.cb = cb;
+    cbData.context = NULL;
+    cbData.cd = NULL;
+
+    OCPayload *payload = (method == OC_REST_PUT || method == OC_REST_POST) ? putPayload() : NULL;
+
+    ret = OCDoRequest(NULL, method, query.str().c_str(), dest,
+                      payload, ocConnType, qos, &cbData, options, numOptions);
+
+    OCPayloadDestroy(payload);
+
+    if (ret != OC_STACK_OK)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "OCDoResource returns error %d with method %d", ret, method);
+    }
+
+    return ret;
+}
+
+OCStackApplicationResult putReqCB(void *, OCDoHandle, OCClientResponse *clientResponse)
+{
+    OCSAMPLE_LOG_INFO(TAG, 0, "Callback Context for PUT recvd successfully");
+
+    if (clientResponse)
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "StackResult: %s",  getResult(clientResponse->result));
+        OCSAMPLE_LOG_PAYLOAD(INFO, clientResponse->payload);
+        OCSAMPLE_LOG_INFO(TAG, 0, "=============> Put Response");
+    }
+    return OC_STACK_DELETE_TRANSACTION;
+}
+
+OCStackApplicationResult postReqCB(void *, OCDoHandle, OCClientResponse *clientResponse)
+{
+    OCSAMPLE_LOG_INFO(TAG, 0, "Callback Context for POST recvd successfully");
+
+    if (clientResponse)
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "StackResult: %s",  getResult(clientResponse->result));
+        OCSAMPLE_LOG_PAYLOAD(INFO, clientResponse->payload);
+        OCSAMPLE_LOG_INFO(TAG, 0, "=============> Post Response");
+    }
+    return OC_STACK_DELETE_TRANSACTION;
+}
+
+OCStackApplicationResult getReqCB(void *, OCDoHandle, OCClientResponse *clientResponse)
+{
+    OCSAMPLE_LOG_INFO(TAG, 0, "Callback Context for GET query recvd successfully");
+
+    if (clientResponse)
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "StackResult: %s",  getResult(clientResponse->result));
+        OCSAMPLE_LOG_INFO(TAG, 0, "SEQUENCE NUMBER: %d", clientResponse->sequenceNumber);
+        OCSAMPLE_LOG_PAYLOAD(INFO, clientResponse->payload);
+        OCSAMPLE_LOG_INFO(TAG, 0, "=============> Get Response");
+    }
+    return OC_STACK_DELETE_TRANSACTION;
+}
+
+// This is a function called back when a device is discovered
+OCStackApplicationResult discoveryReqCB(void *, OCDoHandle,
+                                        OCClientResponse *clientResponse)
+{
+    OCSAMPLE_LOG_INFO(TAG, 0, "Callback Context for DISCOVER query recvd successfully");
+
+    if (clientResponse)
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "StackResult: %s", getResult(clientResponse->result));
+        OCSAMPLE_LOG_INFO(TAG, 0,
+                  "Device =============> Discovered @ %s:%d",
+                  clientResponse->devAddr.addr,
+                  clientResponse->devAddr.port);
+
+        if (clientResponse->result == OC_STACK_OK)
+        {
+            OCSAMPLE_LOG_PAYLOAD(INFO, clientResponse->payload);
+
+            ocConnType = clientResponse->connType;
+
+            if (parseClientResponse(clientResponse) != -1)
+            {
+                OCDiscoveryPayload *payload = (OCDiscoveryPayload *) clientResponse->payload;
+                OCResourcePayload *resource = (OCResourcePayload *) payload->resources;
+                for (;resource; resource = resource->next)
+                {
+                    if ((0 == strcmp(gResourceUri, resource->uri))
+                         && (0 == strcmp(COAPS_STR, resource->eps->tps)))
+                    {
+                        OCDevAddr* endpoint = &clientResponse->devAddr;
+                        strcpy(endpoint->addr, resource->eps->addr);
+                        endpoint->port = resource->eps->port;
+                        endpoint->flags = resource->eps->family;
+
+                        switch (TestCase)
+                        {
+                        case TEST_NON_CON_OP:
+                            InitGetRequest(endpoint, OC_LOW_QOS);
+                            InitPutRequest(endpoint, OC_LOW_QOS);
+                            InitPostRequest(endpoint, OC_LOW_QOS);
+                            break;
+                        case TEST_CON_OP:
+                            InitGetRequest(endpoint, OC_HIGH_QOS);
+                            InitPutRequest(endpoint, OC_HIGH_QOS);
+                            InitPostRequest(endpoint, OC_HIGH_QOS);
+
+                        break;
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    return (UnicastDiscovery) ? OC_STACK_DELETE_TRANSACTION : OC_STACK_KEEP_TRANSACTION ;
+
+}
+int InitPutRequest(OCDevAddr *endpoint, OCQualityOfService qos)
+{
+    OCSAMPLE_LOG_INFO(TAG, 0, "Executing %s", __func__);
+    std::ostringstream query;
+    query << coapServerResource;
+
+    return (InvokeOCDoResource(query, OC_REST_PUT, endpoint,
+                               ((qos == OC_HIGH_QOS) ? OC_HIGH_QOS : OC_LOW_QOS), putReqCB, NULL, 0));
+}
+
+int InitPostRequest(OCDevAddr *endpoint, OCQualityOfService qos)
+{
+    OCStackResult result;
+
+    OCSAMPLE_LOG_INFO(TAG, 0, "Executing %s", __func__);
+    std::ostringstream query;
+    query << coapServerResource;
+
+    // First PUT operation (to create an LED instance)
+    result = InvokeOCDoResource(query, OC_REST_PUT, endpoint,
+                                ((qos == OC_HIGH_QOS) ? OC_HIGH_QOS : OC_LOW_QOS),
+                                putReqCB, NULL, 0);
+    if (OC_STACK_OK != result)
+    {
+        // Error can happen if for example, network connectivity is down
+        OCSAMPLE_LOG_INFO(TAG, 0, "First POST call did not succeed");
+    }
+
+    // Second PUT operation (to create an LED instance)
+    result = InvokeOCDoResource(query, OC_REST_PUT, endpoint,
+                                ((qos == OC_HIGH_QOS) ? OC_HIGH_QOS : OC_LOW_QOS),
+                                putReqCB, NULL, 0);
+    if (OC_STACK_OK != result)
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "Second POST call did not succeed");
+    }
+
+    // This POST operation will update the original resourced /a/led (as long as
+    // the server is set to max 2 /lcd resources)
+    result = InvokeOCDoResource(query, OC_REST_POST, endpoint,
+                                ((qos == OC_HIGH_QOS) ? OC_HIGH_QOS : OC_LOW_QOS),
+                                postReqCB, NULL, 0);
+    if (OC_STACK_OK != result)
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "Third POST call did not succeed");
+    }
+    return result;
+}
+
+int InitGetRequest(OCDevAddr *endpoint, OCQualityOfService qos)
+{
+    OCSAMPLE_LOG_INFO(TAG, 0, "Executing %s", __func__);
+    std::ostringstream query;
+    query << coapServerResource;
+
+    return (InvokeOCDoResource(query, OC_REST_GET, endpoint,
+                               ((qos == OC_HIGH_QOS) ?  OC_HIGH_QOS : OC_LOW_QOS),
+                               getReqCB, NULL, 0));
+}
+
+int InitDiscovery()
+{
+    OCStackResult ret;
+    OCCallbackData cbData;
+    char queryUri[200];
+    char ipaddr[100] = { '\0' };
+
+    if (UnicastDiscovery)
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "Enter IP address (with optional port) of the Server hosting resource\n");
+        OCSAMPLE_LOG_INFO(TAG, 0, "IPv4: 192.168.0.15:45454\n");
+        OCSAMPLE_LOG_INFO(TAG, 0, "IPv6: [fe80::20c:29ff:fe1b:9c5]:45454\n");
+
+        if (fgets(ipaddr, sizeof (ipaddr), stdin))
+        {
+            StripNewLineChar(ipaddr); //Strip newline char from ipaddr
+        }
+        else
+        {
+            OCSAMPLE_LOG_ERROR(TAG, 0, "!! Bad input for IP address. !!");
+            return OC_STACK_INVALID_PARAM;
+        }
+    }
+    snprintf(queryUri, sizeof (queryUri), DISCOVERY_QUERY, ipaddr);
+
+    cbData.cb = discoveryReqCB;
+    cbData.context = NULL;
+    cbData.cd = NULL;
+
+    /* Start a discovery query*/
+    OCSAMPLE_LOG_INFO(TAG, 0, "Initiating %s Resource Discovery : %s\n",
+              (UnicastDiscovery) ? "Unicast" : "Multicast",
+              queryUri);
+
+    ret = OCDoRequest(NULL, OC_REST_DISCOVER, queryUri, 0, 0, CT_DEFAULT,
+                      OC_LOW_QOS, &cbData, NULL, 0);
+    if (ret != OC_STACK_OK)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "OCStack resource error");
+    }
+    return ret;
+}
+
+FILE *client_fopen_devowner(const char *path, const char *mode)
+{
+    if (0 == strcmp(path, OC_SECURITY_DB_DAT_FILE_NAME))
+    {
+        return fopen(CRED_FILE_DEVOWNER, mode);
+    }
+    else
+    {
+        return fopen(path, mode);
+    }
+}
+
+FILE *client_fopen_nondevowner(const char *path, const char *mode)
+{
+    if (0 == strcmp(path, OC_SECURITY_DB_DAT_FILE_NAME))
+    {
+        return fopen(CRED_FILE_NONDEVOWNER, mode);
+    }
+    else
+    {
+        return fopen(path, mode);
+    }
+}
+
+static gboolean clientStarter(gpointer user_data)
+{
+    if (!gQuitFlag)
+    {   
+        if (OCProcess() != OC_STACK_OK)
+        {
+            OCSAMPLE_LOG_ERROR(TAG, 0, "OCStack process error");
+        }
+        return TRUE;
+    }   
+    else
+    {   
+        OCSAMPLE_LOG_INFO(TAG, 0, "Stopping clientStarter loop...");
+        return FALSE;
+    }   
+}
+
+int main(int argc, char *argv[])
+{
+    int opt;
+    struct timespec timeout;
+    OCPersistentStorage ps;
+
+    LSError lserror;
+    LSErrorInit(&lserror);
+
+    (void) PmLogGetContext("OCCLIENTBASICOPS", &gLogContext);
+
+    // Initialize g_main_loop
+    mainloop = g_main_loop_new(NULL, FALSE);
+    if (!mainloop) {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Failed to create main loop");
+        return 0;
+    }
+
+    if (!LSRegister("org.ocf.webossample.occlientbasicops", &pLsHandle, &lserror)) {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Failed to register LS Handle");
+        LSErrorLog(gLogContext, "LS_SRVC_ERROR", &lserror);
+        return 0;
+    }
+
+    if (!LSGmainAttach(pLsHandle, mainloop, &lserror)) {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Failed to attach main loop");
+        LSErrorLog(gLogContext, "LS_SRVC_ATTACH_ERROR", &lserror);
+        return 0;
+    }
+
+    while ((opt = getopt(argc, argv, "u:t:c:d:p:")) != -1)
+    {
+        switch (opt)
+        {
+            case 'u':
+                UnicastDiscovery = atoi(optarg);
+                break;
+            case 't':
+                TestCase = atoi(optarg);
+                break;
+            case 'c':
+                ConnType = atoi(optarg);
+                break;
+            case 'd':
+                DevOwner = atoi(optarg);
+                break;
+            case 'p':
+                {
+                    WithTcp = atoi(optarg);
+                    if (WithTcp > 1)
+                    {
+                        PrintUsage();
+                        return -1;
+                    }
+                }
+                break;
+            default:
+                PrintUsage();
+                return -1;
+        }
+    }
+
+    if ((UnicastDiscovery != 0 && UnicastDiscovery != 1) ||
+        (TestCase < TEST_DISCOVER_REQ || TestCase >= MAX_TESTS) ||
+        (ConnType < CT_ADAPTER_DEFAULT || ConnType >= MAX_CT))
+    {
+        PrintUsage();
+        return -1;
+    }
+
+
+    if (ConnType == CT_ADAPTER_DEFAULT || ConnType ==  CT_IP)
+    {
+        discoveryReqConnType = CT_DEFAULT;
+    }
+    else
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "Using Default Connectivity type");
+        PrintUsage();
+    }
+
+
+    // Initialize Persistent Storage for SVR database
+    if (DevOwner)
+        ps = { client_fopen_devowner, fread, fwrite, fclose, unlink };
+    else
+        ps = { client_fopen_nondevowner, fread, fwrite, fclose, unlink };
+    OCRegisterPersistentStorageHandler(&ps);
+
+    /* Initialize OCStack*/
+    if (OCInit(NULL, 0, OC_CLIENT_SERVER) != OC_STACK_OK)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "OCStack init error");
+        return 0;
+    }
+
+    InitDiscovery();
+
+    timeout.tv_sec  = 0;
+    timeout.tv_nsec = 100000000L;
+
+    // Break from loop with Ctrl+C
+    OCSAMPLE_LOG_INFO(TAG, 0, "Entering clientStarter main loop...");
+    signal(SIGINT, handleSigInt);
+    g_timeout_add_seconds(1, clientStarter, NULL);
+    g_main_loop_run(mainloop);
+
+    OCSAMPLE_LOG_INFO(TAG, 0, "Exiting occlient main loop...");
+
+    if (OCStop() != OC_STACK_OK)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "OCStack stop error");
+    }
+
+    return 0;
+}
+
+int parseClientResponse(OCClientResponse *clientResponse)
+{
+    OCResourcePayload *res = ((OCDiscoveryPayload *)clientResponse->payload)->resources;
+
+    // Initialize all global variables
+    coapServerResource.clear();
+    coapSecureResource = 0;
+
+    while (res)
+    {
+        coapServerResource.assign(res->uri);
+        OCSAMPLE_LOG_INFO(TAG, 0, "Uri -- %s", coapServerResource.c_str());
+
+        if (0 == strncmp(coapServerResource.c_str(), OIC_STD_URI_PREFIX, strlen(OIC_STD_URI_PREFIX)) ||
+            0 == strncmp(coapServerResource.c_str(), "/introspection", strlen("/introspection")))
+        {
+            OCSAMPLE_LOG_INFO(TAG, 0, "Skip resource");
+            res = res->next;
+            continue;
+        }
+
+        OCDevAddr *endpoint = &clientResponse->devAddr;
+        if (res && res->eps)
+        {
+            endpoint->port = 0;
+            OCEndpointPayload* eps = res->eps;
+            while (NULL != eps)
+            {
+                if (eps->family & OC_FLAG_SECURE)
+                {
+#ifdef __WITH_TLS__
+                    if (WithTcp && 0 == strcmp(eps->tps, COAPS_TCP_STR))
+                    {
+                        strncpy(endpoint->addr, eps->addr, sizeof(endpoint->addr));
+                        endpoint->port = eps->port;
+                        endpoint->flags = (OCTransportFlags)(eps->family | OC_SECURE);
+                        endpoint->adapter = OC_ADAPTER_TCP;
+                        coapSecureResource = 1;
+                        OCSAMPLE_LOG_INFO(TAG, 0, "TLS port: %d", endpoint->port);
+                        break;
+                    }
+#endif
+                    if (!WithTcp && 0 == strcmp(eps->tps, COAPS_STR))
+                    {
+                        strncpy(endpoint->addr, eps->addr, sizeof(endpoint->addr));
+                        endpoint->port = eps->port;
+                        endpoint->flags = (OCTransportFlags)(eps->family | OC_SECURE);
+                        endpoint->adapter = OC_ADAPTER_IP;
+                        coapSecureResource = 1;
+                        OCSAMPLE_LOG_INFO(TAG, 0, "DTLS port: %d", endpoint->port);
+                    }
+                }
+                eps = eps->next;
+            }
+            if (!endpoint->port)
+            {
+                OCSAMPLE_LOG_INFO(TAG, 0, "Can not find secure port information.");
+            }
+        }
+
+        //old servers support
+        if (0 == coapSecureResource && res->secure)
+        {
+#ifdef __WITH_TLS__
+            if (WithTcp)
+            {
+                endpoint->flags = (OCTransportFlags)(endpoint->flags | OC_SECURE);
+                endpoint->adapter = OC_ADAPTER_TCP;
+                endpoint->port = res->tcpPort;
+                OCSAMPLE_LOG_INFO(TAG, 0, "TLS port: %d", endpoint->port);
+            }
+            else
+#endif
+            {
+                endpoint->port = res->port;
+                endpoint->flags = (OCTransportFlags)(endpoint->flags | OC_SECURE);
+                endpoint->adapter = OC_ADAPTER_IP;
+                OCSAMPLE_LOG_INFO(TAG, 0, "DTLS port: %d", endpoint->port);
+            }
+            coapSecureResource = 1;
+        }
+
+        OCSAMPLE_LOG_INFO(TAG, 0, "Secure -- %s", coapSecureResource == 1 ? "YES" : "NO");
+
+        // If we discovered a secure resource, exit from here
+        if (coapSecureResource)
+        {
+            break;
+        }
+
+        res = res->next;
+    }
+
+    return 0;
+}
diff --git a/resource/csdk/stack/samples/webos/secure/occlientbasicops/occlientbasicops.h b/resource/csdk/stack/samples/webos/secure/occlientbasicops/occlientbasicops.h
new file mode 100644
index 0000000..ab00f9e
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/secure/occlientbasicops/occlientbasicops.h
@@ -0,0 +1,108 @@
+/*******************************************************************
+ *
+ * Copyright (c) 2018 LG Electronics, Inc.
+ * Copyright 2014 Intel Mobile Communications GmbH All Rights Reserved.
+ *
+ *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+ */
+
+#ifndef OCCLIENT_BASICOPS_H_
+#define OCCLIENT_BASICOPS_H_
+
+#include "ocstack.h"
+
+//-----------------------------------------------------------------------------
+// Defines
+//-----------------------------------------------------------------------------
+#define DEFAULT_CONTEXT_VALUE 0x99
+
+//-----------------------------------------------------------------------------
+// Typedefs
+//-----------------------------------------------------------------------------
+
+/**
+ * List of methods that can be inititated from the client
+ */
+typedef enum {
+    TEST_DISCOVER_REQ = 1,
+    TEST_NON_CON_OP,
+    TEST_CON_OP,
+    MAX_TESTS
+} CLIENT_TEST;
+
+/**
+ * List of connectivity types that can be initiated from the client
+ * Required for user input validation
+ */
+typedef enum {
+    CT_ADAPTER_DEFAULT = 0,
+    CT_IP,
+    MAX_CT
+} CLIENT_CONNECTIVITY_TYPE;
+
+//-----------------------------------------------------------------------------
+// Function prototype
+//-----------------------------------------------------------------------------
+
+/* Get the IP address of the server */
+std::string getIPAddrTBServer(OCClientResponse * clientResponse);
+
+/* Get the port number the server is listening on */
+std::string getPortTBServer(OCClientResponse * clientResponse);
+
+/* Returns the query string for GET and PUT operations */
+std::string getQueryStrForGetPut(OCClientResponse * clientResponse);
+
+/* Following are initialization functions for GET, PUT
+ * POST & Discovery operations
+ */
+int InitPutRequest(OCDevAddr *endpoint, OCQualityOfService qos);
+int InitGetRequest(OCDevAddr *endpoint, OCQualityOfService qos);
+int InitPostRequest(OCDevAddr *endpoint, OCQualityOfService qos);
+int InitDiscovery();
+
+/* Function to retrieve ip address, port no. of the server
+ *  and query for the operations to be performed.
+ */
+int parseClientResponse(OCClientResponse * clientResponse);
+
+/* This method calls OCDoResource() which in turn makes calls
+ * to the lower layers
+ */
+OCStackResult InvokeOCDoResource(std::ostringstream &query,
+        OCMethod method, OCQualityOfService qos,
+        OCClientResponseHandler cb, OCHeaderOption * options, uint8_t numOptions);
+
+//-----------------------------------------------------------------------------
+// Callback functions
+//-----------------------------------------------------------------------------
+
+/* Following are callback functions for the  GET, PUT
+ * POST & Discovery operations
+ */
+
+OCStackApplicationResult putReqCB(void* ctx, OCDoHandle handle, OCClientResponse * clientResponse);
+
+OCStackApplicationResult postReqCB(void *ctx, OCDoHandle handle, OCClientResponse *clientResponse);
+
+OCStackApplicationResult getReqCB(void* ctx, OCDoHandle handle, OCClientResponse * clientResponse);
+
+OCStackApplicationResult discoveryReqCB(void* ctx, OCDoHandle handle,
+        OCClientResponse * clientResponse);
+
+#endif
+
diff --git a/resource/csdk/stack/samples/webos/secure/occlientbasicops/oic_svr_db_client_devowner.json b/resource/csdk/stack/samples/webos/secure/occlientbasicops/oic_svr_db_client_devowner.json
new file mode 100644
index 0000000..286428b
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/secure/occlientbasicops/oic_svr_db_client_devowner.json
@@ -0,0 +1,61 @@
+{
+    "acl": {
+        "aclist2": [
+            {
+                "aceid": 1,
+                "subject": { "conntype": "anon-clear" },
+                "resources": [
+                    { "href": "/oic/res" },
+                    { "href": "/oic/d" },
+                    { "href": "/oic/p" },
+                    { "href": "/oic/sec/doxm" }
+                ],
+                "permission": 2
+            },
+            {
+                "aceid": 2,
+                "subject": { "conntype": "auth-crypt" },
+                "resources": [
+                    { "href": "/oic/res" },
+                    { "href": "/oic/d" },
+                    { "href": "/oic/p" },
+                    { "href": "/oic/sec/doxm" }
+                ],
+                "permission": 2
+            }
+        ],
+        "rowneruuid" : "32323232-3232-3232-3232-323232323232"
+    },
+    "pstat": {
+        "dos": {"s": 3, "p": false},
+        "isop": true,
+        "rowneruuid": "32323232-3232-3232-3232-323232323232",
+        "cm": 0,
+        "tm": 0,
+        "om": 4,
+        "sm": 4
+        },
+    "doxm": {
+        "oxms": [0],
+        "oxmsel": 0,
+        "sct": 9,
+        "owned": true,
+        "deviceuuid": "32323232-3232-3232-3232-323232323232",
+        "devowneruuid": "32323232-3232-3232-3232-323232323232",
+        "rowneruuid": "32323232-3232-3232-3232-323232323232"
+    },
+    "cred": {
+        "creds": [
+            {
+                "credid": 1,
+                "subjectuuid": "31313131-3131-3131-3131-313131313131",
+                "credtype": 1,
+                "privatedata": {
+                    "data": "AAAAAAAAAAAAAAAA",
+                    "encoding": "oic.sec.encoding.raw"
+                }
+            }
+        ],
+        "rowneruuid": "32323232-3232-3232-3232-323232323232"
+    }
+}
diff --git a/resource/csdk/stack/samples/webos/secure/occlientbasicops/oic_svr_db_client_nondevowner.json b/resource/csdk/stack/samples/webos/secure/occlientbasicops/oic_svr_db_client_nondevowner.json
new file mode 100644
index 0000000..54aecee
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/secure/occlientbasicops/oic_svr_db_client_nondevowner.json
@@ -0,0 +1,61 @@
+{
+    "acl": {
+        "aclist2": [
+            {
+                "aceid": 1,
+                "subject": { "conntype": "anon-clear" },
+                "resources": [
+                    { "href": "/oic/res" },
+                    { "href": "/oic/d" },
+                    { "href": "/oic/p" },
+                    { "href": "/oic/sec/doxm" }
+                ],
+                "permission": 2
+            },
+            {
+                "aceid": 2,
+                "subject": { "conntype": "auth-crypt" },
+                "resources": [
+                    { "href": "/oic/res" },
+                    { "href": "/oic/d" },
+                    { "href": "/oic/p" },
+                    { "href": "/oic/sec/doxm" }
+                ],
+                "permission": 2
+            }
+        ],
+        "rowneruuid" : "31393139-3139-3139-3139-313931393139"
+    },
+    "pstat": {
+        "dos": {"s": 3, "p": false},
+        "isop": true,
+        "rowneruuid": "31393139-3139-3139-3139-313931393139",
+        "cm": 0,
+        "tm": 0,
+        "om": 4,
+        "sm": 4
+        },
+    "doxm": {
+        "oxms": [0],
+        "oxmsel": 0,
+        "sct": 9,
+        "owned": true,
+        "deviceuuid": "31393139-3139-3139-3139-313931393139",
+        "devowneruuid": "31393139-3139-3139-3139-313931393139",
+        "rowneruuid": "31393139-3139-3139-3139-313931393139"
+    },
+    "cred": {
+        "creds": [
+            {
+                "credid": 1,
+                "subjectuuid": "31313131-3131-3131-3131-313131313131",
+                "credtype": 1,
+                "privatedata": {
+                    "data": "BBBBBBBBBBBBBBBB",
+                    "encoding": "oic.sec.encoding.raw"
+                }
+            }
+        ],
+        "rowneruuid": "31393139-3139-3139-3139-313931393139"
+    }
+}
diff --git a/resource/csdk/stack/samples/webos/secure/occlientbasicops/sample_payload_logging.h b/resource/csdk/stack/samples/webos/secure/occlientbasicops/sample_payload_logging.h
new file mode 100644
index 0000000..5dfc666
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/secure/occlientbasicops/sample_payload_logging.h
@@ -0,0 +1,356 @@
+/*******************************************************************
+ *
+ * Copyright (c) 2018 LG Electronics, Inc.
+ * Copyright 2015 Intel Mobile Communications GmbH All Rights Reserved.
+ *
+ *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+ */
+
+#ifndef SAMPLE_PAYLOAD_LOGGING_H_
+#define SAMPLE_PAYLOAD_LOGGING_H_
+
+#ifndef __STDC_FORMAT_MACROS
+#define __STDC_FORMAT_MACROS
+#endif
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS
+#endif
+
+#include "logger.h"
+#include "oic_malloc.h"
+#include "ocpayload.h"
+#include "ocstack.h"
+
+#include "logging.h"
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+// PL_TAG is made as generic predefined tag because of build problems in arduino for using logging
+#define PL_TAG "PayloadLog"
+
+#ifdef TB_LOG
+    #define OCSAMPLE_LOG_PAYLOAD(level, payload) OCPayloadLog((level),(payload))
+    #define UUID_SIZE (16)
+
+const char *OC_CALL convertTriggerEnumToString(OCPresenceTrigger trigger);
+OCPresenceTrigger OC_CALL convertTriggerStringToEnum(const char * triggerStr);
+
+INLINE_API void OCPayloadLogRep(LogLevel level, OCRepPayload* payload);
+
+INLINE_API void OCPayloadLogRepValues(LogLevel level, OCRepPayloadValue* val)
+{
+    while (val)
+    {
+        switch(val->type)
+        {
+            case OCREP_PROP_NULL:
+                OCSAMPLE_LOG_INFO(PL_TAG, 0, "        %s: NULL", val->name);
+                break;
+            case OCREP_PROP_INT:
+                OCSAMPLE_LOG_INFO(PL_TAG, 0, "        %s(int):%" PRId64, val->name, val->i);
+                break;
+            case OCREP_PROP_DOUBLE:
+                OCSAMPLE_LOG_INFO(PL_TAG, 0, "        %s(double):%f", val->name, val->d);
+                break;
+            case OCREP_PROP_BOOL:
+                OCSAMPLE_LOG_INFO(PL_TAG, 0, "        %s(bool):%s", val->name, val->b ? "true" : "false");
+                break;
+            case OCREP_PROP_STRING:
+                OCSAMPLE_LOG_INFO(PL_TAG, 0, "        %s(string):%s", val->name, val->str);
+                break;
+            case OCREP_PROP_BYTE_STRING:
+                OCSAMPLE_LOG_INFO(PL_TAG, 0, "        %s(binary):", val->name);
+                OIC_LOG_BUFFER(level, PL_TAG, val->ocByteStr.bytes, val->ocByteStr.len);
+                break;
+            case OCREP_PROP_OBJECT:
+                // Note: Only prints the URI (if available), to print further, you'll
+                // need to dig into the object better!
+                OCSAMPLE_LOG_INFO(PL_TAG, 0, "        %s(object):", val->name);
+                OCPayloadLogRep(level, val->obj);
+                break;
+            case OCREP_PROP_ARRAY:
+                switch(val->arr.type)
+                {
+                    case OCREP_PROP_INT:
+                        OCSAMPLE_LOG_INFO(PL_TAG, 0, "        %s(int array):%" PRIuPTR " x %" PRIuPTR " x %" PRIuPTR ": ",
+                                val->name,
+                                val->arr.dimensions[0], val->arr.dimensions[1],
+                                val->arr.dimensions[2]);
+                        OCSAMPLE_LOG_INFO(PL_TAG, 0,  "         Values:");
+                        for (size_t i = 0; i < val->arr.dimensions[0]; i++)
+                        {
+                            OCSAMPLE_LOG_INFO(PL_TAG, 0, "             %" PRId64, val->arr.iArray[i]);
+                        }
+                        break;
+                    case OCREP_PROP_DOUBLE:
+                        OCSAMPLE_LOG_INFO(PL_TAG, 0, "        %s(double array):%" PRIuPTR " x %" PRIuPTR " x %" PRIuPTR ": ",
+                                val->name,
+                                val->arr.dimensions[0], val->arr.dimensions[1],
+                                val->arr.dimensions[2]);
+                        OCSAMPLE_LOG_INFO(PL_TAG, 0,  "         Values:");
+                        for (size_t i = 0; i < val->arr.dimensions[0]; i++)
+                        {
+                            OCSAMPLE_LOG_INFO(PL_TAG, 0, "             %lf", val->arr.dArray[i]);
+                        }
+                        break;
+                    case OCREP_PROP_BOOL:
+                        OCSAMPLE_LOG_INFO(PL_TAG, 0, "        %s(bool array):%" PRIuPTR " x %" PRIuPTR " x %" PRIuPTR ": ",
+                                val->name,
+                                val->arr.dimensions[0], val->arr.dimensions[1],
+                                val->arr.dimensions[2]);
+                        OCSAMPLE_LOG_INFO(PL_TAG, 0,  "         Values:");
+                        for (size_t i = 0; i < val->arr.dimensions[0]; i++)
+                        {
+                            OCSAMPLE_LOG_INFO(PL_TAG, 0, "             %d", val->arr.bArray[i]);
+                        }
+                        break;
+                    case OCREP_PROP_STRING:
+                        OCSAMPLE_LOG_INFO(PL_TAG, 0, "        %s(string array):%" PRIuPTR " x %" PRIuPTR " x %" PRIuPTR ": ",
+                                val->name,
+                                val->arr.dimensions[0], val->arr.dimensions[1],
+                                val->arr.dimensions[2]);
+                        OCSAMPLE_LOG_INFO(PL_TAG, 0,  "         Values:");
+                        for (size_t i = 0; i < val->arr.dimensions[0]; i++)
+                        {
+                            OCSAMPLE_LOG_INFO(PL_TAG, 0, "             %s", val->arr.strArray[i]);
+                        }
+                        break;
+                    case OCREP_PROP_BYTE_STRING:
+                        OCSAMPLE_LOG_INFO(PL_TAG, 0, "        %s(byte array):%" PRIuPTR " x %" PRIuPTR " x %" PRIuPTR ": ",
+                                val->name,
+                                val->arr.dimensions[0], val->arr.dimensions[1],
+                                val->arr.dimensions[2]);
+                        OCSAMPLE_LOG_INFO(PL_TAG, 0,  "         Values:");
+                        for (size_t i = 0; i < val->arr.dimensions[0]; i++)
+                        {
+                            OIC_LOG_BUFFER(level, PL_TAG, val->arr.ocByteStrArray[i].bytes, val->arr.ocByteStrArray[i].len);
+                        }
+                        break;
+                    case OCREP_PROP_OBJECT:
+                        OCSAMPLE_LOG_INFO(PL_TAG, 0, "        %s(object array):%" PRIuPTR " x %" PRIuPTR " x %" PRIuPTR ": ",
+                                val->name,
+                                val->arr.dimensions[0], val->arr.dimensions[1],
+                                val->arr.dimensions[2]);
+                        OCSAMPLE_LOG_INFO(PL_TAG, 0,  "         Values:");
+
+                        for (size_t i = 0; i < val->arr.dimensions[0]; i++)
+                        {
+                            OCPayloadLogRep(level, val->arr.objArray[i]);
+                        }
+                        break;
+                    case OCREP_PROP_ARRAY: //Seems as nested arrays doesn't not supported in API
+                    default:
+                        OCSAMPLE_LOG_ERROR(PL_TAG, 0, "%s <-- Unknown/unsupported array type!",
+                                val->name);
+                        break;
+                }
+                break;
+            default:
+                OCSAMPLE_LOG_ERROR(PL_TAG, 0, "%s <-- Unknown type!", val->name);
+                break;
+        }
+        val = val -> next;
+    }
+}
+
+INLINE_API void OCPayloadLogRep(LogLevel level, OCRepPayload* payload)
+{
+    OCSAMPLE_LOG_INFO(PL_TAG, 0, "Payload Type: Representation");
+    uint32_t i = 1;
+    for (OCRepPayload* rep = payload; rep; rep = rep->next, ++i)
+    {
+        OCSAMPLE_LOG_INFO(PL_TAG, 0, "    Resource #%d", i);
+        if (rep->uri)
+        {
+            OCSAMPLE_LOG_INFO(PL_TAG, 0, "    URI:%s", rep->uri);
+        }
+        if (rep->types)
+        {
+            OCSAMPLE_LOG_INFO(PL_TAG, 0,  "    Resource Types:");
+            for (OCStringLL* strll = rep->types; strll; strll = strll->next)
+            {
+                OCSAMPLE_LOG_INFO(PL_TAG, 0, "        %s", strll->value);
+            }
+        }
+        if (rep->interfaces)
+        {
+            OCSAMPLE_LOG_INFO(PL_TAG, 0,  "    Interfaces:");
+            for (OCStringLL* strll = rep->interfaces; strll; strll = strll->next)
+            {
+                OCSAMPLE_LOG_INFO(PL_TAG, 0, "        %s", strll->value);
+            }
+        }
+        OCSAMPLE_LOG_INFO(PL_TAG, 0,  "    Values:");
+        OCPayloadLogRepValues(level, rep->values);
+    }
+}
+
+static void OCStringLLPrint(LogLevel level, OCStringLL *type)
+{
+    for (OCStringLL *strll = type; strll; strll = strll->next)
+    {
+        OCSAMPLE_LOG_INFO(PL_TAG, 0, "         %s", strll->value);
+    }
+}
+
+INLINE_API void OCPayloadLogDiscovery(LogLevel level, OCDiscoveryPayload* payload)
+{
+    OCSAMPLE_LOG_INFO(PL_TAG, 0,  "Payload Type: Discovery");
+
+    while(payload && payload->resources)
+    {
+        OCSAMPLE_LOG_INFO(PL_TAG, 0, "    DI: %s", payload->sid);
+        if (payload->name)
+        {
+            OCSAMPLE_LOG_INFO(PL_TAG, 0, "    NAME: %s", payload->name);
+        }
+
+        if (payload->type)
+        {
+            OCSAMPLE_LOG_INFO(PL_TAG, 0,  "    Resource Type:");
+            OCStringLLPrint(level, payload->type);
+        }
+
+        if (payload->iface)
+        {
+            OCSAMPLE_LOG_INFO(PL_TAG, 0,  "    Interface:");
+            OCStringLLPrint(level, payload->iface);
+        }
+
+        OCResourcePayload* res = payload->resources;
+
+        uint32_t i = 1;
+        while(res)
+        {
+            OCSAMPLE_LOG_INFO(PL_TAG, 0, "    Link#%d", i);
+            OCSAMPLE_LOG_INFO(PL_TAG, 0, "    URI:%s", res->uri);
+            if (res->rel)
+            {
+                OCSAMPLE_LOG_INFO(PL_TAG, 0, "    Relation:%s", res->rel);
+            }
+            if (res->anchor)
+            {
+                OCSAMPLE_LOG_INFO(PL_TAG, 0, "    Anchor:%s", res->anchor);
+            }
+            OCSAMPLE_LOG_INFO(PL_TAG, 0,  "    Resource Types:");
+            OCStringLL* strll =  res->types;
+            while(strll)
+            {
+                OCSAMPLE_LOG_INFO(PL_TAG, 0, "        %s", strll->value);
+                strll = strll->next;
+            }
+            OCSAMPLE_LOG_INFO(PL_TAG, 0,  "    Interfaces:");
+            strll =  res->interfaces;
+            while(strll)
+            {
+                OCSAMPLE_LOG_INFO(PL_TAG, 0, "        %s", strll->value);
+                strll = strll->next;
+            }
+
+            OCSAMPLE_LOG_INFO(PL_TAG, 0, "    Bitmap: %u", res->bitmap);
+            OCSAMPLE_LOG_INFO(PL_TAG, 0, "    Secure?: %s", res->secure ? "true" : "false");
+            OCSAMPLE_LOG_INFO(PL_TAG, 0, "    Port: %u", res->port);
+
+            uint32_t j = 1;
+            OCEndpointPayload* eps = res->eps;
+            while (eps)
+            {
+                OCSAMPLE_LOG_INFO(PL_TAG, 0, "    Endpoint #%d", j);
+                OCSAMPLE_LOG_INFO(PL_TAG, 0, "        tps: %s", eps->tps);
+                OCSAMPLE_LOG_INFO(PL_TAG, 0, "        addr: %s", eps->addr);
+                OCSAMPLE_LOG_INFO(PL_TAG, 0, "        port: %d", eps->port);
+                OCSAMPLE_LOG_INFO(PL_TAG, 0, "        pri: %d", eps->pri);
+                eps = eps->next;
+                ++j;
+            }
+
+            OCSAMPLE_LOG_INFO(PL_TAG, 0,  "");
+            res = res->next;
+            ++i;
+        }
+        payload = payload->next;
+    }
+}
+
+INLINE_API void OCPayloadLogPresence(LogLevel level, OCPresencePayload* payload)
+{
+    OCSAMPLE_LOG_INFO(PL_TAG, 0,  "Payload Type: Presence");
+    OCSAMPLE_LOG_INFO(PL_TAG, 0, "    Sequence Number:%u", payload->sequenceNumber);
+    OCSAMPLE_LOG_INFO(PL_TAG, 0, "    Max Age:%d", payload->maxAge);
+    OCSAMPLE_LOG_INFO(PL_TAG, 0, "    Trigger:%s", convertTriggerEnumToString(payload->trigger));
+    OCSAMPLE_LOG_INFO(PL_TAG, 0, "    Resource Type:%s", payload->resourceType);
+}
+
+INLINE_API void OCPayloadLogSecurity(LogLevel level, OCSecurityPayload* payload)
+{
+    size_t payloadSize = payload->payloadSize;
+    OCSAMPLE_LOG_INFO(PL_TAG, 0,  "Payload Type: Security");
+
+    if (payloadSize > 0)
+    {
+        // Add a zero-character string terminator.
+        char *securityData = (char *)OICMalloc(payloadSize + 1);
+
+        if (securityData)
+        {
+            memcpy(securityData, payload->securityData, payloadSize);
+            // assert(securityData[payloadSize - 1] != '\0');
+            securityData[payloadSize] = '\0';
+            OCSAMPLE_LOG_INFO(PL_TAG, 0, "    Security Data: %s", securityData);
+            OICFree(securityData);
+        }
+    }
+}
+
+INLINE_API void OCPayloadLog(LogLevel level, OCPayload* payload)
+{
+    if(!payload)
+    {
+        OCSAMPLE_LOG_INFO(PL_TAG, 0,  "NULL Payload");
+        return;
+    }
+    switch(payload->type)
+    {
+        case PAYLOAD_TYPE_REPRESENTATION:
+            OCPayloadLogRep(level, (OCRepPayload*)payload);
+            break;
+        case PAYLOAD_TYPE_DISCOVERY:
+            OCPayloadLogDiscovery(level, (OCDiscoveryPayload*)payload);
+            break;
+        case PAYLOAD_TYPE_PRESENCE:
+            OCPayloadLogPresence(level, (OCPresencePayload*)payload);
+            break;
+        case PAYLOAD_TYPE_SECURITY:
+            OCPayloadLogSecurity(level, (OCSecurityPayload*)payload);
+            break;
+        default:
+            OCSAMPLE_LOG_INFO(PL_TAG, 0, "Unknown Payload Type: %d", payload->type);
+            break;
+    }
+}
+#else
+    #define OCSAMPLE_LOG_PAYLOAD(level, payload)
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/resource/csdk/stack/samples/webos/secure/ocserverbasicops/SConscript b/resource/csdk/stack/samples/webos/secure/ocserverbasicops/SConscript
new file mode 100644
index 0000000..b18eabe
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/secure/ocserverbasicops/SConscript
@@ -0,0 +1,98 @@
+#******************************************************************
+#
+# Copyright (c) 2018 LG Electronics, Inc.
+# Copyright 2014 Intel Mobile Communications GmbH All Rights Reserved.
+#
+#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+Import('stacksamples_env')
+
+samples_env = stacksamples_env.Clone()
+######################################################################
+# Build flags
+######################################################################
+samples_env.PrependUnique(CPPPATH=[
+    '../../../../../logger/include',
+    '../../../../../include',
+    '../../../../../stack/include',
+    '../../../../../security/include',
+    '../../../../../../oc_logger/include',
+    '../'
+])
+
+target_os = samples_env.get('TARGET_OS')
+if target_os not in ['windows']:
+    samples_env.AppendUnique(CXXFLAGS=['-std=c++0x', '-Wall', '-pthread'])
+
+    # Note: 'pthread' is in libc for android.
+    if target_os != 'android':
+        samples_env.AppendUnique(LIBS=['pthread'])
+    samples_env.Append(LINKFLAGS=['-Wl,--no-as-needed'])
+
+if target_os in ['windows', 'msys_nt']:
+    samples_env.PrependUnique(LIBS=['coap', 'ocsrm'])
+else:
+    samples_env.PrependUnique(LIBS=['connectivity_abstraction', 'coap', 'm'])
+
+samples_env.PrependUnique(LIBS=['octbstack'])
+
+if samples_env.get('SECURED') == '1':
+    samples_env.AppendUnique(LIBS=['mbedtls', 'mbedx509', 'mbedcrypto'])
+
+if target_os == 'android':
+    samples_env.AppendUnique(CXXFLAGS=['-frtti', '-fexceptions'])
+    samples_env.AppendUnique(LIBS=['gnustl_shared'])
+    samples_env.AppendUnique(
+        CPPDEFINES=['_GLIBCXX_USE_C99=1', '_GLIBCXX_HAVE_WCSTOF=1'])
+
+    if not samples_env.get('RELEASE'):
+        samples_env.AppendUnique(LIBS=['log'])
+
+if target_os in ['darwin', 'ios']:
+    samples_env.AppendUnique(CPPDEFINES=['_DARWIN_C_SOURCE'])
+
+samples_env.AppendUnique(CPPDEFINES=['TB_LOG'])
+
+samples_env.ParseConfig("pkg-config --cflags --libs glib-2.0")
+samples_env.ParseConfig("pkg-config --cflags --libs luna-service2")
+samples_env.ParseConfig("pkg-config --cflags --libs pbnjson_c")
+
+######################################################################
+# Source files and Targets
+######################################################################
+
+ocserverbasicops = samples_env.Program(
+    'ocserverbasicops', ['../common.cpp', 'ocserverbasicops.cpp'])
+
+ocsamples = [ocserverbasicops]
+Alias("samples", ocsamples)
+samples_env.AppendTarget('samples')
+
+src_dir = samples_env.get('SRC_DIR')
+sec_samples_src_dir = src_dir + '/resource/csdk/stack/samples/linux/secure/'
+sec_samples_build_dir = samples_env.get(
+    'BUILD_DIR') + '/resource/csdk/stack/samples/linux/secure'
+
+samples_env.Alias(
+    "install",
+    samples_env.Install(sec_samples_build_dir,
+                        sec_samples_src_dir + 'oic_svr_db_server.json'))
+
+samples_env.Alias(
+    "install",
+    samples_env.Install(sec_samples_build_dir,
+                        sec_samples_src_dir + 'oic_svr_db_server.dat'))
diff --git a/resource/csdk/stack/samples/webos/secure/ocserverbasicops/logging.h b/resource/csdk/stack/samples/webos/secure/ocserverbasicops/logging.h
new file mode 100644
index 0000000..455b268
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/secure/ocserverbasicops/logging.h
@@ -0,0 +1,69 @@
+/*******************************************************************
+ *
+ * Copyright (c) 2018 LG Electronics, Inc.
+ *
+ *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+ */
+
+#ifndef __LOGGING_H__
+#define __LOGGING_H__
+
+#include <PmLogLib.h>
+
+extern PmLogContext gLogContext;
+
+/* Logging for ocserverbasciops context ********
+ * The parameters needed are
+ * msgid - unique message id
+ * kvcount - count for key-value pairs
+ * ... - key-value pairs and free text. key-value pairs are formed using PMLOGKS or PMLOGKFV
+ * e.g.)
+ * WCALOG_CRITICAL(msgid, 2, PMLOGKS("key1", "value1"), PMLOGKFV("key2", "%d", value2), "free text message");
+ **********************************************/
+#define OCSAMPLE_LOG_CRITICAL(msgid, kvcount, ...) \
+        PmLogCritical(gLogContext, msgid, kvcount, ##__VA_ARGS__)
+
+#define OCSAMPLE_LOG_ERROR(msgid, kvcount, ...) \
+        PmLogError(gLogContext, msgid, kvcount,##__VA_ARGS__)
+
+#define OCSAMPLE_LOG_WARNING(msgid, kvcount, ...) \
+        PmLogWarning(gLogContext, msgid, kvcount, ##__VA_ARGS__)
+
+#define OCSAMPLE_LOG_INFO(msgid, kvcount, ...) \
+        PmLogInfo(gLogContext, msgid, kvcount, ##__VA_ARGS__)
+
+#define OCSAMPLE_LOG_DEBUG(...) \
+        PmLogDebug(gLogContext, ##__VA_ARGS__)
+
+#define OCSAMPLE_LOG_ESCAPED_ERRMSG(msgid, errmsg) \
+    do { \
+    gchar *escaped_errtext = g_strescape(errmsg, NULL); \
+    WCALOG_ERROR(msgid, 1, PMLOGKS("Error", escaped_errtext), ""); \
+    g_free(escaped_errtext); \
+    } while(0)
+
+#define OCSAMPLE_LOG_ADDR_INFOMSG(msgid, name, addr) \
+    do { \
+    gchar straddr[16]; \
+    snprintf(straddr, 16, "%p", addr); \
+    WCALOG_INFO(msgid, 1, PMLOGKS(name, straddr), ""); \
+    } while(0)
+
+/** list of MSGID's */
+#define MSGID_WIFI_SRVC_REGISTER_FAIL                   "WIFI_SRVC_REGISTER_FAIL"
+
+#endif // __LOGGING_H__
diff --git a/resource/csdk/stack/samples/webos/secure/ocserverbasicops/ocserverbasicops.cpp b/resource/csdk/stack/samples/webos/secure/ocserverbasicops/ocserverbasicops.cpp
new file mode 100644
index 0000000..ac3e781
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/secure/ocserverbasicops/ocserverbasicops.cpp
@@ -0,0 +1,451 @@
+/*******************************************************************
+ *
+ * Copyright (c) 2018 LG Electronics, Inc.
+ * Copyright 2014 Intel Mobile Communications GmbH All Rights Reserved.
+ *
+ *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+ */
+
+#include "iotivity_config.h"
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#include <signal.h>
+#ifdef HAVE_PTHREAD_H
+#include <pthread.h>
+#endif
+#include "ocstack.h"
+#include "ocpayload.h"
+#include "ocserverbasicops.h"
+#include "common.h"
+
+
+/// This example is using experimental API, so there is no guarantee of support for future release,
+/// nor any there any guarantee that breaking changes will not occur across releases.
+#include "logger.h"
+
+#include <luna-service2/lunaservice.h>
+#include <glib.h>
+#include <pbnjson.h>
+#include <pthread.h>
+#include "logging.h"
+
+pthread_t threadId_server;
+PmLogContext gLogContext;
+PmLogContext gLogLibContext;
+
+int gQuitFlag = 0;
+
+static LEDResource LED;
+// This variable determines instance number of the LED resource.
+// Used by POST method to create a new instance of LED resource.
+static int gCurrLedInstance = 0;
+#define SAMPLE_MAX_NUM_POST_INSTANCE  2
+static LEDResource gLedInstance[SAMPLE_MAX_NUM_POST_INSTANCE];
+
+char *gResourceUri= (char *)"/a/led";
+
+//Secure Virtual Resource database for Iotivity Server
+//It contains Server's Identity and the PSK credentials
+//of other devices which the server trusts
+static char CRED_FILE[] = "oic_svr_db_server.dat";
+
+static LSHandle *pLsHandle = NULL;
+static GMainLoop *mainloop = NULL;
+
+OCRepPayload* getPayload(const char* uri, int64_t power, bool state)
+{
+    OCRepPayload* payload = OCRepPayloadCreate();
+    if(!payload)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Failed to allocate Payload");
+        return nullptr;
+    }
+
+    OCRepPayloadSetUri(payload, uri);
+    OCRepPayloadSetPropBool(payload, "state", state);
+    OCRepPayloadSetPropInt(payload, "power", power);
+
+    return payload;
+}
+
+//This function takes the request as an input and returns the response
+OCRepPayload* constructResponse (OCEntityHandlerRequest *ehRequest)
+{
+    if(ehRequest->payload && ehRequest->payload->type != PAYLOAD_TYPE_REPRESENTATION)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Incoming payload not a representation");
+        return nullptr;
+    }
+
+    OCRepPayload* input = reinterpret_cast<OCRepPayload*>(ehRequest->payload);
+
+    LEDResource *currLEDResource = &LED;
+
+    if (ehRequest->resource == gLedInstance[0].handle)
+    {
+        currLEDResource = &gLedInstance[0];
+        gResourceUri = (char *) "/a/led/0";
+    }
+    else if (ehRequest->resource == gLedInstance[1].handle)
+    {
+        currLEDResource = &gLedInstance[1];
+        gResourceUri = (char *) "/a/led/1";
+    }
+
+    if(OC_REST_PUT == ehRequest->method
+        || OC_REST_POST == ehRequest->method)
+    {
+        // Get pointer to query
+        int64_t pow;
+        if(OCRepPayloadGetPropInt(input, "power", &pow))
+        {
+            currLEDResource->power = pow;
+        }
+
+        bool state;
+        if(OCRepPayloadGetPropBool(input, "state", &state))
+        {
+            currLEDResource->state = state;
+        }
+    }
+
+    return getPayload(gResourceUri, currLEDResource->power, currLEDResource->state);
+}
+
+OCEntityHandlerResult ProcessGetRequest (OCEntityHandlerRequest *ehRequest,
+        OCRepPayload **payload)
+{
+    OCEntityHandlerResult ehResult;
+
+    OCRepPayload *getResp = constructResponse(ehRequest);
+
+    if(getResp)
+    {
+        *payload = getResp;
+        ehResult = OC_EH_OK;
+    }
+    else
+    {
+        ehResult = OC_EH_ERROR;
+    }
+
+    return ehResult;
+}
+
+OCEntityHandlerResult ProcessPutRequest (OCEntityHandlerRequest *ehRequest,
+        OCRepPayload **payload)
+{
+    OCEntityHandlerResult ehResult;
+
+    OCRepPayload *putResp = constructResponse(ehRequest);
+
+    if(putResp)
+    {
+        *payload = putResp;
+        ehResult = OC_EH_OK;
+    }
+    else
+    {
+        ehResult = OC_EH_ERROR;
+    }
+
+    return ehResult;
+}
+
+OCEntityHandlerResult ProcessPostRequest (OCEntityHandlerRequest *ehRequest,
+        OCEntityHandlerResponse *response, OCRepPayload **payload)
+{
+    OCRepPayload *respPLPost_led = nullptr;
+    OCEntityHandlerResult ehResult = OC_EH_OK;
+
+    /*
+     * The entity handler determines how to process a POST request.
+     * Per the REST paradigm, POST can also be used to update representation of existing
+     * resource or create a new resource.
+     * In the sample below, if the POST is for /a/led then a new instance of the LED
+     * resource is created with default representation (if representation is included in
+     * POST payload it can be used as initial values) as long as the instance is
+     * lesser than max new instance count. Once max instance count is reached, POST on
+     * /a/led updated the representation of /a/led.
+     */
+
+    if (ehRequest->resource == LED.handle)
+    {
+        if (gCurrLedInstance < SAMPLE_MAX_NUM_POST_INSTANCE)
+        {
+            // Create new LED instance
+            char newLedUri[15] = "/a/led/";
+            size_t newLedUriLength = strlen(newLedUri);
+            snprintf((newLedUri + newLedUriLength), (sizeof(newLedUri) - newLedUriLength), "%d", gCurrLedInstance);
+
+            respPLPost_led = OCRepPayloadCreate();
+            OCRepPayloadSetUri(respPLPost_led, gResourceUri);
+            OCRepPayloadSetPropString(respPLPost_led, "createduri", newLedUri);
+
+            if (0 == createLEDResource (newLedUri, &gLedInstance[gCurrLedInstance], false, 0))
+            {
+                OCSAMPLE_LOG_INFO(TAG, 0, "Created new LED instance");
+                gLedInstance[gCurrLedInstance].state = 0;
+                gLedInstance[gCurrLedInstance].power = 0;
+                gCurrLedInstance++;
+                strncpy ((char *)response->resourceUri, newLedUri, MAX_URI_LENGTH);
+                ehResult = OC_EH_RESOURCE_CREATED;
+            }
+        }
+        else
+        {
+            respPLPost_led = constructResponse(ehRequest);
+        }
+    }
+    else
+    {
+        for (int i = 0; i < SAMPLE_MAX_NUM_POST_INSTANCE; i++)
+        {
+            if (ehRequest->resource == gLedInstance[i].handle)
+            {
+                if (i == 0)
+                {
+                    respPLPost_led = constructResponse(ehRequest);
+                    break;
+                }
+                else if (i == 1)
+                {
+                    respPLPost_led = constructResponse(ehRequest);
+                }
+            }
+        }
+    }
+
+    if (respPLPost_led != NULL)
+    {
+        *payload = respPLPost_led;
+        ehResult = OC_EH_OK;
+    }
+    else
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "Payload was NULL");
+        ehResult = OC_EH_ERROR;
+    }
+
+    return ehResult;
+}
+
+OCEntityHandlerResult
+OCEntityHandlerCb (OCEntityHandlerFlag flag,
+        OCEntityHandlerRequest *entityHandlerRequest,
+        void* /*callbackParam*/)
+{
+    OCSAMPLE_LOG_INFO(TAG, 0, "Inside entity handler - flags: 0x%x", flag);
+
+    OCEntityHandlerResult ehResult = OC_EH_ERROR;
+    OCEntityHandlerResponse response = { 0, 0, OC_EH_ERROR, 0, 0, { },{ 0 }, false };
+    // Validate pointer
+    if (!entityHandlerRequest)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Invalid request pointer");
+        return OC_EH_ERROR;
+    }
+
+    OCRepPayload* payload = nullptr;
+
+    if (flag & OC_REQUEST_FLAG)
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "Flag includes OC_REQUEST_FLAG");
+        if (entityHandlerRequest)
+        {
+            if (OC_REST_GET == entityHandlerRequest->method)
+            {
+                OCSAMPLE_LOG_INFO(TAG, 0, "Received OC_REST_GET from client");
+                ehResult = ProcessGetRequest (entityHandlerRequest, &payload);
+            }
+            else if (OC_REST_PUT == entityHandlerRequest->method)
+            {
+                OCSAMPLE_LOG_INFO(TAG, 0, "Received OC_REST_PUT from client");
+                ehResult = ProcessPutRequest (entityHandlerRequest, &payload);
+            }
+            else if (OC_REST_POST == entityHandlerRequest->method)
+            {
+                OCSAMPLE_LOG_INFO(TAG, 0, "Received OC_REST_POST from client");
+                ehResult = ProcessPostRequest (entityHandlerRequest, &response, &payload);
+            }
+            else
+            {
+                OCSAMPLE_LOG_INFO(TAG, 0, "Received unsupported method %d from client",
+                        entityHandlerRequest->method);
+                ehResult = OC_EH_ERROR;
+            }
+
+            if (ehResult == OC_EH_OK && ehResult != OC_EH_FORBIDDEN)
+            {
+                // Format the response.  Note this requires some info about the request
+                response.requestHandle = entityHandlerRequest->requestHandle;
+                response.resourceHandle = entityHandlerRequest->resource;
+                response.ehResult = ehResult;
+                response.payload = reinterpret_cast<OCPayload*>(payload);
+                response.numSendVendorSpecificHeaderOptions = 0;
+                memset(response.sendVendorSpecificHeaderOptions, 0, sizeof response.sendVendorSpecificHeaderOptions);
+                memset(response.resourceUri, 0, sizeof(response.resourceUri));
+                // Indicate that response is NOT in a persistent buffer
+                response.persistentBufferFlag = 0;
+
+                // Send the response
+                if (OCDoResponse(&response) != OC_STACK_OK)
+                {
+                    OCSAMPLE_LOG_ERROR(TAG, 0, "Error sending response");
+                    ehResult = OC_EH_ERROR;
+                }
+            }
+        }
+    }
+
+    OCRepPayloadDestroy(payload);
+    return ehResult;
+}
+
+/* SIGINT handler: set gQuitFlag to 1 for graceful termination */
+void handleSigInt(int signum)
+{
+    if (signum == SIGINT)
+    {
+        gQuitFlag = 1;
+        g_main_loop_quit(mainloop);
+    }
+}
+
+FILE* server_fopen(const char *path, const char *mode)
+{
+    if (0 == strcmp(path, OC_SECURITY_DB_DAT_FILE_NAME))
+    {
+        return fopen(CRED_FILE, mode);
+    }
+    else
+    {
+        return fopen(path, mode);
+    }
+}
+
+static gboolean serverStarter(gpointer user_data)
+{
+    if (!gQuitFlag)
+    {
+        if (OCProcess() != OC_STACK_OK)
+        {
+            OCSAMPLE_LOG_ERROR(TAG, 0, "OCStack process error");
+        }
+        return TRUE;
+    }
+    else
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "Stopping serverStarter loop...");
+        return FALSE;
+    }
+}
+
+int main(int /*argc*/, char* /*argv*/[])
+{
+    struct timespec timeout;
+    LSError lserror;
+    LSErrorInit(&lserror);
+    (void) PmLogGetContext("OCSERVERBASICOPS", &gLogContext);
+    (void) PmLogGetContext("OCSERVERBASICOPS-LIB", &gLogLibContext);
+    PmLogSetLibContext(gLogLibContext);
+
+    mainloop = g_main_loop_new(NULL, FALSE);
+
+    // Initialize g_main_loop
+    if (!mainloop) {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Failed to create main loop");
+        return 0;
+    }
+
+    OCSAMPLE_LOG_INFO(TAG, 0, "OCServer is starting...");
+
+    if (!LSRegister("org.ocf.webossample.ocserverbasicops", &pLsHandle, &lserror)) {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Failed to register LS Handle");
+        LSErrorLog(gLogContext, "LS_SRVC_ERROR", &lserror);
+        return 0;
+    }
+
+    if (!LSGmainAttach(pLsHandle, mainloop, &lserror)) {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Failed to attach main loop: %s", &lserror);
+        LSErrorLog(gLogContext, "LS_SRVC_ATTACH_ERROR", &lserror);
+        return 0;
+    }
+
+    // Initialize Persistent Storage for SVR database
+    OCPersistentStorage ps = { server_fopen, fread, fwrite, fclose, unlink };
+    OCRegisterPersistentStorageHandler(&ps);
+
+    if (OCInit(NULL, 0, OC_SERVER) != OC_STACK_OK)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "OCStack init error");
+        return 0;
+    }
+
+    /*
+     * Declare and create the example resource: LED
+     */
+    createLEDResource(gResourceUri, &LED, false, 0);
+
+    timeout.tv_sec  = 0;
+    timeout.tv_nsec = 100000000L;
+
+    // Break from loop with Ctrl-C
+    OCSAMPLE_LOG_INFO(TAG, 0, "Entering ocserver main loop...");
+    signal(SIGINT, handleSigInt);
+
+    //pthread_create(&threadId_server, NULL, serverStarter, (void *)NULL);
+    OCSAMPLE_LOG_INFO(TAG, 0, "Entering serverStarter main loop...");
+    g_timeout_add_seconds(1, serverStarter, NULL);
+    g_main_loop_run(mainloop);
+
+    OCSAMPLE_LOG_INFO(TAG, 0, "Exiting ocserver main loop...");
+
+    if (OCStop() != OC_STACK_OK)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "OCStack process error");
+        return 0;
+    }
+
+    return 0;
+}
+
+int createLEDResource (char *uri, LEDResource *ledResource, bool resourceState, int64_t resourcePower)
+{
+    if (!uri)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Resource URI cannot be NULL");
+        return -1;
+    }
+
+    ledResource->state = resourceState;
+    ledResource->power= resourcePower;
+    OCStackResult res = OCCreateResource(&(ledResource->handle),
+            "core.led",
+            OC_RSRVD_INTERFACE_DEFAULT,
+            uri,
+            OCEntityHandlerCb,
+            NULL,
+            OC_DISCOVERABLE|OC_OBSERVABLE | OC_SECURE);
+    OCSAMPLE_LOG_INFO(TAG, 0, "Created LED resource with result: %s", getResult(res));
+
+    return 0;
+}
diff --git a/resource/csdk/stack/samples/webos/secure/ocserverbasicops/ocserverbasicops.h b/resource/csdk/stack/samples/webos/secure/ocserverbasicops/ocserverbasicops.h
new file mode 100644
index 0000000..ffcaff3
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/secure/ocserverbasicops/ocserverbasicops.h
@@ -0,0 +1,77 @@
+/*******************************************************************
+ *
+ * Copyright (c) 2018 LG Electronics, Inc.
+ * Copyright 2014 Intel Mobile Communications GmbH All Rights Reserved.
+ *
+ *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+ */
+
+#ifndef OCSERVER_BASICOPS_H_
+#define OCSERVER_BASICOPS_H_
+
+#include "ocstack.h"
+
+//-----------------------------------------------------------------------------
+// Defines
+//-----------------------------------------------------------------------------
+#define TAG "ocserverbasicops"
+
+//-----------------------------------------------------------------------------
+// Typedefs
+//-----------------------------------------------------------------------------
+
+/* Structure to represent a LED resource */
+typedef struct LEDRESOURCE{
+    OCResourceHandle handle;
+    bool state;
+    int64_t power;
+} LEDResource;
+
+//-----------------------------------------------------------------------------
+// Function prototype
+//-----------------------------------------------------------------------------
+
+/* Function that creates a new LED resource by calling the
+ * OCCreateResource() method.
+ */
+int createLEDResource (char *uri, LEDResource *ledResource, bool resourceState, int64_t resourcePower);
+
+/* This method converts the payload to JSON format */
+OCRepPayload* constructResponse (OCEntityHandlerRequest *ehRequest);
+
+/* Following methods process the PUT, GET, POST
+ * requests
+ */
+OCEntityHandlerResult ProcessGetRequest (OCEntityHandlerRequest *ehRequest,
+                                         OCRepPayload **payload);
+OCEntityHandlerResult ProcessPutRequest (OCEntityHandlerRequest *ehRequest,
+                                         OCRepPayload **payload);
+OCEntityHandlerResult ProcessPostRequest (OCEntityHandlerRequest *ehRequest,
+                                        OCEntityHandlerResponse *response,
+                                        OCRepPayload **payload);
+
+//-----------------------------------------------------------------------------
+// Callback functions
+//-----------------------------------------------------------------------------
+
+/* Entity Handler callback functions */
+
+OCEntityHandlerResult
+OCEntityHandlerCb (OCEntityHandlerFlag flag,
+        OCEntityHandlerRequest *entityHandlerRequest);
+
+#endif
diff --git a/resource/csdk/stack/samples/webos/secure/ocserverbasicops/oic_svr_db_server.json b/resource/csdk/stack/samples/webos/secure/ocserverbasicops/oic_svr_db_server.json
new file mode 100644
index 0000000..3a8ea10
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/secure/ocserverbasicops/oic_svr_db_server.json
@@ -0,0 +1,90 @@
+{
+    "acl": {
+        "aclist2": [
+            {
+                "aceid": 1,
+                "subject": { "conntype": "anon-clear" },
+                "resources": [
+                    { "href": "/oic/res" },
+                    { "href": "/oic/d" },
+                    { "href": "/oic/p" },
+                    { "href": "/oic/sec/doxm" }
+                ],
+                "permission": 2
+            },
+            {
+                "aceid": 2,
+                "subject": { "conntype": "auth-crypt" },
+                "resources": [
+                    { "href": "/oic/res" },
+                    { "href": "/oic/d" },
+                    { "href": "/oic/p" },
+                    { "href": "/oic/sec/doxm" }
+                ],
+                "permission": 2
+            },
+            {
+                "aceid": 3,
+                "subject": { "uuid": "32323232-3232-3232-3232-323232323232" },
+                "resources": [{ "wc": "*" }],
+                "permission": 7
+            },
+            {
+                "aceid": 4,
+                "subject": { "uuid": "31393139-3139-3139-3139-313931393139" },
+                "resources": [{ "href": "/a/led" }],
+                "permission": 7
+            },
+            {
+                "aceid": 5,
+                "subject": { "uuid": "37373737-3737-3737-3737-373737373737" },
+                "resources": [{ "href": "/a/led" }],
+                "permission": 6
+            }
+        ],
+        "rowneruuid" : "31313131-3131-3131-3131-313131313131"
+    },
+    "pstat": {
+        "dos": {"s": 3, "p": false},
+        "isop": true,
+        "rowneruuid": "31313131-3131-3131-3131-313131313131",
+        "cm": 0,
+        "tm": 0,
+        "om": 4,
+        "sm": 4
+        },
+    "doxm": {
+        "oxms": [0],
+        "oxmsel": 0,
+        "sct": 9,
+        "owned": true,
+        "deviceuuid": "31313131-3131-3131-3131-313131313131",
+        "devowneruuid": "32323232-3232-3232-3232-323232323232",
+        "rowneruuid": "31313131-3131-3131-3131-313131313131"
+    },
+    "cred": {
+        "creds": [
+            {
+                "credid": 1,
+                "subjectuuid": "32323232-3232-3232-3232-323232323232",
+                "credtype": 1,
+                "period": "20150630T060000/20990920T220000",
+                "privatedata": {
+                    "data": "AAAAAAAAAAAAAAAA",
+                    "encoding": "oic.sec.encoding.raw"
+                }
+            },
+            {
+                "credid": 2,
+                "subjectuuid": "31393139-3139-3139-3139-313931393139",
+                "credtype": 1,
+                "period": "20150630T060000/20990920T220000",
+                "privatedata": {
+                    "data": "BBBBBBBBBBBBBBBB",
+                    "encoding": "oic.sec.encoding.raw"
+                }
+            }
+        ],
+        "rowneruuid": "32323232-3232-3232-3232-323232323232"
+    }
+}
diff --git a/resource/csdk/stack/samples/webos/unsecure/SConscript b/resource/csdk/stack/samples/webos/unsecure/SConscript
new file mode 100644
index 0000000..b1bb8de
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/unsecure/SConscript
@@ -0,0 +1,24 @@
+#******************************************************************
+#
+# Copyright (c) 2018 LG Electronics, Inc.
+#
+#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+Import('stacksamples_env')
+
+SConscript('ocserver/SConscript', 'stacksamples_env')
+SConscript('occlient/SConscript', 'stacksamples_env')
diff --git a/resource/csdk/stack/samples/webos/unsecure/common.cpp b/resource/csdk/stack/samples/webos/unsecure/common.cpp
new file mode 100644
index 0000000..dbb4e23
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/unsecure/common.cpp
@@ -0,0 +1,99 @@
+/*******************************************************************
+ *
+ * Copyright (c) 2018 LG Electronics, Inc.
+ * Copyright 2014 Intel Mobile Communications GmbH All Rights Reserved.
+ *
+ *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <ocstack.h>
+#include <getopt.h>
+
+const char *getResult(OCStackResult result)
+{
+    switch (result)
+    {
+        case OC_STACK_OK:
+            return "OC_STACK_OK";
+        case OC_STACK_RESOURCE_CREATED:
+            return "OC_STACK_RESOURCE_CREATED";
+        case OC_STACK_RESOURCE_DELETED:
+            return "OC_STACK_RESOURCE_DELETED";
+        case OC_STACK_RESOURCE_CHANGED:
+            return "OC_STACK_RESOURCE_CHANGED";
+        case OC_STACK_INVALID_URI:
+            return "OC_STACK_INVALID_URI";
+        case OC_STACK_INVALID_QUERY:
+            return "OC_STACK_INVALID_QUERY";
+        case OC_STACK_INVALID_IP:
+            return "OC_STACK_INVALID_IP";
+        case OC_STACK_INVALID_PORT:
+            return "OC_STACK_INVALID_PORT";
+        case OC_STACK_INVALID_CALLBACK:
+            return "OC_STACK_INVALID_CALLBACK";
+        case OC_STACK_INVALID_METHOD:
+            return "OC_STACK_INVALID_METHOD";
+        case OC_STACK_NO_MEMORY:
+            return "OC_STACK_NO_MEMORY";
+        case OC_STACK_COMM_ERROR:
+            return "OC_STACK_COMM_ERROR";
+        case OC_STACK_INVALID_PARAM:
+            return "OC_STACK_INVALID_PARAM";
+        case OC_STACK_NOTIMPL:
+            return "OC_STACK_NOTIMPL";
+        case OC_STACK_NO_RESOURCE:
+            return "OC_STACK_NO_RESOURCE";
+        case OC_STACK_RESOURCE_ERROR:
+            return "OC_STACK_RESOURCE_ERROR";
+        case OC_STACK_SLOW_RESOURCE:
+            return "OC_STACK_SLOW_RESOURCE";
+        case OC_STACK_NO_OBSERVERS:
+            return "OC_STACK_NO_OBSERVERS";
+        case OC_STACK_UNAUTHORIZED_REQ:
+            return "OC_STACK_UNAUTHORIZED_REQ";
+        case OC_STACK_NOT_ACCEPTABLE:
+            return "OC_STACK_NOT_ACCEPTABLE";
+#ifdef WITH_PRESENCE
+        case OC_STACK_PRESENCE_STOPPED:
+            return "OC_STACK_PRESENCE_STOPPED";
+        case OC_STACK_PRESENCE_TIMEOUT:
+            return "OC_STACK_PRESENCE_TIMEOUT";
+#endif
+        case OC_STACK_ERROR:
+            return "OC_STACK_ERROR";
+        default:
+            return "UNKNOWN";
+    }
+}
+
+void StripNewLineChar(char* str)
+{
+    int i = 0;
+    if (str)
+    {
+        while( str[i])
+        {
+            if (str[i] == '\n')
+            {
+                str[i] = '\0';
+            }
+            i++;
+        }
+    }
+}
+
diff --git a/resource/csdk/stack/samples/webos/unsecure/common.h b/resource/csdk/stack/samples/webos/unsecure/common.h
new file mode 100644
index 0000000..db5453a
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/unsecure/common.h
@@ -0,0 +1,29 @@
+/*******************************************************************
+ *
+ * Copyright (c) 2018 LG Electronics, Inc.
+ * Copyright 2014 Intel Mobile Communications GmbH All Rights Reserved.
+ *
+ *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+ */
+
+#ifndef COMMON_H_
+#define COMMON_H_
+
+const char *getResult(OCStackResult result);
+void StripNewLineChar(char* str);
+
+#endif
diff --git a/resource/csdk/stack/samples/webos/unsecure/device_properties.json b/resource/csdk/stack/samples/webos/unsecure/device_properties.json
new file mode 100644
index 0000000..bc68caf
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/unsecure/device_properties.json
@@ -0,0 +1,5 @@
+{
+    "DeviceProperties": {
+        "piid": "a127ec9c-b1af-430e-ad6f-8e069a7cae3b"
+    }
+}
diff --git a/resource/csdk/stack/samples/webos/unsecure/files/sysbus/occlient.api.json b/resource/csdk/stack/samples/webos/unsecure/files/sysbus/occlient.api.json
new file mode 100644
index 0000000..2c63c08
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/unsecure/files/sysbus/occlient.api.json
@@ -0,0 +1,2 @@
+{
+}
diff --git a/resource/csdk/stack/samples/webos/unsecure/files/sysbus/occlient.manifest.json b/resource/csdk/stack/samples/webos/unsecure/files/sysbus/occlient.manifest.json
new file mode 100644
index 0000000..3b0c064
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/unsecure/files/sysbus/occlient.manifest.json
@@ -0,0 +1,16 @@
+{
+    "serviceFiles": [
+        "/usr/share/luna-service2/services.d/occlient.service"
+    ],
+    "roleFiles": [
+        "/usr/share/luna-service2/roles.d/occlient.role.json"
+    ],
+    "apiPermissionFiles": [
+        "/usr/share/luna-service2/api-permissions.d/occlient.api.json"
+    ],
+    "version": "1.0.0",
+    "id": "occlient",
+    "clientPermissionFiles": [
+        "/usr/share/luna-service2/client-permissions.d/occlient.perm.json"
+    ]
+}
diff --git a/resource/csdk/stack/samples/webos/unsecure/files/sysbus/occlient.perm.json b/resource/csdk/stack/samples/webos/unsecure/files/sysbus/occlient.perm.json
new file mode 100644
index 0000000..2b5bc4d
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/unsecure/files/sysbus/occlient.perm.json
@@ -0,0 +1,5 @@
+{
+    "org.ocf.webossample.occlient*": [
+        "networking.internal"
+    ]
+}
diff --git a/resource/csdk/stack/samples/webos/unsecure/files/sysbus/occlient.role.json b/resource/csdk/stack/samples/webos/unsecure/files/sysbus/occlient.role.json
new file mode 100644
index 0000000..93f6d9d
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/unsecure/files/sysbus/occlient.role.json
@@ -0,0 +1,11 @@
+{
+    "exeName":"/usr/palm/services/org.ocf.webossample.occlient/occlient",
+    "type":"regular",
+    "allowedNames":["org.ocf.webossample.occlient*"],
+    "permissions": [
+        {
+            "service":"org.ocf.webossample.occlient*",
+            "outbound":["com.webos.service.connectionmanager"]
+        }
+    ]
+}
diff --git a/resource/csdk/stack/samples/webos/unsecure/files/sysbus/occlient.service b/resource/csdk/stack/samples/webos/unsecure/files/sysbus/occlient.service
new file mode 100644
index 0000000..26848b4
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/unsecure/files/sysbus/occlient.service
@@ -0,0 +1,24 @@
+#******************************************************************
+#
+# Copyright (c) 2018 LG Electronics, Inc.
+#
+#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+[D-BUS Service]
+Name=org.ocf.webossample.occlient*
+Exec=/usr/palm/services/org.ocf.webossample.occlient/occlient
+Type=static
diff --git a/resource/csdk/stack/samples/webos/unsecure/files/sysbus/ocserver.api.json b/resource/csdk/stack/samples/webos/unsecure/files/sysbus/ocserver.api.json
new file mode 100644
index 0000000..2c63c08
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/unsecure/files/sysbus/ocserver.api.json
@@ -0,0 +1,2 @@
+{
+}
diff --git a/resource/csdk/stack/samples/webos/unsecure/files/sysbus/ocserver.manifest.json b/resource/csdk/stack/samples/webos/unsecure/files/sysbus/ocserver.manifest.json
new file mode 100644
index 0000000..907308a
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/unsecure/files/sysbus/ocserver.manifest.json
@@ -0,0 +1,16 @@
+{
+    "serviceFiles": [
+        "/usr/share/luna-service2/services.d/ocserver.service"
+    ],
+    "roleFiles": [
+        "/usr/share/luna-service2/roles.d/ocserver.role.json"
+    ],
+    "apiPermissionFiles": [
+        "/usr/share/luna-service2/api-permissions.d/ocserver.api.json"
+    ],
+    "version": "1.0.0",
+    "id": "ocserver",
+    "clientPermissionFiles": [
+        "/usr/share/luna-service2/client-permissions.d/ocserver.perm.json"
+    ]
+}
diff --git a/resource/csdk/stack/samples/webos/unsecure/files/sysbus/ocserver.perm.json b/resource/csdk/stack/samples/webos/unsecure/files/sysbus/ocserver.perm.json
new file mode 100644
index 0000000..dba4b8b
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/unsecure/files/sysbus/ocserver.perm.json
@@ -0,0 +1,5 @@
+{
+    "org.ocf.webossample.ocserver*": [
+        "networking.internal"
+    ]
+}
diff --git a/resource/csdk/stack/samples/webos/unsecure/files/sysbus/ocserver.role.json b/resource/csdk/stack/samples/webos/unsecure/files/sysbus/ocserver.role.json
new file mode 100644
index 0000000..9dbb449
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/unsecure/files/sysbus/ocserver.role.json
@@ -0,0 +1,11 @@
+{
+    "exeName":"/usr/palm/services/org.ocf.webossample.ocserver/ocserver",
+    "type":"regular",
+    "allowedNames":["org.ocf.webossample.ocserver*"],
+    "permissions": [
+        {
+            "service":"org.ocf.webossample.ocserver*",
+            "outbound":["com.webos.service.connectionmanager"]
+        }
+    ]
+}
diff --git a/resource/csdk/stack/samples/webos/unsecure/files/sysbus/ocserver.service b/resource/csdk/stack/samples/webos/unsecure/files/sysbus/ocserver.service
new file mode 100644
index 0000000..5f40950
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/unsecure/files/sysbus/ocserver.service
@@ -0,0 +1,24 @@
+#******************************************************************
+#
+# Copyright (c) 2018 LG Electronics, Inc.
+#
+#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+[D-BUS Service]
+Name=org.ocf.webossample.ocserver*
+Exec=/usr/palm/services/org.ocf.webossample.ocserver/ocserver
+Type=static
diff --git a/resource/csdk/stack/samples/webos/unsecure/introspection.json b/resource/csdk/stack/samples/webos/unsecure/introspection.json
new file mode 100644
index 0000000..baab37f
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/unsecure/introspection.json
@@ -0,0 +1,272 @@
+{
+    "swagger": "2.0",
+    "info": {
+      "title": "my_example_device",
+      "version": "my device version"
+    },
+
+
+    "schemes": [
+        "http"
+    ],
+    "consumes": [
+        "application/json"
+    ],
+    "produces": [
+        "application/json"
+    ],
+    "paths": {
+       "/switch": {
+
+          "get": {
+
+
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline" ],
+
+                 "type": "string"
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                  "schema" :
+                  {
+                    "$ref": "#/definitions/BinarySwitch"
+                  }
+               }
+            }
+
+           },
+
+          "post": {
+
+
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline" ],
+
+                 "type": "string"
+                }
+                 ,{
+                  "name": "body",
+                  "in": "body",
+                  "required": false,
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/BinarySwitch"
+                  }
+
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/BinarySwitch"
+                  }
+
+               }
+            }
+          }
+        },
+       "/brightness": {
+
+          "get": {
+
+
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline" ],
+
+                 "type": "string"
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                 "schema" :
+                  {
+                    "$ref": "#/definitions/Brightness"
+                  }
+               }
+            }
+
+           },
+
+          "post": {
+
+
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline" ],
+
+                 "type": "string"
+                }
+                 ,{
+                  "name": "body",
+                  "in": "body",
+                  "required": false,
+                 "schema" :
+                  {
+                    "$ref": "#/definitions/Brightness"
+                  }
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                 "schema" :
+                  {
+                    "$ref": "#/definitions/Brightness"
+                  }
+
+               }
+            }
+
+          }
+        }
+    },
+    "definitions":
+    {
+        "BinarySwitch": {
+           "type": "object",
+           "required": [
+             "id"
+           ],
+           "properties":  {
+               "value": {
+                  "type": "boolean",
+                  "description": "Status of the switch"
+                },
+                "rt": {
+                "type": "array",
+                "items" : [
+                  {
+                    "type" : "string",
+                    "maxLength": 64
+                  }
+                ],
+                "minItems" : 1,
+                "description": "Resource Type",
+                "readOnly" : true,
+                "default" : [ "oic.r.switch.binary" ]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.a"
+                        ]
+                    }
+                },
+                "p": {
+                    "type": "integer",
+                    "description": "Bitmap indicating observable and discoverable",
+                    "readOnly" : true
+                },
+                "n": {
+                    "type": "string",
+                    "description": "Friendly name of the resource",
+                    "readOnly" : true
+                },
+                "id": {
+                    "type": "string",
+                    "description": "Instance ID of this specific resource",
+                    "readOnly" : true
+                },
+                "range": {
+                    "type": "array",
+                    "description": "The valid range for the value Property",
+                    "readOnly" : true,
+                    "minItems": 2,
+                    "maxItems": 2,
+                    "items": {
+                        "type": "number"
+                    }
+                }
+            }
+        },
+        "Brightness": {
+           "type": "object",
+           "required": [
+             "id"
+           ],
+           "properties":  {
+               "brighness": {
+                  "type": "integer",
+                  "description": "Current sensed or set value for Brightness"
+                },
+                "rt": {
+                "type": "array",
+                "items" : [
+                  {
+                    "type" : "string",
+                    "maxLength": 64
+                  }
+                ],
+                "minItems" : 1,
+                "description": "Resource Type",
+                "readOnly" : true,
+                "default" : [ "oic.r.light.brightness" ]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.a"
+                        ]
+                    }
+                },
+                "p": {
+                    "type": "integer",
+                    "description": "Bitmap indicating observable and discoverable",
+                    "readOnly" : true
+                },
+                "n": {
+                    "type": "string",
+                    "description": "Friendly name of the resource",
+                    "readOnly" : true
+                },
+                "id": {
+                    "type": "string",
+                    "description": "Instance ID of this specific resource",
+                    "readOnly" : true
+                },
+                "range": {
+                    "type": "array",
+                    "description": "The valid range for the value Property",
+                    "readOnly" : true,
+                    "minItems": 2,
+                    "maxItems": 2,
+                    "items": {
+                        "type": "number"
+                    }
+                }
+            }
+        }
+    }
+
+}
diff --git a/resource/csdk/stack/samples/webos/unsecure/occlient/SConscript b/resource/csdk/stack/samples/webos/unsecure/occlient/SConscript
new file mode 100644
index 0000000..7d0bb7c
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/unsecure/occlient/SConscript
@@ -0,0 +1,90 @@
+#******************************************************************
+#
+# Copyright (c) 2018 LG Electronics, Inc.
+# Copyright 2014 Intel Mobile Communications GmbH All Rights Reserved.
+#
+#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+Import('stacksamples_env')
+
+samples_env = stacksamples_env.Clone()
+SConscript('#build_common/thread.scons', exports={'thread_env': samples_env})
+
+target_os = samples_env.get('TARGET_OS')
+with_ra = samples_env.get('WITH_RA')
+
+######################################################################
+# Build flags
+######################################################################
+with_upstream_libcoap = samples_env.get('WITH_UPSTREAM_LIBCOAP')
+if with_upstream_libcoap == '1':
+    samples_env.AppendUnique(CPPPATH=['#/extlibs/libcoap/libcoap/include'])
+else:
+    samples_env.AppendUnique(CPPPATH=['#/resource/csdk/connectivity/lib/libcoap-4.1.1/include'])
+
+samples_env.PrependUnique(CPPPATH=[
+    '../../../../../logger/include',
+    '../../../../../include',
+    '../../../../../stack/include',
+    '../../../../../connectivity/api',
+    '../../../../../security/include',
+    '../../../../../../../extlibs/boost/boost',
+    '../../../../../../oc_logger/include',
+    '../'
+])
+
+compiler = samples_env.get('CXX')
+if 'g++' in compiler:
+    samples_env.AppendUnique(CXXFLAGS=['-std=c++0x', '-Wall'])
+
+samples_env.PrependUnique(LIBS=['coap'])
+
+if target_os not in ['msys_nt', 'windows']:
+    samples_env.PrependUnique(LIBS=['connectivity_abstraction'])
+
+samples_env.PrependUnique(LIBS=['octbstack', 'ocsrm'])
+
+if target_os in ['darwin']:
+    samples_env.AppendUnique(LIBS=['routingmanager'])
+
+if target_os not in ['windows', 'darwin', 'ios', 'msys_nt']:
+    samples_env.AppendUnique(LIBS=['rt'])
+
+if target_os not in ['windows']:
+    samples_env.PrependUnique(LIBS=['m'])
+
+if samples_env.get('SECURED') == '1':
+    samples_env.AppendUnique(LIBS=['mbedtls'])
+
+samples_env.AppendUnique(CPPDEFINES=['TB_LOG'])
+
+samples_env.ParseConfig("pkg-config --cflags --libs glib-2.0")
+samples_env.ParseConfig("pkg-config --cflags --libs luna-service2")
+samples_env.ParseConfig("pkg-config --cflags --libs pbnjson_c")
+
+######################################################################
+# Source files and Targets
+######################################################################
+occlient = samples_env.Program('occlient', ['occlient.cpp', '../common.cpp'])
+
+list_of_samples = [
+    occlient
+]
+
+Alias("samples", list_of_samples)
+
+samples_env.AppendTarget('samples')
diff --git a/resource/csdk/stack/samples/webos/unsecure/occlient/logging.h b/resource/csdk/stack/samples/webos/unsecure/occlient/logging.h
new file mode 100644
index 0000000..455b268
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/unsecure/occlient/logging.h
@@ -0,0 +1,69 @@
+/*******************************************************************
+ *
+ * Copyright (c) 2018 LG Electronics, Inc.
+ *
+ *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+ */
+
+#ifndef __LOGGING_H__
+#define __LOGGING_H__
+
+#include <PmLogLib.h>
+
+extern PmLogContext gLogContext;
+
+/* Logging for ocserverbasciops context ********
+ * The parameters needed are
+ * msgid - unique message id
+ * kvcount - count for key-value pairs
+ * ... - key-value pairs and free text. key-value pairs are formed using PMLOGKS or PMLOGKFV
+ * e.g.)
+ * WCALOG_CRITICAL(msgid, 2, PMLOGKS("key1", "value1"), PMLOGKFV("key2", "%d", value2), "free text message");
+ **********************************************/
+#define OCSAMPLE_LOG_CRITICAL(msgid, kvcount, ...) \
+        PmLogCritical(gLogContext, msgid, kvcount, ##__VA_ARGS__)
+
+#define OCSAMPLE_LOG_ERROR(msgid, kvcount, ...) \
+        PmLogError(gLogContext, msgid, kvcount,##__VA_ARGS__)
+
+#define OCSAMPLE_LOG_WARNING(msgid, kvcount, ...) \
+        PmLogWarning(gLogContext, msgid, kvcount, ##__VA_ARGS__)
+
+#define OCSAMPLE_LOG_INFO(msgid, kvcount, ...) \
+        PmLogInfo(gLogContext, msgid, kvcount, ##__VA_ARGS__)
+
+#define OCSAMPLE_LOG_DEBUG(...) \
+        PmLogDebug(gLogContext, ##__VA_ARGS__)
+
+#define OCSAMPLE_LOG_ESCAPED_ERRMSG(msgid, errmsg) \
+    do { \
+    gchar *escaped_errtext = g_strescape(errmsg, NULL); \
+    WCALOG_ERROR(msgid, 1, PMLOGKS("Error", escaped_errtext), ""); \
+    g_free(escaped_errtext); \
+    } while(0)
+
+#define OCSAMPLE_LOG_ADDR_INFOMSG(msgid, name, addr) \
+    do { \
+    gchar straddr[16]; \
+    snprintf(straddr, 16, "%p", addr); \
+    WCALOG_INFO(msgid, 1, PMLOGKS(name, straddr), ""); \
+    } while(0)
+
+/** list of MSGID's */
+#define MSGID_WIFI_SRVC_REGISTER_FAIL                   "WIFI_SRVC_REGISTER_FAIL"
+
+#endif // __LOGGING_H__
diff --git a/resource/csdk/stack/samples/webos/unsecure/occlient/occlient.cpp b/resource/csdk/stack/samples/webos/unsecure/occlient/occlient.cpp
new file mode 100644
index 0000000..697e0b9
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/unsecure/occlient/occlient.cpp
@@ -0,0 +1,1415 @@
+/*******************************************************************
+ *
+ * Copyright (c) 2018 LG Electronics, Inc.
+ * Copyright 2014 Intel Mobile Communications GmbH All Rights Reserved.
+ *
+ *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+ */
+
+// Warning disabled globally but VS2013 ignores the /wd4200 option in C++ files.
+#if defined(_MSC_VER) && _MSC_VER < 1900
+#pragma warning(disable : 4200)
+#endif
+
+#include "iotivity_config.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <signal.h>
+#include "ocstack.h"
+#include "ocpayload.h"
+#include "pinoxmcommon.h"
+#include "cacommon.h"
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#include <iostream>
+#include <sstream>
+#include <getopt.h>
+#include <coap/pdu.h>
+#include "occlient.h"
+#include "common.h"
+#include "logger.h"
+#include "sample_payload_logging.h"
+
+#include <luna-service2/lunaservice.h>
+#include <pbnjson.h>
+#include "logging.h"
+
+pthread_t threadId_client = NULL;
+static LSHandle *pLsHandle = NULL;
+static GMainLoop *mainloop = NULL;
+
+PmLogContext gLogContext;
+PmLogContext occlientLibLogContext;
+
+#define VERIFY_SUCCESS(op)                          \
+do                                                  \
+{                                                   \
+    if (op != OC_STACK_OK)                          \
+    {                                               \
+        OCSAMPLE_LOG_CRITICAL(TAG, 0, "%s failed!!", #op);  \
+        goto exit;                                  \
+    }                                               \
+} while(0)
+
+#ifdef ROUTING_GATEWAY
+/**
+ * Maximum number of gateway requests to form the routing table.
+ */
+#define MAX_NUM_GATEWAY_REQUEST 20
+
+/**
+ * Sleep duration after every OCProcess().
+ */
+#define SLEEP_DURATION 100000
+#endif
+// Tracking user input
+static int UnicastDiscovery = 0;
+static int TestCase = 0;
+static int Connectivity = 0;
+static int Introspection = 0;
+static int OCFSpecVersion = 1;
+
+static const char *DEVICE_DISCOVERY_QUERY = "%s/oic/d";
+static const char *PLATFORM_DISCOVERY_QUERY = "%s/oic/p";
+static const char *RESOURCE_DISCOVERY_QUERY = "%s/oic/res";
+
+// Device information
+static const char* gDeviceName = "OCClient";
+static const char* gSpecVersion = "ocf.1.1.0";
+static const char* gDataModelVersions = "ocf.res.1.1.0,ocf.sh.1.1.0";
+static const char* gProtocolIndependentID = "31B59DA2-E68F-4A47-81C5-93E5CBF37D0B";
+
+// Platform information
+static const char* gDateOfManufacture = "2016-01-15";
+static const char* gFirmwareVersion = "myFirmwareVersion";
+static const char* gManufacturerName = "myName";
+static const char* gOperatingSystemVersion = "myOS";
+static const char* gHardwareVersion = "myHardwareVersion";
+static const char* gPlatformID = "6A47983C-CA70-4397-8280-5C34EF23B63B";
+static const char* gManufacturerUrl = "https://www.iotivity.org";
+static const char* gModelNumber = "myModelNumber";
+static const char* gPlatformVersion = "myPlatformVersion";
+static const char* gSupportUrl = "https://www.iotivity.org";
+static const char* gSystemTime = "2015-05-15T11.04";
+
+//The following variable determines the interface protocol (IPv4, IPv6, etc)
+//to be used for sending unicast messages. Default set to IP dual stack.
+static OCConnectivityType ConnType = CT_ADAPTER_IP;
+static OCDevAddr serverAddr;
+static char discoveryAddr[100];
+static std::string coapServerResource = "/a/light";
+static std::string introspectionResType = "oic.wk.introspection";
+
+int InitIntrospectionPayload(OCClientResponse * clientResponse);
+
+#ifdef WITH_PRESENCE
+// The handle for observe registration
+OCDoHandle gPresenceHandle;
+#endif
+// After this crosses a threshold client deregisters for further notifications
+int gNumObserveNotifies = 0;
+
+#ifdef WITH_PRESENCE
+int gNumPresenceNotifies = 0;
+#endif
+
+int gQuitFlag = 0;
+/* SIGINT handler: set gQuitFlag to 1 for graceful termination */
+void handleSigInt(int signum)
+{
+    if (signum == SIGINT)
+    {
+        gQuitFlag = 1;
+        g_main_loop_quit(mainloop);
+    }
+}
+
+OCPayload* createPayload()
+{
+    OCRepPayload* payload = OCRepPayloadCreate();
+
+    if (!payload)
+    {
+        std::cout << "Failed to create payload object"<<std::endl;
+        std::exit(1);
+    }
+
+    OCRepPayloadSetPropInt(payload, "power", 15);
+    OCRepPayloadSetPropBool(payload, "state", true);
+
+    return (OCPayload*) payload;
+}
+
+static void PrintUsage()
+{
+    printf("Usage : occlient -u <0|1> -t <1..24> -c <0|1> -i <0|1> -s <0|1>\n");
+    printf("-u <0|1> : Perform multicast/unicast discovery of resources\n");
+    printf("-c 0 : Use Default connectivity(IP)\n");
+    printf("-c 1 : IP Connectivity Type\n");
+    printf("-t 1  :  Discover Resources\n");
+    printf("-t 2  :  Discover Resources and Initiate Nonconfirmable Get Request\n");
+    printf("-t 3  :  Discover Resources and Initiate Nonconfirmable Get Request"
+            " with query filter.\n");
+    printf("-t 4  :  Discover Resources and Initiate Nonconfirmable Put Requests\n");
+    printf("-t 5  :  Discover Resources and Initiate Nonconfirmable Post Requests\n");
+    printf("-t 6  :  Discover Resources and Initiate Nonconfirmable Delete Requests\n");
+    printf("-t 7  :  Discover Resources and Initiate Nonconfirmable Observe Requests\n");
+    printf("-t 8  :  Discover Resources and Initiate Nonconfirmable Get Request "\
+            "for a resource which is unavailable\n");
+    printf("-t 9  :  Discover Resources and Initiate Confirmable Get Request\n");
+    printf("-t 10 :  Discover Resources and Initiate Confirmable Post Request\n");
+    printf("-t 11 :  Discover Resources and Initiate Confirmable Delete Requests\n");
+    printf("-t 12 :  Discover Resources and Initiate Confirmable Observe Requests"\
+            " and cancel with Low QoS\n");
+
+#ifdef WITH_PRESENCE
+    printf("-t 13 :  Discover Resources and Initiate Nonconfirmable presence\n");
+    printf("-t 14 :  Discover Resources and Initiate Nonconfirmable presence with "\
+            "filter\n");
+    printf("-t 15 :  Discover Resources and Initiate Nonconfirmable presence with "\
+            "2 filters\n");
+    printf("-t 16 :  Discover Resources and Initiate Nonconfirmable multicast presence.\n");
+#endif
+
+    printf("-t 17 :  Discover Resources and Initiate Nonconfirmable Observe Requests "\
+            "then cancel immediately with High QOS\n");
+    printf("-t 18 :  Discover Resources and Initiate Nonconfirmable Get Request and "\
+            "add vendor specific header options\n");
+    printf("-t 19 :  Discover Platform\n");
+    printf("-t 20 :  Discover Devices\n");
+    printf("-t 21 :  Discover Resources and Display endpoints of the server information\n");
+    printf("-t 22 :  Discover Resources and Perform Get Requests by IPv4 + COAP + UDP "\
+            "using server's endpoints information\n");
+    printf("-t 23 :  Discover Resources and Perform Get Requests by IPv4 + COAP + TCP "\
+            "using server's endpoints information\n");
+    printf("-t 24 :  Discover Introspection Resources and Perform Get Request\n");
+    printf("-s 0 :  Specify the device spec version as core.0.0.0\n");
+    printf("-s 1 :  Specify the device spec version as ocf.1.1.0\n");
+}
+
+OCStackResult InvokeOCDoResource(std::ostringstream &query,
+                                 OCDevAddr *remoteAddr,
+                                 OCMethod method,
+                                 OCQualityOfService qos,
+                                 OCClientResponseHandler cb,
+                                 OCHeaderOption * options,
+                                 uint8_t numOptions)
+{
+    OCStackResult ret;
+    OCCallbackData cbData;
+    OCDoHandle handle;
+
+    cbData.cb = cb;
+    cbData.context = (void*)DEFAULT_CONTEXT_VALUE;
+    cbData.cd = NULL;
+
+    OCPayload* payload = (method == OC_REST_PUT || method == OC_REST_POST) ? createPayload() : NULL;
+
+    ret = OCDoRequest(&handle, method, query.str().c_str(), remoteAddr,
+                      payload, (ConnType), qos, &cbData, options, numOptions);
+
+    OCPayloadDestroy(payload);
+
+    if (ret != OC_STACK_OK)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "OCDoResource returns error %d with method %d", ret, method);
+    }
+#ifdef WITH_PRESENCE
+    else if (method == OC_REST_PRESENCE)
+    {
+        gPresenceHandle = handle;
+    }
+#endif
+
+    return ret;
+}
+
+OCStackApplicationResult putReqCB(void* ctx, OCDoHandle /*handle*/,
+                                  OCClientResponse * clientResponse)
+{
+    if (ctx == (void*)DEFAULT_CONTEXT_VALUE)
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "Callback Context for PUT recvd successfully");
+    }
+
+    if (clientResponse)
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "StackResult: %s",  getResult(clientResponse->result));
+        OCSAMPLE_LOG_PAYLOAD(INFO, clientResponse->payload);
+        OCSAMPLE_LOG_INFO(TAG, 0, ("=============> Put Response"));
+    }
+    else
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "putReqCB received Null clientResponse");
+    }
+    return OC_STACK_DELETE_TRANSACTION;
+}
+
+OCStackApplicationResult postReqCB(void *ctx, OCDoHandle /*handle*/,
+                                   OCClientResponse *clientResponse)
+{
+    if (ctx == (void*)DEFAULT_CONTEXT_VALUE)
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "Callback Context for POST recvd successfully");
+    }
+
+    if (clientResponse)
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "StackResult: %s",  getResult(clientResponse->result));
+        OCSAMPLE_LOG_PAYLOAD(INFO, clientResponse->payload);
+        OCSAMPLE_LOG_INFO(TAG, 0, ("=============> Post Response"));
+    }
+    else
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "postReqCB received Null clientResponse");
+    }
+    return OC_STACK_DELETE_TRANSACTION;
+}
+
+OCStackApplicationResult deleteReqCB(void *ctx,
+                                     OCDoHandle /*handle*/,
+                                     OCClientResponse *clientResponse)
+{
+    if (ctx == (void*)DEFAULT_CONTEXT_VALUE)
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "Callback Context for DELETE recvd successfully");
+    }
+
+    if (clientResponse)
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "StackResult: %s",  getResult(clientResponse->result));
+        OCSAMPLE_LOG_PAYLOAD(INFO, clientResponse->payload);
+        OCSAMPLE_LOG_INFO(TAG, 0, ("=============> Delete Response"));
+    }
+    else
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "deleteReqCB received Null clientResponse");
+    }
+    return OC_STACK_DELETE_TRANSACTION;
+}
+
+OCStackApplicationResult getReqCB(void* ctx, OCDoHandle /*handle*/,
+                                  OCClientResponse * clientResponse)
+{
+    if (clientResponse == NULL)
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "getReqCB received NULL clientResponse");
+        return   OC_STACK_DELETE_TRANSACTION;
+    }
+
+    if (ctx == (void*)DEFAULT_CONTEXT_VALUE)
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "Callback Context for GET query recvd successfully");
+    }
+
+    OCSAMPLE_LOG_INFO(TAG, 0, "StackResult: %s",  getResult(clientResponse->result));
+    OCSAMPLE_LOG_INFO(TAG, 0, "SEQUENCE NUMBER: %d", clientResponse->sequenceNumber);
+    OCSAMPLE_LOG_PAYLOAD(INFO, clientResponse->payload);
+    OCSAMPLE_LOG_INFO(TAG, 0, ("=============> Get Response"));
+
+    if (clientResponse->numRcvdVendorSpecificHeaderOptions > 0)
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "Received vendor specific options");
+        uint8_t i = 0;
+        OCHeaderOption * rcvdOptions = clientResponse->rcvdVendorSpecificHeaderOptions;
+        for( i = 0; i < clientResponse->numRcvdVendorSpecificHeaderOptions; i++)
+        {
+            if (((OCHeaderOption)rcvdOptions[i]).protocolID == OC_COAP_ID)
+            {
+                OCSAMPLE_LOG_INFO(TAG, 0, "Received option with OC_COAP_ID and ID %u with",
+                        ((OCHeaderOption)rcvdOptions[i]).optionID );
+               if (COAP_OPTION_CONTENT_VERSION == ((OCHeaderOption)rcvdOptions[i]).optionID)
+               {
+                    uint16_t versionValue = rcvdOptions[i].optionData[0] * 256
+                            + rcvdOptions[i].optionData[1];
+                    OCSAMPLE_LOG_INFO(TAG, 0, "Received version value of %u", versionValue);
+               }
+               if (COAP_OPTION_CONTENT_FORMAT == ((OCHeaderOption)rcvdOptions[i]).optionID)
+               {
+                    uint16_t formatValue = rcvdOptions[i].optionData[0] * 256
+                            + rcvdOptions[i].optionData[1];
+                   OCSAMPLE_LOG_INFO(TAG, 0, "Received format value of %u", formatValue);
+               }
+                OIC_LOG_BUFFER(INFO, TAG, ((OCHeaderOption)rcvdOptions[i]).optionData,
+                    MAX_HEADER_OPTION_DATA_LENGTH);
+            }
+        }
+    }
+
+    switch (TestCase)
+    {
+    case TEST_INTROSPECTION:
+        InitIntrospectionPayload(clientResponse);
+        break;
+    default:
+        break;
+    }
+
+    return OC_STACK_DELETE_TRANSACTION;
+}
+
+OCStackApplicationResult obsReqCB(void* ctx, OCDoHandle handle,
+                                  OCClientResponse * clientResponse)
+{
+    if (ctx == (void*)DEFAULT_CONTEXT_VALUE)
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "Callback Context for OBS query recvd successfully");
+    }
+
+    if (clientResponse)
+    {
+        if (clientResponse->sequenceNumber <= MAX_SEQUENCE_NUMBER)
+        {
+            if (clientResponse->sequenceNumber == OC_OBSERVE_REGISTER)
+            {
+                OCSAMPLE_LOG_INFO(TAG, 0, "This also serves as a registration confirmation.");
+            }
+
+            OCSAMPLE_LOG_INFO(TAG, 0, "StackResult: %s",  getResult(clientResponse->result));
+            OCSAMPLE_LOG_INFO(TAG, 0, "SEQUENCE NUMBER: %d", clientResponse->sequenceNumber);
+
+            if (clientResponse->result == OC_STACK_OK)
+            {
+                OCSAMPLE_LOG_INFO(TAG, 0, "Callback Context for OBSERVE notification recvd successfully %d",
+                        gNumObserveNotifies);
+                OCSAMPLE_LOG_PAYLOAD(INFO, clientResponse->payload);
+                OCSAMPLE_LOG_INFO(TAG, 0, ("=============> Obs Response"));
+                gNumObserveNotifies++;
+
+                if (gNumObserveNotifies > 15) //large number to test observing in DELETE case.
+                {
+                    if (TestCase == TEST_OBS_REQ_NON || TestCase == TEST_OBS_REQ_CON)
+                    {
+                        OCSAMPLE_LOG_ERROR(TAG, 0, "Cancelling with LOW QOS");
+                        if (OCCancel (handle, OC_LOW_QOS, NULL, 0) != OC_STACK_OK)
+                        {
+                            OCSAMPLE_LOG_ERROR(TAG, 0, "Observe cancel error");
+                        }
+                        return OC_STACK_DELETE_TRANSACTION;
+                    }
+                    else if (TestCase == TEST_OBS_REQ_NON_CANCEL_IMM)
+                    {
+                        OCSAMPLE_LOG_ERROR(TAG, 0, "Cancelling with HIGH QOS");
+                        if (OCCancel (handle, OC_HIGH_QOS, NULL, 0) != OC_STACK_OK)
+                        {
+                            OCSAMPLE_LOG_ERROR(TAG, 0, "Observe cancel error");
+                        }
+                    }
+                }
+            }
+        }
+        else
+        {
+            OCSAMPLE_LOG_INFO(TAG, 0, "No observe option header is returned in the response.");
+            OCSAMPLE_LOG_INFO(TAG, 0, "For a registration request, it means the registration failed");
+            return OC_STACK_DELETE_TRANSACTION;
+        }
+    }
+    else
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "obsReqCB received Null clientResponse");
+    }
+    return OC_STACK_KEEP_TRANSACTION;
+}
+#ifdef WITH_PRESENCE
+OCStackApplicationResult presenceCB(void* ctx, OCDoHandle /*handle*/,
+                                    OCClientResponse * clientResponse)
+{
+    if (ctx == (void*) DEFAULT_CONTEXT_VALUE)
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "Callback Context for Presence recvd successfully");
+    }
+
+    if (clientResponse)
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "StackResult: %s", getResult(clientResponse->result));
+        OCSAMPLE_LOG_INFO(TAG, 0, "Callback Context for Presence notification recvd successfully %d",
+                gNumPresenceNotifies);
+        OCSAMPLE_LOG_PAYLOAD(INFO, clientResponse->payload);
+        OCSAMPLE_LOG_INFO(TAG, 0, ("=============> Presence Response"));
+        gNumPresenceNotifies++;
+        if (gNumPresenceNotifies == 20)
+        {
+            if (OCCancel(gPresenceHandle, OC_LOW_QOS, NULL, 0) != OC_STACK_OK)
+            {
+                OCSAMPLE_LOG_ERROR(TAG, 0, "Presence cancel error");
+            }
+            return OC_STACK_DELETE_TRANSACTION;
+        }
+    }
+    else
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "presenceCB received Null clientResponse");
+    }
+    return OC_STACK_KEEP_TRANSACTION;
+}
+#endif
+
+// This is a function called back when a device is discovered
+OCStackApplicationResult discoveryReqCB(void* ctx, OCDoHandle /*handle*/,
+                                        OCClientResponse * clientResponse)
+{
+    if (ctx == (void*) DEFAULT_CONTEXT_VALUE)
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "Callback Context for DISCOVER query recvd successfully");
+    }
+
+    if (clientResponse)
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "StackResult: %s", getResult(clientResponse->result));
+
+        std::string connectionType = getConnectivityType (clientResponse->connType);
+        OCSAMPLE_LOG_INFO(TAG, 0, "Discovered on %s", connectionType.c_str());
+        OCSAMPLE_LOG_INFO(TAG, 0,
+                "Device =============> Discovered @ %s:%d",
+                clientResponse->devAddr.addr,
+                clientResponse->devAddr.port);
+        OCSAMPLE_LOG_PAYLOAD(INFO, clientResponse->payload);
+
+        ConnType = clientResponse->connType;
+        serverAddr = clientResponse->devAddr;
+
+        OCDiscoveryPayload *payload = (OCDiscoveryPayload*) clientResponse->payload;
+        if (!payload)
+        {
+            return OC_STACK_DELETE_TRANSACTION;
+        }
+
+        OCResourcePayload *resource = (OCResourcePayload*) payload->resources;
+        int found = 0;
+        while (resource)
+        {
+            if(resource->uri && strcmp(resource->uri, coapServerResource.c_str()) == 0)
+            {
+                found = 1;
+                break;
+            }
+            resource = resource->next;
+        }
+
+        if(!found)
+        {
+            OCSAMPLE_LOG_INFO(TAG, 0, "No %s in payload", coapServerResource.c_str());
+            return OC_STACK_KEEP_TRANSACTION;
+        }
+
+        switch(TestCase)
+        {
+            case TEST_GET_REQ_NON:
+                InitGetRequest(OC_LOW_QOS, 0, 0);
+                break;
+            case TEST_GET_REQ_NON_WITH_FILTERS:
+                InitGetRequest(OC_LOW_QOS, 0, 1);
+                break;
+            case TEST_PUT_REQ_NON:
+                InitPutRequest(OC_LOW_QOS);
+                break;
+            case TEST_POST_REQ_NON:
+                InitPostRequest(OC_LOW_QOS);
+                break;
+            case TEST_DELETE_REQ_NON:
+                InitDeleteRequest(OC_LOW_QOS);
+                break;
+            case TEST_OBS_REQ_NON:
+            case TEST_OBS_REQ_NON_CANCEL_IMM:
+                InitObserveRequest(OC_LOW_QOS);
+                break;
+            case TEST_GET_UNAVAILABLE_RES_REQ_NON:
+                InitGetRequestToUnavailableResource(OC_LOW_QOS);
+                break;
+            case TEST_GET_REQ_CON:
+                InitGetRequest(OC_HIGH_QOS, 0, 0);
+                break;
+            case TEST_POST_REQ_CON:
+                InitPostRequest(OC_HIGH_QOS);
+                break;
+            case TEST_DELETE_REQ_CON:
+                InitDeleteRequest(OC_HIGH_QOS);
+                break;
+            case TEST_OBS_REQ_CON:
+                InitObserveRequest(OC_HIGH_QOS);
+                break;
+#ifdef WITH_PRESENCE
+            case TEST_OBS_PRESENCE:
+            case TEST_OBS_PRESENCE_WITH_FILTER:
+            case TEST_OBS_PRESENCE_WITH_FILTERS:
+            case TEST_OBS_MULTICAST_PRESENCE:
+                InitPresence();
+                break;
+#endif
+            case TEST_GET_REQ_NON_WITH_VENDOR_HEADER_OPTIONS:
+                InitGetRequest(OC_LOW_QOS, 1, 0);
+                break;
+            case TEST_DISCOVER_PLATFORM_REQ:
+                InitPlatformDiscovery(OC_LOW_QOS);
+                break;
+            case TEST_DISCOVER_DEV_REQ:
+                InitDeviceDiscovery(OC_LOW_QOS);
+                break;
+            case TEST_DISCOVER_REQ_SHOW_EPS:
+                showEndpointsInfo(resource);
+                break;
+            case TEST_GET_REQ_UDP:
+                InitGetRequestWithCoap(payload, true);
+                break;
+            case TEST_GET_REQ_TCP:
+                InitGetRequestWithCoap(payload, false);
+                break;
+            case TEST_INTROSPECTION:
+                InitIntrospection(payload);
+                break;
+            default:
+                PrintUsage();
+                break;
+        }
+    }
+    else
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "discoveryReqCB received Null clientResponse");
+    }
+    return OC_STACK_KEEP_TRANSACTION;
+}
+
+OCStackApplicationResult PlatformDiscoveryReqCB(void* ctx,
+                                                OCDoHandle /*handle*/,
+                                                OCClientResponse * clientResponse)
+{
+    if (ctx == (void*) DEFAULT_CONTEXT_VALUE)
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "Callback Context for Platform DISCOVER query recvd successfully");
+    }
+
+    if (clientResponse)
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, ("Discovery Response:"));
+        OCSAMPLE_LOG_PAYLOAD(INFO, clientResponse->payload);
+    }
+    else
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "PlatformDiscoveryReqCB received Null clientResponse");
+    }
+
+    return (UnicastDiscovery) ? OC_STACK_DELETE_TRANSACTION : OC_STACK_KEEP_TRANSACTION;
+}
+
+OCStackApplicationResult DeviceDiscoveryReqCB(void* ctx, OCDoHandle /*handle*/,
+                                              OCClientResponse * clientResponse)
+{
+    if (ctx == (void*) DEFAULT_CONTEXT_VALUE)
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "Callback Context for Device DISCOVER query recvd successfully");
+    }
+
+    if (clientResponse)
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, ("Discovery Response:"));
+        OCSAMPLE_LOG_PAYLOAD(INFO, clientResponse->payload);
+    }
+    else
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "PlatformDiscoveryReqCB received Null clientResponse");
+    }
+
+    return (UnicastDiscovery) ? OC_STACK_DELETE_TRANSACTION : OC_STACK_KEEP_TRANSACTION;
+}
+
+#ifdef WITH_PRESENCE
+int InitPresence()
+{
+    OCStackResult result = OC_STACK_OK;
+    OCSAMPLE_LOG_INFO(TAG, 0, "\n\nExecuting %s", __func__);
+    std::ostringstream query;
+    std::ostringstream querySuffix;
+    query << OC_RSRVD_PRESENCE_URI;
+    if (TestCase == TEST_OBS_PRESENCE)
+    {
+        result = InvokeOCDoResource(query, &serverAddr, OC_REST_PRESENCE,
+                OC_LOW_QOS, presenceCB, NULL, 0);
+    }
+    if (TestCase == TEST_OBS_PRESENCE_WITH_FILTER || TestCase == TEST_OBS_PRESENCE_WITH_FILTERS)
+    {
+        querySuffix.str("");
+        querySuffix << query.str() << "?rt=core.led";
+        result = InvokeOCDoResource(querySuffix, &serverAddr, OC_REST_PRESENCE,
+                OC_LOW_QOS, presenceCB, NULL, 0);
+    }
+    if (TestCase == TEST_OBS_PRESENCE_WITH_FILTERS)
+    {
+        if (result == OC_STACK_OK)
+        {
+            querySuffix.str("");
+            querySuffix << query.str() << "?rt=core.fan";
+            result = InvokeOCDoResource(querySuffix, &serverAddr, OC_REST_PRESENCE, OC_LOW_QOS,
+                    presenceCB, NULL, 0);
+        }
+    }
+    if (TestCase == TEST_OBS_MULTICAST_PRESENCE)
+    {
+        if (result == OC_STACK_OK)
+        {
+            result = InvokeOCDoResource(query, NULL, OC_REST_PRESENCE, OC_LOW_QOS,
+                    presenceCB, NULL, 0);
+        }
+    }
+    return result;
+}
+#endif
+
+int InitGetRequestToUnavailableResource(OCQualityOfService qos)
+{
+    std::ostringstream query;
+    query << "/SomeUnknownResource";
+    OCSAMPLE_LOG_INFO(TAG, 0, "\nExecuting %s with query %s", __func__, query.str().c_str());
+    return (InvokeOCDoResource(query, &serverAddr, OC_REST_GET, (qos == OC_HIGH_QOS)? OC_HIGH_QOS:OC_LOW_QOS,
+            getReqCB, NULL, 0));
+}
+
+int InitIntrospectionPayload(OCClientResponse * clientResponse)
+{
+    std::ostringstream query;
+    std::string introspectionPayloadUrl;
+    OCRepPayload *introspectionInfo = (OCRepPayload*)clientResponse->payload;
+    if (NULL == introspectionInfo)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "\nFailed to get introspection info from NULL payload");
+        return OC_STACK_ERROR;
+    }
+
+    OCRepPayloadValue *value = introspectionInfo->values;
+
+    while (value)
+    {
+        if (strcmp(value->name, "urlInfo") == 0)
+        {
+            break;
+        }
+        value = value->next;
+    }
+
+    if (value && (value->arr.dimensions[0] > 0))
+    {
+        OCRepPayloadValue *prop = value->arr.objArray[0]->values;
+        while (prop)
+        {
+            if (strcmp(prop->name, "url") == 0)
+            {
+                introspectionPayloadUrl = prop->str;
+                break;
+            }
+            prop = prop->next;
+        }
+    }
+
+    if (introspectionPayloadUrl.length() <= 0)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "\nFailed to get introspection URL from payload");
+        return OC_STACK_ERROR;
+    }
+    else
+    {
+        query << introspectionPayloadUrl;
+        OCSAMPLE_LOG_INFO(TAG, 0, "\nExecuting %s with query %s", __func__, query.str().c_str());
+        return (InvokeOCDoResource(query, &serverAddr, OC_REST_GET, OC_LOW_QOS,
+            getReqCB, NULL, 0));
+    }
+}
+
+int InitIntrospection(OCDiscoveryPayload* dis)
+{
+    OCResourcePayload* resource = (OCResourcePayload*)dis->resources;
+    bool found = false;
+    std::string introspectionUri;
+    while (resource && !found)
+    {
+        OCStringLL* resTypes = resource->types;
+        while (resTypes && !found)
+        {
+            if (strcmp(resTypes->value, introspectionResType.c_str()) == 0)
+            {
+                introspectionUri = resource->uri;
+                found = true;
+            }
+            resTypes = resTypes->next;
+        }
+        resource = resource->next;
+    }
+
+    if (introspectionUri.length() == 0)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Could not find URI for introspection");
+    }
+
+    std::ostringstream query;
+    query << introspectionUri;
+    OCSAMPLE_LOG_INFO(TAG, 0, "\nExecuting %s with query %s", __func__, query.str().c_str());
+    return (InvokeOCDoResource(query, &serverAddr, OC_REST_GET, OC_LOW_QOS,
+            getReqCB, NULL, 0));
+}
+
+int InitObserveRequest(OCQualityOfService qos)
+{
+    std::ostringstream query;
+    query << coapServerResource;
+    OCSAMPLE_LOG_INFO(TAG, 0, "\nExecuting %s with query %s", __func__, query.str().c_str());
+    return (InvokeOCDoResource(query, &serverAddr, OC_REST_OBSERVE,
+            (qos == OC_HIGH_QOS)? OC_HIGH_QOS:OC_LOW_QOS, obsReqCB, NULL, 0));
+}
+
+int InitPutRequest(OCQualityOfService qos)
+{
+    std::ostringstream query;
+    query << coapServerResource;
+    OCSAMPLE_LOG_INFO(TAG, 0, "\nExecuting %s with query %s", __func__, query.str().c_str());
+    return (InvokeOCDoResource(query, &serverAddr, OC_REST_PUT, (qos == OC_HIGH_QOS)? OC_HIGH_QOS:OC_LOW_QOS,
+            putReqCB, NULL, 0));
+}
+
+int InitPostRequest(OCQualityOfService qos)
+{
+    OCStackResult result;
+
+    std::ostringstream query;
+    query << coapServerResource;
+
+    OCSAMPLE_LOG_INFO(TAG, 0, "\nExecuting %s with query %s", __func__, query.str().c_str());
+    // First POST operation (to create an Light instance)
+    result = InvokeOCDoResource(query, &serverAddr, OC_REST_POST,
+                               ((qos == OC_HIGH_QOS) ? OC_HIGH_QOS: OC_LOW_QOS),
+                               postReqCB, NULL, 0);
+    if (OC_STACK_OK != result)
+    {
+        // Error can happen if for example, network connectivity is down
+        OCSAMPLE_LOG_INFO(TAG, 0, "First POST call did not succeed");
+    }
+
+    // Second POST operation (to create an Light instance)
+    result = InvokeOCDoResource(query, &serverAddr, OC_REST_POST,
+                               ((qos == OC_HIGH_QOS) ? OC_HIGH_QOS: OC_LOW_QOS),
+                               postReqCB, NULL, 0);
+    if (OC_STACK_OK != result)
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "Second POST call did not succeed");
+    }
+
+    // This POST operation will update the original resourced /a/light
+    return (InvokeOCDoResource(query, &serverAddr, OC_REST_POST,
+                               ((qos == OC_HIGH_QOS) ? OC_HIGH_QOS: OC_LOW_QOS),
+                               postReqCB, NULL, 0));
+}
+
+void* RequestDeleteDeathResourceTask(void* myqos)
+{
+    sleep (30);//long enough to give the server time to finish deleting the resource.
+    std::ostringstream query;
+    query << coapServerResource;
+
+    OCSAMPLE_LOG_INFO(TAG, 0, "\nExecuting %s with query %s", __func__, query.str().c_str());
+
+    // Second DELETE operation to delete the resource that might have been removed already.
+    OCQualityOfService qos;
+    if (myqos == NULL)
+    {
+        qos = OC_LOW_QOS;
+    }
+    else
+    {
+        qos = OC_HIGH_QOS;
+    }
+
+    OCStackResult result = InvokeOCDoResource(query, &serverAddr, OC_REST_DELETE,
+                               qos,
+                               deleteReqCB, NULL, 0);
+
+    if (OC_STACK_OK != result)
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "Second DELETE Request also failed");
+    }
+    else
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "Second DELETE Request sent successfully; Waiting for Callback");
+    }
+
+    return NULL;
+}
+
+int InitDeleteRequest(OCQualityOfService qos)
+{
+    OCStackResult result;
+    std::ostringstream query;
+    query << coapServerResource;
+
+    OCSAMPLE_LOG_INFO(TAG, 0, "\nExecuting %s with query %s", __func__, query.str().c_str());
+
+    // First DELETE operation
+    result = InvokeOCDoResource(query, &serverAddr, OC_REST_DELETE,
+                               qos,
+                               deleteReqCB, NULL, 0);
+    if (OC_STACK_OK != result)
+    {
+        // Error can happen if for example, network connectivity is down
+        OCSAMPLE_LOG_INFO(TAG, 0, "DELETE Request did not succeed; Will try again.");
+        //Create a thread to delete this resource again
+        pthread_t threadId;
+        pthread_create (&threadId, NULL, RequestDeleteDeathResourceTask, (void*)qos);
+    }
+    else
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "DELETE Request sent successfully; Waiting for Callback");
+    }
+    return result;
+}
+
+int InitGetRequest(OCQualityOfService qos, uint8_t withVendorSpecificHeaderOptions,
+                   bool getWithQuery)
+{
+
+    OCHeaderOption options[MAX_HEADER_OPTIONS];
+
+    std::ostringstream query;
+    query << coapServerResource;
+
+    // ocserver is written to only process "power<X" query.
+    if (getWithQuery)
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "Using query power<50");
+        query << "?power<50";
+    }
+    OCSAMPLE_LOG_INFO(TAG, 0, "\nExecuting %s with query %s", __func__, query.str().c_str());
+
+    if (withVendorSpecificHeaderOptions)
+    {
+        memset(options, 0, sizeof(OCHeaderOption)* MAX_HEADER_OPTIONS);
+        size_t numOptions = 0;
+        uint8_t option0[] = { 16, 39 };
+        uint16_t optionID = COAP_OPTION_ACCEPT;
+        size_t optionDataSize = sizeof(option0);
+        OCSetHeaderOption(options,
+                          &numOptions,
+                          optionID,
+                          option0,
+                          optionDataSize);
+
+        uint8_t option1[] = { 0, 8 };
+        optionID = COAP_OPTION_ACCEPT_VERSION;
+        optionDataSize = sizeof(option1);
+        OCSetHeaderOption(options,
+                          &numOptions,
+                          optionID,
+                          option1,
+                          optionDataSize);
+    }
+    if (withVendorSpecificHeaderOptions)
+    {
+        return (InvokeOCDoResource(query, &serverAddr, OC_REST_GET,
+                (qos == OC_HIGH_QOS) ? OC_HIGH_QOS : OC_LOW_QOS, getReqCB, options, 2));
+    }
+    else
+    {
+        return (InvokeOCDoResource(query, &serverAddr, OC_REST_GET,
+                (qos == OC_HIGH_QOS) ? OC_HIGH_QOS : OC_LOW_QOS, getReqCB, NULL, 0));
+    }
+}
+
+int InitPlatformDiscovery(OCQualityOfService qos)
+{
+    OCSAMPLE_LOG_INFO(TAG, 0, "\n\nExecuting %s", __func__);
+
+    OCStackResult ret;
+    OCCallbackData cbData;
+    char szQueryUri[MAX_QUERY_LENGTH] = { 0 };
+
+    snprintf(szQueryUri, sizeof (szQueryUri) - 1, PLATFORM_DISCOVERY_QUERY, discoveryAddr);
+
+    cbData.cb = PlatformDiscoveryReqCB;
+    cbData.context = (void*)DEFAULT_CONTEXT_VALUE;
+    cbData.cd = NULL;
+
+    ret = OCDoRequest(NULL, OC_REST_DISCOVER, szQueryUri, NULL, 0, CT_DEFAULT,
+                      (qos == OC_HIGH_QOS) ? OC_HIGH_QOS : OC_LOW_QOS,
+                      &cbData, NULL, 0);
+    if (ret != OC_STACK_OK)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "OCStack device error");
+    }
+
+    return ret;
+}
+
+int InitDeviceDiscovery(OCQualityOfService qos)
+{
+    OCSAMPLE_LOG_INFO(TAG, 0, "\n\nExecuting %s", __func__);
+
+    OCStackResult ret;
+    OCCallbackData cbData;
+    char szQueryUri[MAX_QUERY_LENGTH] = { 0 };
+
+    snprintf(szQueryUri, sizeof (szQueryUri) - 1, DEVICE_DISCOVERY_QUERY, discoveryAddr);
+
+    cbData.cb = DeviceDiscoveryReqCB;
+    cbData.context = (void*)DEFAULT_CONTEXT_VALUE;
+    cbData.cd = NULL;
+
+    ret = OCDoRequest(NULL, OC_REST_DISCOVER, szQueryUri, NULL, 0, CT_DEFAULT,
+                      (qos == OC_HIGH_QOS) ? OC_HIGH_QOS : OC_LOW_QOS,
+                      &cbData, NULL, 0);
+    if (ret != OC_STACK_OK)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "OCStack device error");
+    }
+
+    return ret;
+}
+
+int InitDiscovery(OCQualityOfService qos, uint8_t withVendorSpecificHeaderOptions)
+{
+    OCStackResult ret;
+    OCCallbackData cbData;
+    char szQueryUri[MAX_QUERY_LENGTH] = { 0 };
+
+    snprintf(szQueryUri, sizeof (szQueryUri) - 1, RESOURCE_DISCOVERY_QUERY, discoveryAddr);
+
+    cbData.cb = discoveryReqCB;
+    cbData.context = (void*)DEFAULT_CONTEXT_VALUE;
+    cbData.cd = NULL;
+
+    if (withVendorSpecificHeaderOptions)
+    {
+        OCHeaderOption options[MAX_HEADER_OPTIONS];
+        memset(options, 0, sizeof(OCHeaderOption) * MAX_HEADER_OPTIONS);
+        size_t numOptions = 0;
+
+        uint8_t format = COAP_MEDIATYPE_APPLICATION_CBOR;
+        uint16_t optionID = CA_OPTION_ACCEPT;
+        OCSetHeaderOption(options, &numOptions, optionID, &format, sizeof(format));
+
+        ret = OCDoRequest(NULL, OC_REST_DISCOVER, szQueryUri, NULL, 0, CT_DEFAULT,
+                              (qos == OC_HIGH_QOS) ? OC_HIGH_QOS : OC_LOW_QOS,
+                              &cbData, options, 2);
+    }
+    else
+    {
+        ret = OCDoRequest(NULL, OC_REST_DISCOVER, szQueryUri, NULL, 0, CT_DEFAULT,
+                           (qos == OC_HIGH_QOS) ? OC_HIGH_QOS : OC_LOW_QOS,
+                           &cbData, NULL, 0);
+    }
+    if (ret != OC_STACK_OK)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "OCStack resource error");
+    }
+    return ret;
+}
+
+int InitGetRequestWithCoap(OCDiscoveryPayload* dis, bool isUdp)
+{
+    if (!dis)
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "Given payload is NULL!!!");
+        return -1;
+    }
+
+    // copy query
+    std::ostringstream query;
+    query << coapServerResource;
+
+    // server addr
+    OCDevAddr dev;
+    memset(&dev, 0, sizeof(dev));
+    dev.adapter = OC_DEFAULT_ADAPTER;
+
+    // find endpoint with ipv4, UDP or TCP
+    OCResourcePayload* res = dis->resources;
+    while (res)
+    {
+        OCEndpointPayload* eps = res->eps;
+        while (eps)
+        {
+            if (strcmp(eps->tps, (isUdp ? COAP_UDP : COAP_TCP)) == 0 &&
+                strlen(eps->addr) < MAX_LENGTH_IPv4_ADDR)
+            {
+                OCSAMPLE_LOG_INFO(TAG, 0, "%s found!!!", (isUdp ? COAP_UDP : COAP_TCP));
+                dev.adapter = (isUdp ? OC_ADAPTER_IP : OC_ADAPTER_TCP);
+                dev.flags = OC_IP_USE_V4;
+                dev.port = eps->port;
+                memcpy(dev.addr, eps->addr, sizeof(dev.addr));
+            }
+            eps = eps->next;
+        }
+        res = res->next;
+    }
+
+    if (dev.adapter == (isUdp ? OC_ADAPTER_IP : OC_ADAPTER_TCP) && dev.flags == OC_IP_USE_V4)
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "dev addr is %s", dev.addr);
+        OCSAMPLE_LOG_INFO(TAG, 0, "dev port is %d", dev.port);
+        OCSAMPLE_LOG_INFO(TAG, 0, "dev flags is %d", dev.flags);
+        OCSAMPLE_LOG_INFO(TAG, 0, "dev adapter is %d", dev.adapter);
+
+        // send ocdoresource
+        return (InvokeOCDoResource(query, &dev, OC_REST_GET,
+                OC_LOW_QOS, getReqCB, NULL, 0));
+    }
+    else
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "Endpoints infomation not found on given payload!!!");
+        return -1;
+    }
+}
+
+void showEndpointsInfo(OCResourcePayload* res)
+{
+    if (!res)
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "No endpoints information in given payload");
+        return;
+    }
+
+    if (!res->eps)
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "No endpoints information in given payload");
+        return;
+    }
+
+    OCEndpointPayload* eps = res->eps;
+
+    while (eps)
+    {
+        if (eps->family == OC_IP_USE_V6)
+        {
+            OCSAMPLE_LOG_INFO(TAG, 0, "Resource [%s] has endpoint [%s://[%s]:%d]",
+                      res->uri, eps->tps, eps->addr, eps->port);
+        }
+        else if (eps->family == OC_IP_USE_V4)
+        {
+            OCSAMPLE_LOG_INFO(TAG, 0, "Resource [%s] has endpoint [%s://%s:%d]",
+                      res->uri, eps->tps, eps->addr, eps->port);
+        }
+        else
+        {
+            OCSAMPLE_LOG_INFO(TAG, 0, "Resource [%s] has endpoint [%s://%s]",
+                      res->uri, eps->tps, eps->addr);
+        }
+
+        eps = eps->next;
+    }
+}
+
+OCStackResult SetDeviceInfo()
+{
+    OCResourceHandle resourceHandle = OCGetResourceHandleAtUri(OC_RSRVD_DEVICE_URI);
+    if (resourceHandle == NULL)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Device Resource does not exist.");
+        goto exit;
+    }
+
+    VERIFY_SUCCESS(OCSetPropertyValue(PAYLOAD_TYPE_DEVICE, OC_RSRVD_DEVICE_NAME, gDeviceName));
+    VERIFY_SUCCESS(OCSetPropertyValue(PAYLOAD_TYPE_DEVICE, OC_RSRVD_DATA_MODEL_VERSION, gDataModelVersions));
+    VERIFY_SUCCESS(OCSetPropertyValue(PAYLOAD_TYPE_DEVICE, OC_RSRVD_PROTOCOL_INDEPENDENT_ID, gProtocolIndependentID));
+
+    if (1 == OCFSpecVersion)
+    {
+        VERIFY_SUCCESS(OCSetPropertyValue(PAYLOAD_TYPE_DEVICE, OC_RSRVD_SPEC_VERSION, gSpecVersion));
+    }
+
+    OCSAMPLE_LOG_INFO(TAG, 0, "Device information initialized successfully.");
+    return OC_STACK_OK;
+
+exit:
+    return OC_STACK_ERROR;
+}
+
+OCStackResult SetPlatformInfo()
+{
+    OCResourceHandle resourceHandle = OCGetResourceHandleAtUri(OC_RSRVD_PLATFORM_URI);
+    if (resourceHandle == NULL)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Platform Resource does not exist.");
+        goto exit;
+    }
+
+    VERIFY_SUCCESS(OCSetPropertyValue(PAYLOAD_TYPE_PLATFORM, OC_RSRVD_PLATFORM_ID, gPlatformID));
+    VERIFY_SUCCESS(OCSetPropertyValue(PAYLOAD_TYPE_PLATFORM, OC_RSRVD_MFG_NAME, gManufacturerName));
+    VERIFY_SUCCESS(OCSetPropertyValue(PAYLOAD_TYPE_PLATFORM, OC_RSRVD_MFG_URL, gManufacturerUrl));
+    VERIFY_SUCCESS(OCSetPropertyValue(PAYLOAD_TYPE_PLATFORM, OC_RSRVD_MODEL_NUM, gModelNumber));
+    VERIFY_SUCCESS(OCSetPropertyValue(PAYLOAD_TYPE_PLATFORM, OC_RSRVD_MFG_DATE, gDateOfManufacture));
+    VERIFY_SUCCESS(OCSetPropertyValue(PAYLOAD_TYPE_PLATFORM, OC_RSRVD_PLATFORM_VERSION, gPlatformVersion));
+    VERIFY_SUCCESS(OCSetPropertyValue(PAYLOAD_TYPE_PLATFORM, OC_RSRVD_OS_VERSION, gOperatingSystemVersion));
+    VERIFY_SUCCESS(OCSetPropertyValue(PAYLOAD_TYPE_PLATFORM, OC_RSRVD_HARDWARE_VERSION, gHardwareVersion));
+    VERIFY_SUCCESS(OCSetPropertyValue(PAYLOAD_TYPE_PLATFORM, OC_RSRVD_FIRMWARE_VERSION, gFirmwareVersion));
+    VERIFY_SUCCESS(OCSetPropertyValue(PAYLOAD_TYPE_PLATFORM, OC_RSRVD_SUPPORT_URL, gSupportUrl));
+    VERIFY_SUCCESS(OCSetPropertyValue(PAYLOAD_TYPE_PLATFORM, OC_RSRVD_SYSTEM_TIME, gSystemTime));
+
+    OCSAMPLE_LOG_INFO(TAG, 0, "Platform information initialized successfully.");
+    return OC_STACK_OK;
+
+exit:
+    return OC_STACK_ERROR;
+}
+
+static FILE* server_fopen(const char* path, const char* mode)
+{
+    return fopen(path, mode);
+}
+
+#ifdef SECURED
+void OC_CALL DisplayPinCB(char *pin, size_t pinSize, void *context)
+{
+    OC_UNUSED(context);
+
+    if ((nullptr == pin) || (0 == pinSize))
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "Invalid PIN");
+        return;
+    }
+
+    OCSAMPLE_LOG_INFO(TAG, 0, "============================");
+    OCSAMPLE_LOG_INFO(TAG, 0, "    PIN CODE : %s", pin);
+    OCSAMPLE_LOG_INFO(TAG, 0, "============================");
+}
+
+void OC_CALL ClosePinDisplayCB(void)
+{
+    OCSAMPLE_LOG_INFO(TAG, 0, "============================");
+    OCSAMPLE_LOG_INFO(TAG, 0, "    PIN DISPLAY CLOSED.");
+    OCSAMPLE_LOG_INFO(TAG, 0, "============================");
+}
+#endif
+
+void *clientStarter(void *param)
+{
+    OCSAMPLE_LOG_INFO(TAG, 0, "Entering occlient main loop...");
+    while (!gQuitFlag)
+    {
+        if (OCProcess() != OC_STACK_OK)
+        {
+            OCSAMPLE_LOG_ERROR(TAG, 0, "OCStack process error");
+            return 0;
+        }
+        sleep(1);
+    }
+}
+
+int main(int argc, char* argv[])
+{
+    int opt;
+    OCPersistentStorage ps{ server_fopen, fread, fwrite, fclose, unlink };
+
+#ifdef __webos__
+    LSError lserror;
+    LSErrorInit(&lserror);
+
+    (void) PmLogGetContext("OCCLIENT", &gLogContext);
+    (void) PmLogGetContext("OCCLIENT-LIB", &occlientLibLogContext);
+
+    mainloop = g_main_loop_new(NULL, FALSE);
+
+    // Initialize g_main_loop
+    if (!mainloop) {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Failed to create main loop");
+        return 0;
+    }
+
+    if (!LSRegister("org.ocf.webossample.occlient", &pLsHandle, &lserror)) {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Failed to register LS Handle");
+        LSErrorLog(gLogContext, "LS_SRVC_ERROR", &lserror);
+        return 0;
+    }
+
+    if (!LSGmainAttach(pLsHandle, mainloop, &lserror)) {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Failed to attach main loop");
+        LSErrorLog(gLogContext, "LS_SRVC_ATTACH_ERROR", &lserror);
+        return 0;
+    }
+
+#endif // __webos__
+
+    while ((opt = getopt(argc, argv, "u:t:c:i:s:")) != -1)
+    {
+        switch(opt)
+        {
+            case 'u':
+                UnicastDiscovery = atoi(optarg);
+                break;
+            case 't':
+                TestCase = atoi(optarg);
+                break;
+            case 'c':
+                Connectivity = atoi(optarg);
+                break;
+            case 'i':
+                Introspection = atoi(optarg);
+                break;
+            case 's':
+                OCFSpecVersion = atoi(optarg);
+                break;
+            default:
+                PrintUsage();
+                return -1;
+        }
+    }
+
+    if (((UnicastDiscovery != 0) && (UnicastDiscovery != 1)) ||
+            ((TestCase < TEST_DISCOVER_REQ) || (TestCase >= MAX_TESTS)) ||
+            ((Connectivity < CT_ADAPTER_DEFAULT) || (Connectivity >= MAX_CT)) ||
+            ((OCFSpecVersion != 0) && (OCFSpecVersion != 1)))
+    {
+        PrintUsage();
+        return -1;
+    }
+
+    if (OC_STACK_OK != OCRegisterPersistentStorageHandler(&ps))
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "OCRegisterPersistentStorageHandler error");
+        return 0;
+    }
+
+    if (OCInit1(OC_CLIENT_SERVER, OC_DEFAULT_FLAGS, OC_DEFAULT_FLAGS) != OC_STACK_OK)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "OCStack init error");
+        return 0;
+    }
+
+#ifdef SECURED
+    // Set callbacks for handling pin display
+    if (OC_STACK_OK != SetDisplayPinWithContextCB(DisplayPinCB, NULL))
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Failed to set display pin callback");
+        return 0;
+    }
+
+    SetClosePinDisplayCB(ClosePinDisplayCB);
+
+    // Specify the type and length of the pin that will be generated upon request
+    if (OC_STACK_OK != SetRandomPinPolicy(8, NUM_PIN))
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Failed to set PIN policy");
+        return 0;
+    }
+#endif
+
+    if (OC_STACK_OK != SetDeviceInfo())
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "SetDeviceInfo failed");
+        return 0;
+    }
+
+    if (OC_STACK_OK != SetPlatformInfo())
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "SetPlatformInfo failed");
+        return 0;
+    }
+
+#ifdef ROUTING_GATEWAY
+    /*
+     * Before invoking Discover resource, we process the gateway requests
+     * and form the routing table.
+     */
+    for (int index = 0; index < MAX_NUM_GATEWAY_REQUEST; index++)
+    {
+        if (OC_STACK_OK != OCProcess())
+        {
+            OCSAMPLE_LOG_ERROR(TAG, 0, "OCStack process error");
+            return 0;
+        }
+        usleep(SLEEP_DURATION);
+    }
+#endif
+    if (Connectivity == CT_ADAPTER_DEFAULT || Connectivity == CT_IP)
+    {
+        ConnType = CT_ADAPTER_IP;
+    }
+    else
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "Default Connectivity type selected...");
+        PrintUsage();
+    }
+
+    discoveryAddr[0] = '\0';
+
+    if (UnicastDiscovery)
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "Enter IP address of server with optional port number");
+        OCSAMPLE_LOG_INFO(TAG, 0, "IPv4: 192.168.0.15:45454\n");
+        OCSAMPLE_LOG_INFO(TAG, 0, "IPv6: [fe80::20c:29ff:fe1b:9c5]:45454\n");
+
+        if (fgets(discoveryAddr, sizeof(discoveryAddr), stdin))
+        {
+            //Strip newline char from ipv4addr
+            StripNewLineChar(discoveryAddr);
+        }
+        else
+        {
+            OCSAMPLE_LOG_ERROR(TAG, 0, "!! Bad input for IP address. !!");
+            return OC_STACK_INVALID_PARAM;
+        }
+    }
+
+    if (UnicastDiscovery == 0 && TestCase == TEST_DISCOVER_DEV_REQ)
+    {
+        InitDeviceDiscovery(OC_LOW_QOS);
+    }
+    else if (UnicastDiscovery == 0 && TestCase == TEST_DISCOVER_PLATFORM_REQ)
+    {
+        InitPlatformDiscovery(OC_LOW_QOS);
+    }
+    else
+    {
+        InitDiscovery(OC_LOW_QOS, 0);
+    }
+
+    // Break from loop with Ctrl+C
+    OCSAMPLE_LOG_INFO(TAG, 0, "Entering occlient main loop...");
+    signal(SIGINT, handleSigInt);
+
+    pthread_create(&threadId_client, NULL, clientStarter, (void *)NULL);
+    g_main_loop_run(mainloop);
+
+    OCSAMPLE_LOG_INFO(TAG, 0, "Exiting occlient main loop...");
+
+    if (OCStop() != OC_STACK_OK)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "OCStack stop error");
+    }
+
+    return 0;
+}
+
+std::string getConnectivityType (OCConnectivityType connType)
+{
+    switch (connType & CT_MASK_ADAPTER)
+    {
+        case CT_ADAPTER_IP:
+            return "IP";
+
+        case CT_IP_USE_V4:
+            return "IPv4";
+
+        case CT_IP_USE_V6:
+            return "IPv6";
+
+        case CT_ADAPTER_GATT_BTLE:
+            return "GATT";
+
+        case CT_ADAPTER_RFCOMM_BTEDR:
+            return "RFCOMM";
+
+        default:
+            return "Incorrect connectivity";
+    }
+}
diff --git a/resource/csdk/stack/samples/webos/unsecure/occlient/occlient.h b/resource/csdk/stack/samples/webos/unsecure/occlient/occlient.h
new file mode 100644
index 0000000..d79138e
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/unsecure/occlient/occlient.h
@@ -0,0 +1,160 @@
+/*******************************************************************
+ *
+ * Copyright (c) 2018 LG Electronics, Inc.
+ * Copyright 2014 Intel Mobile Communications GmbH All Rights Reserved.
+ *
+ *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+ */
+
+#ifndef OCCLIENT_H_
+#define OCCLIENT_H_
+
+#include "ocstack.h"
+
+
+//-----------------------------------------------------------------------------
+// Defines
+//-----------------------------------------------------------------------------
+#define TAG "occlient"
+#define COAP_UDP "coap"
+#define COAP_TCP "coap+tcp"
+#define DEFAULT_CONTEXT_VALUE 0x99
+#ifndef MAX_LENGTH_IPv4_ADDR
+#define MAX_LENGTH_IPv4_ADDR 16
+#endif
+
+//-----------------------------------------------------------------------------
+// Typedefs
+//-----------------------------------------------------------------------------
+
+/**
+ * List of methods that can be initiated from the client
+ */
+typedef enum {
+    TEST_DISCOVER_REQ = 1,
+    TEST_GET_REQ_NON,
+    TEST_GET_REQ_NON_WITH_FILTERS,
+    TEST_PUT_REQ_NON,
+    TEST_POST_REQ_NON,
+    TEST_DELETE_REQ_NON,
+    TEST_OBS_REQ_NON,
+    TEST_GET_UNAVAILABLE_RES_REQ_NON,
+    TEST_GET_REQ_CON,
+    TEST_POST_REQ_CON,
+    TEST_DELETE_REQ_CON,
+    TEST_OBS_REQ_CON,
+#ifdef WITH_PRESENCE
+    TEST_OBS_PRESENCE,
+    TEST_OBS_PRESENCE_WITH_FILTER,
+    TEST_OBS_PRESENCE_WITH_FILTERS,
+    TEST_OBS_MULTICAST_PRESENCE,
+#endif
+    TEST_OBS_REQ_NON_CANCEL_IMM,
+    TEST_GET_REQ_NON_WITH_VENDOR_HEADER_OPTIONS,
+    TEST_DISCOVER_PLATFORM_REQ,
+    TEST_DISCOVER_DEV_REQ,
+    TEST_DISCOVER_REQ_SHOW_EPS,
+    TEST_GET_REQ_UDP,
+    TEST_GET_REQ_TCP,
+    TEST_INTROSPECTION,
+    MAX_TESTS
+} CLIENT_TEST;
+
+/**
+ * List of connectivity types that can be initiated from the client
+ * Required for user input validation
+ */
+typedef enum {
+    CT_ADAPTER_DEFAULT = 0,
+    CT_IP,
+    MAX_CT
+} CLIENT_CONNECTIVITY_TYPE;
+
+#ifdef WITH_PRESENCE
+int InitPresence();
+#endif
+
+//----------------------------------------------------------------------------
+// Function prototype
+//----------------------------------------------------------------------------
+std::string getConnectivityType (OCConnectivityType connType);
+
+/* call getResult in common.cpp to get the result in string format. */
+const char *getResult(OCStackResult result);
+
+/* Get the IP address of the server */
+std::string getIPAddrTBServer(OCClientResponse * clientResponse);
+
+/* Get the port number the server is listening on */
+std::string getPortTBServer(OCClientResponse * clientResponse);
+
+/* Show endpoints information in given resource payload */
+void showEndpointsInfo(OCResourcePayload* res);
+
+/* Following are initialization functions for GET, Observe, PUT
+ * POST, Delete & Discovery, Get with coap, get with coap+tcp operations
+ */
+int InitGetRequestToUnavailableResource(OCQualityOfService qos);
+int InitObserveRequest(OCQualityOfService qos);
+int InitPutRequest(OCQualityOfService qos);
+int InitGetRequest(OCQualityOfService qos, uint8_t withVendorSpecificHeaderOptions, bool getWithQuery);
+int InitPostRequest(OCQualityOfService qos);
+int InitDeleteRequest(OCQualityOfService qos);
+int InitGetRequest(OCQualityOfService qos);
+int InitDeviceDiscovery(OCQualityOfService qos);
+int InitPlatformDiscovery(OCQualityOfService qos);
+int InitDiscovery(OCQualityOfService qos, uint8_t withVendorSpecificHeaderOptions);
+int InitGetRequestWithCoap(OCDiscoveryPayload* dis, bool isUdp);
+int InitIntrospection(OCDiscoveryPayload* dis);
+
+/* Call delete operation on already deleted resource */
+void* RequestDeleteDeathResourceTask(void* myqos);
+
+/* This method calls OCDoResource() which in turn makes calls
+ * to the lower layers
+ */
+OCStackResult InvokeOCDoResource(std::ostringstream &query,
+        OCMethod method, OCQualityOfService qos,
+        OCClientResponseHandler cb, OCHeaderOption * options, uint8_t numOptions);
+
+//-----------------------------------------------------------------------------
+// Callback functions
+//-----------------------------------------------------------------------------
+
+/* Following are callback functions for the  GET, Observe, PUT
+ * POST, Delete, Presence & Discovery operations
+ */
+OCStackApplicationResult putReqCB(void* ctx, OCDoHandle handle, OCClientResponse * clientResponse);
+
+OCStackApplicationResult postReqCB(void *ctx, OCDoHandle handle, OCClientResponse *clientResponse);
+
+OCStackApplicationResult getReqCB(void* ctx, OCDoHandle handle, OCClientResponse * clientResponse);
+
+OCStackApplicationResult obsReqCB(void* ctx, OCDoHandle handle, OCClientResponse * clientResponse);
+
+OCStackApplicationResult presenceCB(void* ctx,
+            OCDoHandle handle, OCClientResponse * clientResponse);
+
+OCStackApplicationResult deleteReqCB(void *ctx,
+            OCDoHandle handle, OCClientResponse *clientResponse);
+
+OCStackApplicationResult discoveryReqCB(void* ctx, OCDoHandle handle,
+        OCClientResponse * clientResponse);
+
+
+#endif
+
diff --git a/resource/csdk/stack/samples/webos/unsecure/occlient/sample_payload_logging.h b/resource/csdk/stack/samples/webos/unsecure/occlient/sample_payload_logging.h
new file mode 100644
index 0000000..5dfc666
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/unsecure/occlient/sample_payload_logging.h
@@ -0,0 +1,356 @@
+/*******************************************************************
+ *
+ * Copyright (c) 2018 LG Electronics, Inc.
+ * Copyright 2015 Intel Mobile Communications GmbH All Rights Reserved.
+ *
+ *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+ */
+
+#ifndef SAMPLE_PAYLOAD_LOGGING_H_
+#define SAMPLE_PAYLOAD_LOGGING_H_
+
+#ifndef __STDC_FORMAT_MACROS
+#define __STDC_FORMAT_MACROS
+#endif
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS
+#endif
+
+#include "logger.h"
+#include "oic_malloc.h"
+#include "ocpayload.h"
+#include "ocstack.h"
+
+#include "logging.h"
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+// PL_TAG is made as generic predefined tag because of build problems in arduino for using logging
+#define PL_TAG "PayloadLog"
+
+#ifdef TB_LOG
+    #define OCSAMPLE_LOG_PAYLOAD(level, payload) OCPayloadLog((level),(payload))
+    #define UUID_SIZE (16)
+
+const char *OC_CALL convertTriggerEnumToString(OCPresenceTrigger trigger);
+OCPresenceTrigger OC_CALL convertTriggerStringToEnum(const char * triggerStr);
+
+INLINE_API void OCPayloadLogRep(LogLevel level, OCRepPayload* payload);
+
+INLINE_API void OCPayloadLogRepValues(LogLevel level, OCRepPayloadValue* val)
+{
+    while (val)
+    {
+        switch(val->type)
+        {
+            case OCREP_PROP_NULL:
+                OCSAMPLE_LOG_INFO(PL_TAG, 0, "        %s: NULL", val->name);
+                break;
+            case OCREP_PROP_INT:
+                OCSAMPLE_LOG_INFO(PL_TAG, 0, "        %s(int):%" PRId64, val->name, val->i);
+                break;
+            case OCREP_PROP_DOUBLE:
+                OCSAMPLE_LOG_INFO(PL_TAG, 0, "        %s(double):%f", val->name, val->d);
+                break;
+            case OCREP_PROP_BOOL:
+                OCSAMPLE_LOG_INFO(PL_TAG, 0, "        %s(bool):%s", val->name, val->b ? "true" : "false");
+                break;
+            case OCREP_PROP_STRING:
+                OCSAMPLE_LOG_INFO(PL_TAG, 0, "        %s(string):%s", val->name, val->str);
+                break;
+            case OCREP_PROP_BYTE_STRING:
+                OCSAMPLE_LOG_INFO(PL_TAG, 0, "        %s(binary):", val->name);
+                OIC_LOG_BUFFER(level, PL_TAG, val->ocByteStr.bytes, val->ocByteStr.len);
+                break;
+            case OCREP_PROP_OBJECT:
+                // Note: Only prints the URI (if available), to print further, you'll
+                // need to dig into the object better!
+                OCSAMPLE_LOG_INFO(PL_TAG, 0, "        %s(object):", val->name);
+                OCPayloadLogRep(level, val->obj);
+                break;
+            case OCREP_PROP_ARRAY:
+                switch(val->arr.type)
+                {
+                    case OCREP_PROP_INT:
+                        OCSAMPLE_LOG_INFO(PL_TAG, 0, "        %s(int array):%" PRIuPTR " x %" PRIuPTR " x %" PRIuPTR ": ",
+                                val->name,
+                                val->arr.dimensions[0], val->arr.dimensions[1],
+                                val->arr.dimensions[2]);
+                        OCSAMPLE_LOG_INFO(PL_TAG, 0,  "         Values:");
+                        for (size_t i = 0; i < val->arr.dimensions[0]; i++)
+                        {
+                            OCSAMPLE_LOG_INFO(PL_TAG, 0, "             %" PRId64, val->arr.iArray[i]);
+                        }
+                        break;
+                    case OCREP_PROP_DOUBLE:
+                        OCSAMPLE_LOG_INFO(PL_TAG, 0, "        %s(double array):%" PRIuPTR " x %" PRIuPTR " x %" PRIuPTR ": ",
+                                val->name,
+                                val->arr.dimensions[0], val->arr.dimensions[1],
+                                val->arr.dimensions[2]);
+                        OCSAMPLE_LOG_INFO(PL_TAG, 0,  "         Values:");
+                        for (size_t i = 0; i < val->arr.dimensions[0]; i++)
+                        {
+                            OCSAMPLE_LOG_INFO(PL_TAG, 0, "             %lf", val->arr.dArray[i]);
+                        }
+                        break;
+                    case OCREP_PROP_BOOL:
+                        OCSAMPLE_LOG_INFO(PL_TAG, 0, "        %s(bool array):%" PRIuPTR " x %" PRIuPTR " x %" PRIuPTR ": ",
+                                val->name,
+                                val->arr.dimensions[0], val->arr.dimensions[1],
+                                val->arr.dimensions[2]);
+                        OCSAMPLE_LOG_INFO(PL_TAG, 0,  "         Values:");
+                        for (size_t i = 0; i < val->arr.dimensions[0]; i++)
+                        {
+                            OCSAMPLE_LOG_INFO(PL_TAG, 0, "             %d", val->arr.bArray[i]);
+                        }
+                        break;
+                    case OCREP_PROP_STRING:
+                        OCSAMPLE_LOG_INFO(PL_TAG, 0, "        %s(string array):%" PRIuPTR " x %" PRIuPTR " x %" PRIuPTR ": ",
+                                val->name,
+                                val->arr.dimensions[0], val->arr.dimensions[1],
+                                val->arr.dimensions[2]);
+                        OCSAMPLE_LOG_INFO(PL_TAG, 0,  "         Values:");
+                        for (size_t i = 0; i < val->arr.dimensions[0]; i++)
+                        {
+                            OCSAMPLE_LOG_INFO(PL_TAG, 0, "             %s", val->arr.strArray[i]);
+                        }
+                        break;
+                    case OCREP_PROP_BYTE_STRING:
+                        OCSAMPLE_LOG_INFO(PL_TAG, 0, "        %s(byte array):%" PRIuPTR " x %" PRIuPTR " x %" PRIuPTR ": ",
+                                val->name,
+                                val->arr.dimensions[0], val->arr.dimensions[1],
+                                val->arr.dimensions[2]);
+                        OCSAMPLE_LOG_INFO(PL_TAG, 0,  "         Values:");
+                        for (size_t i = 0; i < val->arr.dimensions[0]; i++)
+                        {
+                            OIC_LOG_BUFFER(level, PL_TAG, val->arr.ocByteStrArray[i].bytes, val->arr.ocByteStrArray[i].len);
+                        }
+                        break;
+                    case OCREP_PROP_OBJECT:
+                        OCSAMPLE_LOG_INFO(PL_TAG, 0, "        %s(object array):%" PRIuPTR " x %" PRIuPTR " x %" PRIuPTR ": ",
+                                val->name,
+                                val->arr.dimensions[0], val->arr.dimensions[1],
+                                val->arr.dimensions[2]);
+                        OCSAMPLE_LOG_INFO(PL_TAG, 0,  "         Values:");
+
+                        for (size_t i = 0; i < val->arr.dimensions[0]; i++)
+                        {
+                            OCPayloadLogRep(level, val->arr.objArray[i]);
+                        }
+                        break;
+                    case OCREP_PROP_ARRAY: //Seems as nested arrays doesn't not supported in API
+                    default:
+                        OCSAMPLE_LOG_ERROR(PL_TAG, 0, "%s <-- Unknown/unsupported array type!",
+                                val->name);
+                        break;
+                }
+                break;
+            default:
+                OCSAMPLE_LOG_ERROR(PL_TAG, 0, "%s <-- Unknown type!", val->name);
+                break;
+        }
+        val = val -> next;
+    }
+}
+
+INLINE_API void OCPayloadLogRep(LogLevel level, OCRepPayload* payload)
+{
+    OCSAMPLE_LOG_INFO(PL_TAG, 0, "Payload Type: Representation");
+    uint32_t i = 1;
+    for (OCRepPayload* rep = payload; rep; rep = rep->next, ++i)
+    {
+        OCSAMPLE_LOG_INFO(PL_TAG, 0, "    Resource #%d", i);
+        if (rep->uri)
+        {
+            OCSAMPLE_LOG_INFO(PL_TAG, 0, "    URI:%s", rep->uri);
+        }
+        if (rep->types)
+        {
+            OCSAMPLE_LOG_INFO(PL_TAG, 0,  "    Resource Types:");
+            for (OCStringLL* strll = rep->types; strll; strll = strll->next)
+            {
+                OCSAMPLE_LOG_INFO(PL_TAG, 0, "        %s", strll->value);
+            }
+        }
+        if (rep->interfaces)
+        {
+            OCSAMPLE_LOG_INFO(PL_TAG, 0,  "    Interfaces:");
+            for (OCStringLL* strll = rep->interfaces; strll; strll = strll->next)
+            {
+                OCSAMPLE_LOG_INFO(PL_TAG, 0, "        %s", strll->value);
+            }
+        }
+        OCSAMPLE_LOG_INFO(PL_TAG, 0,  "    Values:");
+        OCPayloadLogRepValues(level, rep->values);
+    }
+}
+
+static void OCStringLLPrint(LogLevel level, OCStringLL *type)
+{
+    for (OCStringLL *strll = type; strll; strll = strll->next)
+    {
+        OCSAMPLE_LOG_INFO(PL_TAG, 0, "         %s", strll->value);
+    }
+}
+
+INLINE_API void OCPayloadLogDiscovery(LogLevel level, OCDiscoveryPayload* payload)
+{
+    OCSAMPLE_LOG_INFO(PL_TAG, 0,  "Payload Type: Discovery");
+
+    while(payload && payload->resources)
+    {
+        OCSAMPLE_LOG_INFO(PL_TAG, 0, "    DI: %s", payload->sid);
+        if (payload->name)
+        {
+            OCSAMPLE_LOG_INFO(PL_TAG, 0, "    NAME: %s", payload->name);
+        }
+
+        if (payload->type)
+        {
+            OCSAMPLE_LOG_INFO(PL_TAG, 0,  "    Resource Type:");
+            OCStringLLPrint(level, payload->type);
+        }
+
+        if (payload->iface)
+        {
+            OCSAMPLE_LOG_INFO(PL_TAG, 0,  "    Interface:");
+            OCStringLLPrint(level, payload->iface);
+        }
+
+        OCResourcePayload* res = payload->resources;
+
+        uint32_t i = 1;
+        while(res)
+        {
+            OCSAMPLE_LOG_INFO(PL_TAG, 0, "    Link#%d", i);
+            OCSAMPLE_LOG_INFO(PL_TAG, 0, "    URI:%s", res->uri);
+            if (res->rel)
+            {
+                OCSAMPLE_LOG_INFO(PL_TAG, 0, "    Relation:%s", res->rel);
+            }
+            if (res->anchor)
+            {
+                OCSAMPLE_LOG_INFO(PL_TAG, 0, "    Anchor:%s", res->anchor);
+            }
+            OCSAMPLE_LOG_INFO(PL_TAG, 0,  "    Resource Types:");
+            OCStringLL* strll =  res->types;
+            while(strll)
+            {
+                OCSAMPLE_LOG_INFO(PL_TAG, 0, "        %s", strll->value);
+                strll = strll->next;
+            }
+            OCSAMPLE_LOG_INFO(PL_TAG, 0,  "    Interfaces:");
+            strll =  res->interfaces;
+            while(strll)
+            {
+                OCSAMPLE_LOG_INFO(PL_TAG, 0, "        %s", strll->value);
+                strll = strll->next;
+            }
+
+            OCSAMPLE_LOG_INFO(PL_TAG, 0, "    Bitmap: %u", res->bitmap);
+            OCSAMPLE_LOG_INFO(PL_TAG, 0, "    Secure?: %s", res->secure ? "true" : "false");
+            OCSAMPLE_LOG_INFO(PL_TAG, 0, "    Port: %u", res->port);
+
+            uint32_t j = 1;
+            OCEndpointPayload* eps = res->eps;
+            while (eps)
+            {
+                OCSAMPLE_LOG_INFO(PL_TAG, 0, "    Endpoint #%d", j);
+                OCSAMPLE_LOG_INFO(PL_TAG, 0, "        tps: %s", eps->tps);
+                OCSAMPLE_LOG_INFO(PL_TAG, 0, "        addr: %s", eps->addr);
+                OCSAMPLE_LOG_INFO(PL_TAG, 0, "        port: %d", eps->port);
+                OCSAMPLE_LOG_INFO(PL_TAG, 0, "        pri: %d", eps->pri);
+                eps = eps->next;
+                ++j;
+            }
+
+            OCSAMPLE_LOG_INFO(PL_TAG, 0,  "");
+            res = res->next;
+            ++i;
+        }
+        payload = payload->next;
+    }
+}
+
+INLINE_API void OCPayloadLogPresence(LogLevel level, OCPresencePayload* payload)
+{
+    OCSAMPLE_LOG_INFO(PL_TAG, 0,  "Payload Type: Presence");
+    OCSAMPLE_LOG_INFO(PL_TAG, 0, "    Sequence Number:%u", payload->sequenceNumber);
+    OCSAMPLE_LOG_INFO(PL_TAG, 0, "    Max Age:%d", payload->maxAge);
+    OCSAMPLE_LOG_INFO(PL_TAG, 0, "    Trigger:%s", convertTriggerEnumToString(payload->trigger));
+    OCSAMPLE_LOG_INFO(PL_TAG, 0, "    Resource Type:%s", payload->resourceType);
+}
+
+INLINE_API void OCPayloadLogSecurity(LogLevel level, OCSecurityPayload* payload)
+{
+    size_t payloadSize = payload->payloadSize;
+    OCSAMPLE_LOG_INFO(PL_TAG, 0,  "Payload Type: Security");
+
+    if (payloadSize > 0)
+    {
+        // Add a zero-character string terminator.
+        char *securityData = (char *)OICMalloc(payloadSize + 1);
+
+        if (securityData)
+        {
+            memcpy(securityData, payload->securityData, payloadSize);
+            // assert(securityData[payloadSize - 1] != '\0');
+            securityData[payloadSize] = '\0';
+            OCSAMPLE_LOG_INFO(PL_TAG, 0, "    Security Data: %s", securityData);
+            OICFree(securityData);
+        }
+    }
+}
+
+INLINE_API void OCPayloadLog(LogLevel level, OCPayload* payload)
+{
+    if(!payload)
+    {
+        OCSAMPLE_LOG_INFO(PL_TAG, 0,  "NULL Payload");
+        return;
+    }
+    switch(payload->type)
+    {
+        case PAYLOAD_TYPE_REPRESENTATION:
+            OCPayloadLogRep(level, (OCRepPayload*)payload);
+            break;
+        case PAYLOAD_TYPE_DISCOVERY:
+            OCPayloadLogDiscovery(level, (OCDiscoveryPayload*)payload);
+            break;
+        case PAYLOAD_TYPE_PRESENCE:
+            OCPayloadLogPresence(level, (OCPresencePayload*)payload);
+            break;
+        case PAYLOAD_TYPE_SECURITY:
+            OCPayloadLogSecurity(level, (OCSecurityPayload*)payload);
+            break;
+        default:
+            OCSAMPLE_LOG_INFO(PL_TAG, 0, "Unknown Payload Type: %d", payload->type);
+            break;
+    }
+}
+#else
+    #define OCSAMPLE_LOG_PAYLOAD(level, payload)
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/resource/csdk/stack/samples/webos/unsecure/ocserver/SConscript b/resource/csdk/stack/samples/webos/unsecure/ocserver/SConscript
new file mode 100644
index 0000000..a88c9a0
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/unsecure/ocserver/SConscript
@@ -0,0 +1,90 @@
+#******************************************************************
+#
+# Copyright (c) 2018 LG Electronics, Inc.
+# Copyright 2014 Intel Mobile Communications GmbH All Rights Reserved.
+#
+#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+Import('stacksamples_env')
+
+samples_env = stacksamples_env.Clone()
+SConscript('#build_common/thread.scons', exports={'thread_env': samples_env})
+
+target_os = samples_env.get('TARGET_OS')
+with_ra = samples_env.get('WITH_RA')
+
+######################################################################
+# Build flags
+######################################################################
+with_upstream_libcoap = samples_env.get('WITH_UPSTREAM_LIBCOAP')
+if with_upstream_libcoap == '1':
+    samples_env.AppendUnique(CPPPATH=['#/extlibs/libcoap/libcoap/include'])
+else:
+    samples_env.AppendUnique(CPPPATH=['#/resource/csdk/connectivity/lib/libcoap-4.1.1/include'])
+
+samples_env.PrependUnique(CPPPATH=[
+    '../../../../../logger/include',
+    '../../../../../include',
+    '../../../../../stack/include',
+    '../../../../../connectivity/api',
+    '../../../../../security/include',
+    '../../../../../../../extlibs/boost/boost',
+    '../../../../../../oc_logger/include',
+    '../'
+])
+
+compiler = samples_env.get('CXX')
+if 'g++' in compiler:
+    samples_env.AppendUnique(CXXFLAGS=['-std=c++0x', '-Wall'])
+
+samples_env.PrependUnique(LIBS=['coap'])
+
+if target_os not in ['msys_nt', 'windows']:
+    samples_env.PrependUnique(LIBS=['connectivity_abstraction'])
+
+samples_env.PrependUnique(LIBS=['octbstack', 'ocsrm'])
+
+if target_os in ['darwin']:
+    samples_env.AppendUnique(LIBS=['routingmanager'])
+
+if target_os not in ['windows', 'darwin', 'ios', 'msys_nt']:
+    samples_env.AppendUnique(LIBS=['rt'])
+
+if target_os not in ['windows']:
+    samples_env.PrependUnique(LIBS=['m'])
+
+if samples_env.get('SECURED') == '1':
+    samples_env.AppendUnique(LIBS=['mbedtls'])
+
+samples_env.AppendUnique(CPPDEFINES=['TB_LOG'])
+
+samples_env.ParseConfig("pkg-config --cflags --libs glib-2.0")
+samples_env.ParseConfig("pkg-config --cflags --libs luna-service2")
+samples_env.ParseConfig("pkg-config --cflags --libs pbnjson_c")
+
+######################################################################
+# Source files and Targets
+######################################################################
+ocserver = samples_env.Program('ocserver', ['ocserver.cpp', '../common.cpp'])
+
+list_of_samples = [
+    ocserver
+]
+
+Alias("samples", list_of_samples)
+
+samples_env.AppendTarget('samples')
diff --git a/resource/csdk/stack/samples/webos/unsecure/ocserver/logging.h b/resource/csdk/stack/samples/webos/unsecure/ocserver/logging.h
new file mode 100644
index 0000000..455b268
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/unsecure/ocserver/logging.h
@@ -0,0 +1,69 @@
+/*******************************************************************
+ *
+ * Copyright (c) 2018 LG Electronics, Inc.
+ *
+ *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+ */
+
+#ifndef __LOGGING_H__
+#define __LOGGING_H__
+
+#include <PmLogLib.h>
+
+extern PmLogContext gLogContext;
+
+/* Logging for ocserverbasciops context ********
+ * The parameters needed are
+ * msgid - unique message id
+ * kvcount - count for key-value pairs
+ * ... - key-value pairs and free text. key-value pairs are formed using PMLOGKS or PMLOGKFV
+ * e.g.)
+ * WCALOG_CRITICAL(msgid, 2, PMLOGKS("key1", "value1"), PMLOGKFV("key2", "%d", value2), "free text message");
+ **********************************************/
+#define OCSAMPLE_LOG_CRITICAL(msgid, kvcount, ...) \
+        PmLogCritical(gLogContext, msgid, kvcount, ##__VA_ARGS__)
+
+#define OCSAMPLE_LOG_ERROR(msgid, kvcount, ...) \
+        PmLogError(gLogContext, msgid, kvcount,##__VA_ARGS__)
+
+#define OCSAMPLE_LOG_WARNING(msgid, kvcount, ...) \
+        PmLogWarning(gLogContext, msgid, kvcount, ##__VA_ARGS__)
+
+#define OCSAMPLE_LOG_INFO(msgid, kvcount, ...) \
+        PmLogInfo(gLogContext, msgid, kvcount, ##__VA_ARGS__)
+
+#define OCSAMPLE_LOG_DEBUG(...) \
+        PmLogDebug(gLogContext, ##__VA_ARGS__)
+
+#define OCSAMPLE_LOG_ESCAPED_ERRMSG(msgid, errmsg) \
+    do { \
+    gchar *escaped_errtext = g_strescape(errmsg, NULL); \
+    WCALOG_ERROR(msgid, 1, PMLOGKS("Error", escaped_errtext), ""); \
+    g_free(escaped_errtext); \
+    } while(0)
+
+#define OCSAMPLE_LOG_ADDR_INFOMSG(msgid, name, addr) \
+    do { \
+    gchar straddr[16]; \
+    snprintf(straddr, 16, "%p", addr); \
+    WCALOG_INFO(msgid, 1, PMLOGKS(name, straddr), ""); \
+    } while(0)
+
+/** list of MSGID's */
+#define MSGID_WIFI_SRVC_REGISTER_FAIL                   "WIFI_SRVC_REGISTER_FAIL"
+
+#endif // __LOGGING_H__
diff --git a/resource/csdk/stack/samples/webos/unsecure/ocserver/ocserver.cpp b/resource/csdk/stack/samples/webos/unsecure/ocserver/ocserver.cpp
new file mode 100644
index 0000000..aedf74b
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/unsecure/ocserver/ocserver.cpp
@@ -0,0 +1,1387 @@
+/*******************************************************************
+ *
+ * Copyright (c) 2018 LG Electronics, Inc.
+ * Copyright 2014 Intel Mobile Communications GmbH All Rights Reserved.
+ *
+ *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+ */
+
+#include "iotivity_config.h"
+#include <stdio.h>
+#include <string.h>
+#include <string>
+#include <stdlib.h>
+#include <signal.h>
+#include "ocstack.h"
+#include "ocpayload.h"
+#include "pinoxmcommon.h"
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#ifdef HAVE_PTHREAD_H
+#include <pthread.h>
+#endif
+#include <array>
+#include "oic_malloc.h"
+#include <getopt.h>
+#include "logger.h"
+#include "ocserver.h"
+#include "common.h"
+#include "oic_string.h"
+
+#include <luna-service2/lunaservice.h>
+#include <pbnjson.h>
+#include "logging.h"
+
+pthread_t threadId_server = NULL;
+static LSHandle *pLsHandle = NULL;
+static GMainLoop *mainloop = NULL;
+
+PmLogContext gLogContext;
+PmLogContext ocserverLogLibContext;
+
+#define VERIFY_SUCCESS(op)                          \
+do                                                  \
+{                                                   \
+    if (op != OC_STACK_OK)                          \
+    {                                               \
+        OCSAMPLE_LOG_CRITICAL(TAG, 0, "%s failed!!", #op);  \
+        goto exit;                                  \
+    }                                               \
+} while(0)
+
+// string length of "/a/light/" + std::numeric_limits<int>::digits10 + '\0'"
+// 9 + 9 + 1 = 19
+const int URI_MAXSIZE = 19;
+
+static int gObserveNotifyType = 3;
+static int gResourceCreateType = ENDPOINT_OPT_NONE;
+
+int gQuitFlag = 0;
+int gLightUnderObservation = 0;
+
+static LightResource Light;
+// This variable determines instance number of the Light resource.
+// Used by POST method to create a new instance of Light resource.
+static int gCurrLightInstance = 0;
+
+static LightResource gLightInstance[SAMPLE_MAX_NUM_POST_INSTANCE];
+
+Observers interestedObservers[SAMPLE_MAX_NUM_OBSERVATIONS];
+
+pthread_t threadId_observe;
+pthread_t threadId_presence;
+
+static bool observeThreadStarted = false;
+
+#ifdef WITH_PRESENCE
+#define NUM_PRESENCE_RESOURCES 2
+#endif
+
+char *gResourceUri = (char *)"/a/light";
+static const char *gDateOfManufacture = "2016-01-15";
+static const char *gDeviceName = "myDeviceName";
+static const char *gFirmwareVersion = "myFirmwareVersion";
+static const char *gManufacturerName = "myName";
+static const char *gOperatingSystemVersion = "myOS";
+static const char *gHardwareVersion = "myHardwareVersion";
+static const char *gPlatformID = "0A3E0D6F-DBF5-404E-8719-D6880042463A";
+static const char *gProtocolIndependentID = "6ef9211d-2d5c-401e-8e5d-4b3af48a054f";
+static const char *gManufacturerLink = "https://www.iotivity.org";
+static const char *gModelNumber = "myModelNumber";
+static const char *gPlatformVersion = "myPlatformVersion";
+static const char *gSupportLink = "https://www.iotivity.org";
+static const char *gSystemTime = "2015-05-15T11.04";
+static const char *gSpecVersion = "ocf.1.1.0";
+static const char *gDataModelVersions = "ocf.res.1.1.0,ocf.sh.1.1.0";
+static const char *gDeviceType = "oic.d.tv";
+
+OCPlatformInfo platformInfo;
+
+OCRepPayload* getPayload(const char* uri, int64_t power, bool state)
+{
+    OCRepPayload* payload = OCRepPayloadCreate();
+    if(!payload)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, PCF("Failed to allocate Payload"));
+        return nullptr;
+    }
+
+    OCRepPayloadSetUri(payload, uri);
+    OCRepPayloadSetPropBool(payload, "state", state);
+    OCRepPayloadSetPropInt(payload, "power", power);
+
+    return payload;
+}
+
+static FILE* server_fopen(const char* path, const char* mode)
+{
+    OCSAMPLE_LOG_DEBUG("Got file open call for %s",path);
+    return fopen(path, mode);
+}
+
+#ifdef SECURED
+void OC_CALL DisplayPinCB(char *pin, size_t pinSize, void *context)
+{
+    OC_UNUSED(context);
+
+    if ((nullptr == pin) || (0 == pinSize))
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "Invalid PIN");
+        return;
+    }
+
+    OCSAMPLE_LOG_INFO(TAG, 0, "============================");
+    OCSAMPLE_LOG_INFO(TAG, 0, "    PIN CODE : %s", pin);
+    OCSAMPLE_LOG_INFO(TAG, 0, "============================");
+}
+
+void OC_CALL ClosePinDisplayCB(void)
+{
+    OCSAMPLE_LOG_INFO(TAG, 0, "============================");
+    OCSAMPLE_LOG_INFO(TAG, 0, "    PIN DISPLAY CLOSED.");
+    OCSAMPLE_LOG_INFO(TAG, 0, "============================");
+}
+#endif
+
+//This function takes the request as an input and returns the response
+OCRepPayload* constructResponse(OCEntityHandlerRequest *ehRequest)
+{
+    if(ehRequest->payload && ehRequest->payload->type != PAYLOAD_TYPE_REPRESENTATION)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, PCF("Incoming payload not a representation"));
+        return nullptr;
+    }
+
+    OCRepPayload* input = reinterpret_cast<OCRepPayload*>(ehRequest->payload);
+
+    LightResource *currLightResource = &Light;
+
+    if (ehRequest->resource == gLightInstance[0].handle)
+    {
+        currLightResource = &gLightInstance[0];
+        gResourceUri = (char *) "a/light/0";
+    }
+    else if (ehRequest->resource == gLightInstance[1].handle)
+    {
+        currLightResource = &gLightInstance[1];
+        gResourceUri = (char *) "a/light/1";
+    }
+
+    if(OC_REST_PUT == ehRequest->method)
+    {
+        // Get pointer to query
+        int64_t pow;
+        if(OCRepPayloadGetPropInt(input, "power", &pow))
+        {
+            currLightResource->power =pow;
+        }
+
+        bool state;
+        if(OCRepPayloadGetPropBool(input, "state", &state))
+        {
+            currLightResource->state = state;
+        }
+    }
+
+    return getPayload(gResourceUri, currLightResource->power, currLightResource->state);
+}
+
+/*
+ * Very simple example of query parsing.
+ * The query may have multiple filters separated by ';'.
+ * It is upto the entity handler to parse the query for the individual filters,
+ * VALIDATE them and respond as it sees fit.
+
+ * This function only returns false if the query is exactly "power<X" and
+ * current power is greater than X. If X cannot be parsed for an int,
+ * true is returned.
+ */
+bool checkIfQueryForPowerPassed(char * query)
+{
+    if (query && strncmp(query, "power<", strlen("power<")) == 0)
+    {
+        char * pointerToOperator = strstr(query, "<");
+
+        if (pointerToOperator)
+        {
+            int64_t powerRequested;
+            int matchedItems = sscanf((pointerToOperator + 1), "%" SCNd64, &powerRequested);
+
+            if (1 != matchedItems)
+            {
+                return true;
+            }
+
+            if (Light.power > powerRequested)
+            {
+                OCSAMPLE_LOG_INFO(TAG, 0, "Current power: %" PRId64 ". Requested: <%" PRId64, Light.power,
+                          powerRequested);
+                return false;
+            }
+        }
+    }
+    return true;
+}
+
+/*
+ * Application should validate and process these as desired.
+ */
+OCEntityHandlerResult ValidateQueryParams (OCEntityHandlerRequest *entityHandlerRequest)
+{
+    OCSAMPLE_LOG_INFO(TAG, 0, PCF("Received query %s"), entityHandlerRequest->query);
+    OCSAMPLE_LOG_INFO(TAG, 0, PCF("Not processing query"));
+    return OC_EH_OK;
+}
+
+OCEntityHandlerResult ProcessGetRequest (OCEntityHandlerRequest *ehRequest,
+        OCRepPayload **payload)
+{
+    OCEntityHandlerResult ehResult;
+    bool queryPassed = checkIfQueryForPowerPassed(ehRequest->query);
+
+    // Empty payload if the query has no match.
+    if (queryPassed)
+    {
+        OCRepPayload *getResp = constructResponse(ehRequest);
+        if(!getResp)
+        {
+            OCSAMPLE_LOG_ERROR(TAG, 0, "constructResponse failed");
+            return OC_EH_ERROR;
+        }
+
+        *payload = getResp;
+        ehResult = OC_EH_OK;
+    }
+    else
+    {
+        ehResult = OC_EH_OK;
+    }
+
+    return ehResult;
+}
+
+OCEntityHandlerResult ProcessPutRequest (OCEntityHandlerRequest *ehRequest,
+        OCRepPayload** payload)
+{
+    OCEntityHandlerResult ehResult;
+    OCRepPayload *putResp = constructResponse(ehRequest);
+
+    if(!putResp)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Failed to construct Json response");
+        return OC_EH_ERROR;
+    }
+
+    *payload = putResp;
+    ehResult = OC_EH_OK;
+
+    return ehResult;
+}
+
+OCEntityHandlerResult ProcessPostRequest (OCEntityHandlerRequest *ehRequest,
+        OCEntityHandlerResponse *response, OCRepPayload** payload)
+{
+    OCEntityHandlerResult ehResult = OC_EH_OK;
+    OCRepPayload *respPLPost_light = nullptr;
+
+    /*
+     * The entity handler determines how to process a POST request.
+     * Per the REST paradigm, POST can also be used to update representation of existing
+     * resource or create a new resource.
+     * In the sample below, if the POST is for /a/light then a new instance of the Light
+     * resource is created with default representation (if representation is included in
+     * POST payload it can be used as initial values) as long as the instance is
+     * lesser than max new instance count. Once max instance count is reached, POST on
+     * /a/light updated the representation of /a/light (just like PUT)
+     */
+
+    if (ehRequest->resource == Light.handle)
+    {
+        if (gCurrLightInstance < SAMPLE_MAX_NUM_POST_INSTANCE)
+        {
+            // Create new Light instance
+            char newLightUri[URI_MAXSIZE];
+            snprintf(newLightUri, URI_MAXSIZE, "/a/light/%d", gCurrLightInstance);
+
+            respPLPost_light = OCRepPayloadCreate();
+            OCRepPayloadSetUri(respPLPost_light, gResourceUri);
+            OCRepPayloadSetPropString(respPLPost_light, "createduri", newLightUri);
+
+            if (0 == createLightResource (newLightUri, &gLightInstance[gCurrLightInstance]))
+            {
+                OCSAMPLE_LOG_INFO(TAG, 0, "Created new Light instance\n");
+                gLightInstance[gCurrLightInstance].state = 0;
+                gLightInstance[gCurrLightInstance].power = 0;
+                gCurrLightInstance++;
+                strncpy ((char *)response->resourceUri, newLightUri, MAX_URI_LENGTH);
+                ehResult = OC_EH_RESOURCE_CREATED;
+            }
+        }
+        else
+        {
+            // Update repesentation of /a/light
+            Light.state = true;
+            Light.power = 11;
+            respPLPost_light = constructResponse(ehRequest);
+        }
+    }
+    else
+    {
+        for (int i = 0; i < SAMPLE_MAX_NUM_POST_INSTANCE; i++)
+        {
+            if (ehRequest->resource == gLightInstance[i].handle)
+            {
+                gLightInstance[i].state = true;
+                gLightInstance[i].power = 22;
+                if (i == 0)
+                {
+                    respPLPost_light = constructResponse(ehRequest);
+                    break;
+                }
+                else if (i == 1)
+                {
+                    respPLPost_light = constructResponse(ehRequest);
+                }
+            }
+        }
+    }
+
+    if ((respPLPost_light != NULL))
+    {
+        *payload = respPLPost_light;
+    }
+    else
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "Payload was NULL");
+        ehResult = OC_EH_ERROR;
+    }
+
+    return ehResult;
+}
+
+OCEntityHandlerResult ProcessDeleteRequest (OCEntityHandlerRequest *ehRequest)
+{
+    if(ehRequest == NULL)
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "The ehRequest is NULL");
+        return OC_EH_ERROR;
+    }
+    OCEntityHandlerResult ehResult = OC_EH_OK;
+
+    OCSAMPLE_LOG_INFO(TAG, 0, "\n\nExecuting %s for resource %p ", __func__, ehRequest->resource);
+
+    /*
+     * In the sample below, the application will:
+     * 1a. pass the delete request to the c stack
+     * 1b. internally, the c stack figures out what needs to be done and does it accordingly
+     *    (e.g. send observers notification, remove observers...)
+     * 1c. the c stack returns with the result whether the request is fullfilled.
+     * 2. optionally, app removes observers out of its array 'interestedObservers'
+     */
+
+    if ((ehRequest != NULL) && (ehRequest->resource == Light.handle))
+    {
+        //Step 1: Ask stack to do the work.
+        OCStackResult result = OCDeleteResource(ehRequest->resource);
+
+        if (result == OC_STACK_OK)
+        {
+            OCSAMPLE_LOG_INFO(TAG, 0, "\n\nDelete Resource operation succeeded.");
+            ehResult = OC_EH_RESOURCE_DELETED;
+
+            //Step 2: clear observers who wanted to observe this resource at the app level.
+            for (uint8_t i = 0; i < SAMPLE_MAX_NUM_OBSERVATIONS; i++)
+            {
+                if (interestedObservers[i].resourceHandle == ehRequest->resource)
+                {
+                    interestedObservers[i].valid = false;
+                    interestedObservers[i].observationId = 0;
+                    interestedObservers[i].resourceHandle = NULL;
+                }
+            }
+        }
+        else if (result == OC_STACK_NO_RESOURCE)
+        {
+            OCSAMPLE_LOG_INFO(TAG, 0, "\n\nThe resource doesn't exist or it might have been deleted.");
+            ehResult = OC_EH_RESOURCE_NOT_FOUND;
+        }
+        else
+        {
+            OCSAMPLE_LOG_INFO(TAG, 0, "\n\nEncountered error from OCDeleteResource().");
+            ehResult = OC_EH_ERROR;
+        }
+    }
+    else if (ehRequest->resource != Light.handle)
+    {
+        //Let's this app not supporting DELETE on some resources so
+        //consider the DELETE request is received for a non-support resource.
+        OCSAMPLE_LOG_INFO(TAG, 0, "\n\nThe request is received for a non-support resource.");
+        ehResult = OC_EH_FORBIDDEN;
+    }
+
+    return ehResult;
+}
+
+OCEntityHandlerResult ProcessNonExistingResourceRequest(OCEntityHandlerRequest * /*ehRequest*/)
+{
+    OCSAMPLE_LOG_INFO(TAG, 0, "\n\nExecuting %s ", __func__);
+
+    return OC_EH_RESOURCE_NOT_FOUND;
+}
+
+void ProcessObserveRegister (OCEntityHandlerRequest *ehRequest)
+{
+    OCSAMPLE_LOG_INFO(TAG, 0, "Received observation registration request with observation Id %d",
+            ehRequest->obsInfo.obsId);
+
+    if (!observeThreadStarted)
+    {
+        pthread_create (&threadId_observe, NULL, ChangeLightRepresentation, (void *)NULL);
+        observeThreadStarted = 1;
+    }
+    for (uint8_t i = 0; i < SAMPLE_MAX_NUM_OBSERVATIONS; i++)
+    {
+        if (interestedObservers[i].valid == false)
+        {
+            interestedObservers[i].observationId = ehRequest->obsInfo.obsId;
+            interestedObservers[i].valid = true;
+            gLightUnderObservation = 1;
+            break;
+        }
+    }
+}
+
+void ProcessObserveDeregister (OCEntityHandlerRequest *ehRequest)
+{
+    bool clientStillObserving = false;
+
+    OCSAMPLE_LOG_INFO(TAG, 0, "Received observation deregistration request for observation Id %d",
+            ehRequest->obsInfo.obsId);
+    for (uint8_t i = 0; i < SAMPLE_MAX_NUM_OBSERVATIONS; i++)
+    {
+        if (interestedObservers[i].observationId == ehRequest->obsInfo.obsId)
+        {
+            interestedObservers[i].valid = false;
+        }
+        if (interestedObservers[i].valid == true)
+        {
+            // Even if there is one single client observing we continue notifying entity handler
+            clientStillObserving = true;
+        }
+    }
+    if (clientStillObserving == false)
+    {
+        gLightUnderObservation = 0;
+    }
+}
+
+OCEntityHandlerResult
+OCDeviceEntityHandlerCb (OCEntityHandlerFlag flag,
+                         OCEntityHandlerRequest *entityHandlerRequest,
+                         char* uri,
+                         void* /*callbackParam*/)
+{
+    OCSAMPLE_LOG_INFO(TAG, 0, "Inside device default entity handler - flags: 0x%x, uri: %s", flag, uri);
+
+    OCEntityHandlerResult ehResult = OC_EH_OK;
+    OCEntityHandlerResponse response;
+
+    // Validate pointer
+    if (!entityHandlerRequest)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Invalid request pointer");
+        return OC_EH_ERROR;
+    }
+    // Initialize certain response fields
+    response.numSendVendorSpecificHeaderOptions = 0;
+    memset(response.sendVendorSpecificHeaderOptions, 0,
+            sizeof response.sendVendorSpecificHeaderOptions);
+    memset(response.resourceUri, 0, sizeof response.resourceUri);
+    OCRepPayload* payload = nullptr;
+
+
+    if (flag & OC_REQUEST_FLAG)
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "Flag includes OC_REQUEST_FLAG");
+
+        if (entityHandlerRequest->resource == NULL)
+        {
+            OCSAMPLE_LOG_INFO(TAG, 0, "Received request from client to a non-existing resource");
+            ehResult = ProcessNonExistingResourceRequest(entityHandlerRequest);
+        }
+        else if (OC_REST_GET == entityHandlerRequest->method)
+        {
+            OCSAMPLE_LOG_INFO(TAG, 0, "Received OC_REST_GET from client");
+            ehResult = ProcessGetRequest (entityHandlerRequest, &payload);
+        }
+        else if (OC_REST_PUT == entityHandlerRequest->method)
+        {
+            OCSAMPLE_LOG_INFO(TAG, 0, "Received OC_REST_PUT from client");
+            ehResult = ProcessPutRequest (entityHandlerRequest, &payload);
+        }
+        else if (OC_REST_DELETE == entityHandlerRequest->method)
+        {
+            OCSAMPLE_LOG_INFO(TAG, 0, "Received OC_REST_DELETE from client");
+            ehResult = ProcessDeleteRequest (entityHandlerRequest);
+        }
+        else
+        {
+            OCSAMPLE_LOG_INFO(TAG, 0, "Received unsupported method %d from client",
+                      entityHandlerRequest->method);
+            ehResult = OC_EH_ERROR;
+        }
+               // If the result isn't an error or forbidden, send response
+        if (!((ehResult == OC_EH_ERROR) || (ehResult == OC_EH_FORBIDDEN)))
+        {
+            // Format the response.  Note this requires some info about the request
+            response.requestHandle = entityHandlerRequest->requestHandle;
+            response.resourceHandle = entityHandlerRequest->resource;
+            response.ehResult = ehResult;
+            response.payload = reinterpret_cast<OCPayload*>(payload);
+            // Indicate that response is NOT in a persistent buffer
+            response.persistentBufferFlag = 0;
+
+            // Send the response
+            if (OCDoResponse(&response) != OC_STACK_OK)
+            {
+                OCSAMPLE_LOG_ERROR(TAG, 0, "Error sending response");
+                ehResult = OC_EH_ERROR;
+            }
+        }
+    }
+    if (flag & OC_OBSERVE_FLAG)
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "Flag includes OC_OBSERVE_FLAG");
+        if (OC_OBSERVE_REGISTER == entityHandlerRequest->obsInfo.action)
+        {
+            OCSAMPLE_LOG_INFO(TAG, 0, "Received OC_OBSERVE_REGISTER from client");
+        }
+        else if (OC_OBSERVE_DEREGISTER == entityHandlerRequest->obsInfo.action)
+        {
+            OCSAMPLE_LOG_INFO(TAG, 0, "Received OC_OBSERVE_DEREGISTER from client");
+        }
+    }
+
+    OCPayloadDestroy(response.payload);
+    return ehResult;
+}
+
+OCEntityHandlerResult
+OCNOPEntityHandlerCb (OCEntityHandlerFlag /*flag*/,
+                      OCEntityHandlerRequest * /*entityHandlerRequest*/,
+                      void* /*callbackParam*/)
+{
+    // This is callback is associated with the 2 presence notification
+    // resources. They are non-operational.
+    return OC_EH_OK;
+}
+
+OCEntityHandlerResult
+OCEntityHandlerCb (OCEntityHandlerFlag flag,
+        OCEntityHandlerRequest *entityHandlerRequest, void* /*callback*/)
+{
+    OCSAMPLE_LOG_INFO(TAG, 0, "Inside entity handler - flags: 0x%x", flag);
+
+    OCEntityHandlerResult ehResult = OC_EH_OK;
+    OCEntityHandlerResponse response = { 0, 0, OC_EH_ERROR, 0, 0, { },{ 0 }, false };
+
+    // Validate pointer
+    if (!entityHandlerRequest)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Invalid request pointer");
+        return OC_EH_ERROR;
+    }
+
+    // Initialize certain response fields
+    response.numSendVendorSpecificHeaderOptions = 0;
+    memset(response.sendVendorSpecificHeaderOptions,
+            0, sizeof response.sendVendorSpecificHeaderOptions);
+    memset(response.resourceUri, 0, sizeof response.resourceUri);
+    OCRepPayload* payload = nullptr;
+
+    if (flag & OC_REQUEST_FLAG)
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "Flag includes OC_REQUEST_FLAG");
+
+        if (OC_REST_GET == entityHandlerRequest->method)
+        {
+            OCSAMPLE_LOG_INFO(TAG, 0, "Received OC_REST_GET from client");
+            ehResult = ProcessGetRequest (entityHandlerRequest, &payload);
+        }
+        else if (OC_REST_PUT == entityHandlerRequest->method)
+        {
+            OCSAMPLE_LOG_INFO(TAG, 0, "Received OC_REST_PUT from client");
+            ehResult = ProcessPutRequest (entityHandlerRequest, &payload);
+        }
+        else if (OC_REST_POST == entityHandlerRequest->method)
+        {
+            OCSAMPLE_LOG_INFO(TAG, 0, "Received OC_REST_POST from client");
+            ehResult = ProcessPostRequest (entityHandlerRequest, &response, &payload);
+        }
+        else if (OC_REST_DELETE == entityHandlerRequest->method)
+        {
+            OCSAMPLE_LOG_INFO(TAG, 0, "Received OC_REST_DELETE from client");
+            ehResult = ProcessDeleteRequest (entityHandlerRequest);
+        }
+        else
+        {
+            OCSAMPLE_LOG_INFO(TAG, 0, "Received unsupported method %d from client",
+                      entityHandlerRequest->method);
+            ehResult = OC_EH_ERROR;
+        }
+        // If the result isn't an error or forbidden, send response
+        if (!((ehResult == OC_EH_ERROR) || (ehResult == OC_EH_FORBIDDEN)))
+        {
+            // Format the response.  Note this requires some info about the request
+            response.requestHandle = entityHandlerRequest->requestHandle;
+            response.resourceHandle = entityHandlerRequest->resource;
+            response.ehResult = ehResult;
+            response.payload = reinterpret_cast<OCPayload*>(payload);
+            // Indicate that response is NOT in a persistent buffer
+            response.persistentBufferFlag = 0;
+
+            // Handle vendor specific options
+            if(entityHandlerRequest->rcvdVendorSpecificHeaderOptions &&
+                    entityHandlerRequest->numRcvdVendorSpecificHeaderOptions)
+            {
+                OCSAMPLE_LOG_INFO(TAG, 0, "Received vendor specific options");
+                uint8_t i = 0;
+                OCHeaderOption * rcvdOptions =
+                        entityHandlerRequest->rcvdVendorSpecificHeaderOptions;
+                for( i = 0; i < entityHandlerRequest->numRcvdVendorSpecificHeaderOptions; i++)
+                {
+                    if(((OCHeaderOption)rcvdOptions[i]).protocolID == OC_COAP_ID)
+                    {
+                        OCSAMPLE_LOG_INFO(TAG, 0, "Received option with OC_COAP_ID and ID %u with",
+                                ((OCHeaderOption)rcvdOptions[i]).optionID );
+
+                        OIC_LOG_BUFFER(INFO, TAG, ((OCHeaderOption)rcvdOptions[i]).optionData,
+                            MAX_HEADER_OPTION_DATA_LENGTH);
+                    }
+                }
+                // Check on Accept Version option.
+                uint8_t vOptionData[MAX_HEADER_OPTION_DATA_LENGTH];
+                size_t vOptionDataSize = sizeof(vOptionData);
+                uint16_t actualDataSize = 0;
+                OCGetHeaderOption(entityHandlerRequest->rcvdVendorSpecificHeaderOptions,
+                        entityHandlerRequest->numRcvdVendorSpecificHeaderOptions,
+                        COAP_OPTION_ACCEPT_VERSION, vOptionData, vOptionDataSize, &actualDataSize);
+                if (actualDataSize)
+                {
+                    OCSAMPLE_LOG_INFO(TAG, 0, "accept version option exists");
+                    OIC_LOG_BUFFER(INFO, TAG, vOptionData, MAX_HEADER_OPTION_DATA_LENGTH);
+                    uint16_t acceptVersion = vOptionData[0]*256 + vOptionData[1];
+                    if (OC_SPEC_VERSION_VALUE == acceptVersion)
+                    {
+                        OCSAMPLE_LOG_INFO(TAG, 0, "accept version equals to default OC_SPEC_VERSION_VALUE.");
+                    }
+                }
+
+                actualDataSize = 0;
+                OCHeaderOption* sendOptions = response.sendVendorSpecificHeaderOptions;
+                size_t numOptions = response.numSendVendorSpecificHeaderOptions;
+                // Check if the option header has already existed before adding it in.
+                uint8_t optionData[MAX_HEADER_OPTION_DATA_LENGTH];
+                size_t optionDataSize = sizeof(optionData);
+
+                actualDataSize = 0;
+                OCGetHeaderOption(response.sendVendorSpecificHeaderOptions,
+                                  response.numSendVendorSpecificHeaderOptions,
+                                  2248,
+                                  optionData,
+                                  optionDataSize,
+                                  &actualDataSize);
+                if (actualDataSize == 0)
+                {
+                    uint8_t option2[] = {21,22,23,24,25,26,27,28,29,30};
+                    uint16_t optionID2 = 2248;
+                    size_t optionDataSize2 = sizeof(option2);
+                    OCSetHeaderOption(sendOptions,
+                                      &numOptions,
+                                      optionID2,
+                                      option2,
+                                      optionDataSize2);
+                }
+
+                actualDataSize = 0;
+                OCGetHeaderOption(response.sendVendorSpecificHeaderOptions,
+                                  response.numSendVendorSpecificHeaderOptions,
+                                  2600,
+                                  optionData,
+                                  optionDataSize,
+                                  &actualDataSize);
+                if (actualDataSize == 0)
+                {
+                    uint8_t option3[] = {31,32,33,34,35,36,37,38,39,40};
+                    uint16_t optionID3 = 2600;
+                    size_t optionDataSize3 = sizeof(option3);
+                    OCSetHeaderOption(sendOptions,
+                                      &numOptions,
+                                      optionID3,
+                                      option3,
+                                      optionDataSize3);
+                }
+            }
+
+            // Send the response
+            if (OCDoResponse(&response) != OC_STACK_OK)
+            {
+                OCSAMPLE_LOG_ERROR(TAG, 0, "Error sending response");
+                ehResult = OC_EH_ERROR;
+            }
+        }
+    }
+    if (flag & OC_OBSERVE_FLAG)
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "Flag includes OC_OBSERVE_FLAG");
+
+        if (OC_OBSERVE_REGISTER == entityHandlerRequest->obsInfo.action)
+        {
+            OCSAMPLE_LOG_INFO(TAG, 0, "Received OC_OBSERVE_REGISTER from client");
+            ProcessObserveRegister (entityHandlerRequest);
+        }
+        else if (OC_OBSERVE_DEREGISTER == entityHandlerRequest->obsInfo.action)
+        {
+            OCSAMPLE_LOG_INFO(TAG, 0, "Received OC_OBSERVE_DEREGISTER from client");
+            ProcessObserveDeregister (entityHandlerRequest);
+        }
+    }
+
+    OCPayloadDestroy(response.payload);
+    return ehResult;
+}
+
+/* SIGINT handler: set gQuitFlag to 1 for graceful termination */
+void handleSigInt(int signum)
+{
+    if (signum == SIGINT)
+    {
+        gQuitFlag = 1;
+        g_main_loop_quit(mainloop);
+    }
+}
+
+void *ChangeLightRepresentation (void *param)
+{
+    (void)param;
+    OCStackResult result = OC_STACK_ERROR;
+
+    uint8_t j = 0;
+    OCObservationId obsNotify[(SAMPLE_MAX_NUM_OBSERVATIONS)/2];
+
+    while (!gQuitFlag)
+    {
+        sleep(3);
+        Light.power += 5;
+        if (gLightUnderObservation)
+        {
+            OCSAMPLE_LOG_INFO(TAG, 0, " =====> Notifying stack of new power level %" PRId64 "\n", Light.power);
+            if (gObserveNotifyType == 1)
+            {
+                // Notify list of observers. Alternate observers on the list will be notified.
+                j = 0;
+                for (uint8_t i = 0; i < SAMPLE_MAX_NUM_OBSERVATIONS; (i=i+2))
+                {
+                    if (interestedObservers[i].valid == true)
+                    {
+                        obsNotify[j] = interestedObservers[i].observationId;
+                        j++;
+                    }
+                }
+
+                OCRepPayload* payload = getPayload(gResourceUri, Light.power, Light.state);
+                result = OCNotifyListOfObservers (Light.handle, obsNotify, j,
+                        payload, OC_NA_QOS);
+                OCRepPayloadDestroy(payload);
+            }
+            else if (gObserveNotifyType == 0)
+            {
+                // Notifying all observers
+                result = OCNotifyAllObservers (Light.handle, OC_NA_QOS);
+                if (OC_STACK_NO_OBSERVERS == result)
+                {
+                    OCSAMPLE_LOG_INFO(TAG, 0,
+                            "=======> No more observers exist, stop sending observations");
+                    gLightUnderObservation = 0;
+                }
+            }
+            else
+            {
+                OCSAMPLE_LOG_ERROR(TAG, 0, "Incorrect notification type selected");
+            }
+        }
+    }
+    return NULL;
+}
+
+#ifdef WITH_PRESENCE
+void *presenceNotificationGenerator(void *param)
+{
+    uint8_t secondsBeforePresence = 10;
+    OCSAMPLE_LOG_INFO(TAG, 0, "Will send out presence in %u seconds", secondsBeforePresence);
+    sleep(secondsBeforePresence);
+    (void)param;
+    OCDoHandle presenceNotificationHandles[NUM_PRESENCE_RESOURCES];
+    OCStackResult res = OC_STACK_OK;
+
+    std::array<std::string, NUM_PRESENCE_RESOURCES> presenceNotificationResources { {
+        std::string("core.fan"),
+        std::string("core.led") } };
+    std::array<std::string, NUM_PRESENCE_RESOURCES> presenceNotificationUris { {
+        std::string("/a/fan"),
+        std::string("/a/led") } };
+
+    for(int i=0; i<NUM_PRESENCE_RESOURCES; i++)
+    {
+        if(res == OC_STACK_OK)
+        {
+            sleep(1);
+            res = OCCreateResource(&presenceNotificationHandles[i],
+                    presenceNotificationResources.at(i).c_str(),
+                    OC_RSRVD_INTERFACE_DEFAULT,
+                    presenceNotificationUris.at(i).c_str(),
+                    OCNOPEntityHandlerCb,
+                    NULL,
+                    OC_DISCOVERABLE|OC_OBSERVABLE);
+        }
+        if(res != OC_STACK_OK)
+        {
+            OCSAMPLE_LOG_ERROR(TAG, 0, "\"Presence Notification Generator\" failed to create resource "
+                    "%s with result %s.", presenceNotificationResources.at(i).c_str(),
+                    getResult(res));
+            break;
+        }
+        OCSAMPLE_LOG_INFO(TAG, 0, PCF("Created %s for presence notification"),
+                                presenceNotificationUris[i].c_str());
+    }
+    sleep(5);
+    for(int i=0; i<NUM_PRESENCE_RESOURCES; i++)
+    {
+        if(res == OC_STACK_OK)
+        {
+            res = OCDeleteResource(presenceNotificationHandles[i]);
+        }
+        if(res != OC_STACK_OK)
+        {
+            OCSAMPLE_LOG_ERROR(TAG, 0, "\"Presence Notification Generator\" failed to delete "\
+                    "resource %s.", presenceNotificationResources.at(i).c_str());
+            break;
+        }
+        OCSAMPLE_LOG_INFO(TAG, 0, PCF("Deleted %s for presence notification"),
+                                presenceNotificationUris[i].c_str());
+    }
+
+    OCSAMPLE_LOG_INFO(TAG, 0, "================ stopping presence");
+    OCStopPresence();
+
+    return NULL;
+}
+#endif
+
+int createLightResource (char *uri, LightResource *lightResource)
+{
+    if (!uri)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Resource URI cannot be NULL");
+        return -1;
+    }
+
+    lightResource->state = false;
+    lightResource->power= 0;
+    OCTpsSchemeFlags endpointFlags = OC_NO_TPS;
+    switch (gResourceCreateType)
+    {
+        case DISPLAY_SUPPORTED_EPS_FLAG:
+        case CREATE_RESOURCE_OC_ALL:
+        // same as OCCreateResource(args...)
+        endpointFlags = OC_ALL;
+        break;
+
+        case CREATE_RESOURCE_OC_COAP:
+        endpointFlags = OC_COAP;
+        break;
+
+#ifdef TCP_ADAPTER
+        case CREATE_RESOURCE_OC_COAP_TCP:
+        endpointFlags = OC_COAP_TCP;
+        break;
+
+        case CREATE_RESOURCE_OC_COAP_WITH_TCP:
+        endpointFlags = (OCTpsSchemeFlags)(OC_COAP | OC_COAP_TCP);
+        break;
+#endif
+        default:
+        endpointFlags = OC_ALL;
+    }
+
+    OCStackResult res = OCCreateResourceWithEp(&(lightResource->handle),
+            "core.light",
+            "oc.mi.def",
+            uri,
+            OCEntityHandlerCb,
+            NULL,
+            OC_DISCOVERABLE|OC_OBSERVABLE,
+            endpointFlags);
+
+    OCSAMPLE_LOG_INFO(TAG, 0, "Created Light resource with result: %s", getResult(res));
+
+    return 0;
+}
+
+void DeletePlatformInfo()
+{
+    free(platformInfo.platformID);
+    free(platformInfo.manufacturerName);
+    free(platformInfo.manufacturerUrl);
+    free(platformInfo.modelNumber);
+    free(platformInfo.dateOfManufacture);
+    free(platformInfo.platformVersion);
+    free(platformInfo.operatingSystemVersion);
+    free(platformInfo.hardwareVersion);
+    free(platformInfo.firmwareVersion);
+    free(platformInfo.supportUrl);
+    free(platformInfo.systemTime);
+}
+
+bool DuplicateString(char** targetString, const char* sourceString)
+{
+    if(!sourceString)
+    {
+        return false;
+    }
+    else
+    {
+        *targetString = (char *) malloc(strlen(sourceString) + 1);
+
+        if(*targetString)
+        {
+            strncpy(*targetString, sourceString, (strlen(sourceString) + 1));
+            return true;
+        }
+    }
+    return false;
+}
+
+OCStackResult SetPlatformInfo(const char* platformID, const char *manufacturerName,
+    const char *manufacturerUrl, const char *modelNumber, const char *dateOfManufacture,
+    const char *platformVersion, const char* operatingSystemVersion, const char* hardwareVersion,
+    const char *firmwareVersion, const char* supportUrl, const char* systemTime)
+{
+
+    bool success = true;
+
+    if(manufacturerName != NULL && (strlen(manufacturerName) > MAX_PLATFORM_NAME_LENGTH))
+    {
+        return OC_STACK_INVALID_PARAM;
+    }
+
+    if(manufacturerUrl != NULL && (strlen(manufacturerUrl) > MAX_PLATFORM_URL_LENGTH))
+    {
+        return OC_STACK_INVALID_PARAM;
+    }
+
+    if(!DuplicateString(&platformInfo.platformID, platformID))
+    {
+        success = false;
+    }
+
+    if(!DuplicateString(&platformInfo.manufacturerName, manufacturerName))
+    {
+        success = false;
+    }
+
+    if(!DuplicateString(&platformInfo.manufacturerUrl, manufacturerUrl))
+    {
+        success = false;
+    }
+
+    if(!DuplicateString(&platformInfo.modelNumber, modelNumber))
+    {
+        success = false;
+    }
+
+    if(!DuplicateString(&platformInfo.dateOfManufacture, dateOfManufacture))
+    {
+        success = false;
+    }
+
+    if(!DuplicateString(&platformInfo.platformVersion, platformVersion))
+    {
+        success = false;
+    }
+
+    if(!DuplicateString(&platformInfo.operatingSystemVersion, operatingSystemVersion))
+    {
+        success = false;
+    }
+
+    if(!DuplicateString(&platformInfo.hardwareVersion, hardwareVersion))
+    {
+        success = false;
+    }
+
+    if(!DuplicateString(&platformInfo.firmwareVersion, firmwareVersion))
+    {
+        success = false;
+    }
+
+    if(!DuplicateString(&platformInfo.supportUrl, supportUrl))
+    {
+        success = false;
+    }
+
+    if(!DuplicateString(&platformInfo.systemTime, systemTime))
+    {
+        success = false;
+    }
+
+    if(success)
+    {
+        return OC_STACK_OK;
+    }
+
+    DeletePlatformInfo();
+    return OC_STACK_ERROR;
+}
+
+OCStackResult SetDeviceInfo()
+{
+    OCResourceHandle resourceHandle = OCGetResourceHandleAtUri(OC_RSRVD_DEVICE_URI);
+    if (resourceHandle == NULL)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Device Resource does not exist.");
+        goto exit;
+    }
+
+    VERIFY_SUCCESS(OCBindResourceTypeToResource(resourceHandle, gDeviceType));
+    VERIFY_SUCCESS(OCSetPropertyValue(PAYLOAD_TYPE_DEVICE, OC_RSRVD_DEVICE_NAME, gDeviceName));
+    VERIFY_SUCCESS(OCSetPropertyValue(PAYLOAD_TYPE_DEVICE, OC_RSRVD_SPEC_VERSION, gSpecVersion));
+    VERIFY_SUCCESS(OCSetPropertyValue(PAYLOAD_TYPE_DEVICE, OC_RSRVD_DATA_MODEL_VERSION,
+                                      gDataModelVersions));
+    VERIFY_SUCCESS(OCSetPropertyValue(PAYLOAD_TYPE_DEVICE, OC_RSRVD_PROTOCOL_INDEPENDENT_ID,
+                                      gProtocolIndependentID));
+
+    OCSAMPLE_LOG_INFO(TAG, 0, "Device information initialized successfully.");
+    return OC_STACK_OK;
+
+exit:
+    return OC_STACK_ERROR;
+}
+
+static void PrintUsage()
+{
+    printf("Usage : ocserver -o <0|1>\n");
+    printf("-o 0 : Notify all observers\n");
+    printf("-o 1 : Notify list of observers\n");
+    printf("-e 0 : Display supported endpoint flags\n");
+    printf("-e 1 : Create resource without endpoint flags\n");
+    printf("-e 2 : Create resource with endpoint flag OC_COAP\n");
+#ifdef TCP_ADAPTER
+    printf("-e 3 : Create resource with endpoint flag OC_COAP_TCP\n");
+    printf("-e 4 : Create resource with endpoint flag OC_COAP | OC_COAP_TCP\n");
+#endif
+}
+
+#ifdef RA_ADAPTER
+static void jidbound(char *jid)
+{
+    OCSAMPLE_LOG_INFO(TAG, 0, "\n\n    Bound JID: %s\n\n", jid);
+}
+#endif
+
+void *serverStarter(void *param)
+{
+    OCSAMPLE_LOG_INFO(TAG, 0, "Entering ocserver main loop...");
+    while (!gQuitFlag)
+    {
+        if (OCProcess() != OC_STACK_OK)
+        {
+            OCSAMPLE_LOG_ERROR(TAG, 0, "OCStack process error");
+            return 0;
+        }
+        sleep(1);
+    }
+}
+
+int main(int argc, char* argv[])
+{
+
+#ifdef RA_ADAPTER
+    char host[] = "localhost";
+    char user[] = "test1";
+    char pass[] = "intel123";
+    char empstr[] = "";
+    OCRAInfo_t rainfo = {};
+
+    rainfo.hostname = host;
+    rainfo.port = 5222;
+    rainfo.xmpp_domain = host;
+    rainfo.username = user;
+    rainfo.password = pass;
+    rainfo.resource = empstr;
+    rainfo.user_jid = empstr;
+    rainfo.jidbound = jidbound;
+#endif
+
+    int opt = 0;
+    while ((opt = getopt(argc, argv, "o:e:s:p:d:u:w:r:j:")) != -1)
+    {
+        switch(opt)
+        {
+            case 'o':
+                gObserveNotifyType = atoi(optarg);
+                break;
+            case 'e':
+                gResourceCreateType = atoi(optarg);
+                break;
+#ifdef RA_ADAPTER
+            case 's':
+                rainfo.hostname = optarg;
+                break;
+            case 'p':
+                rainfo.port = atoi(optarg);
+                break;
+            case 'd':
+                rainfo.xmpp_domain = optarg;
+                break;
+            case 'u':
+                rainfo.username = optarg;
+                break;
+            case 'w':
+                rainfo.password = optarg;
+                break;
+            case 'j':
+                rainfo.user_jid = optarg;
+                break;
+            case 'r':
+                rainfo.resource = optarg;
+                break;
+#endif
+            default:
+                PrintUsage();
+                return -1;
+        }
+    }
+
+    if ((gObserveNotifyType != 0) && (gObserveNotifyType != 1) &&
+         gResourceCreateType == ENDPOINT_OPT_NONE)
+    {
+        PrintUsage();
+        return -1;
+    }
+
+    if (gResourceCreateType < DISPLAY_SUPPORTED_EPS_FLAG ||
+        gResourceCreateType > ENDPOINT_OPT_NONE)
+    {
+        PrintUsage();
+        return -1;
+    }
+
+#ifdef RA_ADAPTER
+    OCSetRAInfo(&rainfo);
+#endif
+
+#ifdef __webos__
+    LSError lserror;
+    LSErrorInit(&lserror);
+
+    (void) PmLogGetContext("OCSERVER", &gLogContext);
+    (void) PmLogGetContext("OCSERVER-LIB", &ocserverLogLibContext);
+    PmLogSetLibContext(ocserverLogLibContext);
+
+    mainloop = g_main_loop_new(NULL, FALSE);
+
+    // Initialize g_main_loop
+    if (!mainloop) {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Failed to create main loop");
+        return 0;
+    }
+
+    if (!LSRegister("org.ocf.webossample.ocserver", &pLsHandle, &lserror)) {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Failed to register LS Handle");
+        LSErrorLog(gLogContext, "LS_SRVC_ERROR", &lserror);
+        return 0;
+    }
+
+    if (!LSGmainAttach(pLsHandle, mainloop, &lserror)) {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Failed to attach main loop");
+        LSErrorLog(gLogContext, "LS_SRVC_ERROR", &lserror);
+        return 0;
+    }
+
+#endif // __webos__
+
+    OCSAMPLE_LOG_INFO(TAG, 0, "OCServer is starting...");
+    OCPersistentStorage pstStr {
+        server_fopen,
+        fread,
+        fwrite,
+        fclose,
+        unlink
+    };
+    if (OC_STACK_OK != OCRegisterPersistentStorageHandler(&pstStr))
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "OCRegisterPersistentStorageHandler error");
+        return -1;
+    }
+
+    if (OCInit(NULL, 0, OC_SERVER) != OC_STACK_OK)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "OCStack init error");
+        return 0;
+    }
+#ifdef WITH_PRESENCE
+    if (OCStartPresence(0) != OC_STACK_OK)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "OCStack presence/discovery error");
+        return 0;
+    }
+#endif
+
+#ifdef SECURED
+    // Set callbacks for handling pin display
+    if (OC_STACK_OK != SetDisplayPinWithContextCB(DisplayPinCB, NULL))
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Failed to set display pin callback");
+        return 0;
+    }
+
+    SetClosePinDisplayCB(ClosePinDisplayCB);
+
+    // Specify the type and length of the pin that will be generated upon request
+    if (OC_STACK_OK != SetRandomPinPolicy(8, NUM_PIN))
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Failed to set PIN policy");
+        return 0;
+    }
+#endif
+
+    if (DISPLAY_SUPPORTED_EPS_FLAG == gResourceCreateType)
+    {
+        char strBuff[SAMPLE_MAX_STR_BUFF_SIZE] = {0};
+        OCTpsSchemeFlags deviceFlags = OCGetSupportedEndpointTpsFlags();
+
+        if (deviceFlags & OC_COAP)
+        {
+            OICStrcat(strBuff, sizeof(strBuff), "OC_COAP");
+        }
+        if (deviceFlags & OC_COAPS)
+        {
+            OICStrcat(strBuff, sizeof(strBuff), ", OC_COAPS");
+        }
+#ifdef TCP_ADAPTER
+        if (deviceFlags & OC_COAP_TCP)
+        {
+            OICStrcat(strBuff, sizeof(strBuff), ", OC_COAP_TCP");
+        }
+        if (deviceFlags & OC_COAPS_TCP)
+        {
+            OICStrcat(strBuff, sizeof(strBuff), ", OC_COAPS_TCP");
+        }
+#endif
+#ifdef EDR_ADAPTER
+        if (deviceFlags & OC_COAP_RFCOMM)
+        {
+            OICStrcat(strBuff, sizeof(strBuff), ", OC_COAP_RFCOMM");
+        }
+#endif
+        OCSAMPLE_LOG_INFO(TAG, 0, "Endpoint flag %s is supported", strBuff);
+        return 0;
+    }
+
+    OCSetDefaultDeviceEntityHandler(OCDeviceEntityHandlerCb, NULL);
+
+    OCStackResult registrationResult =
+        SetPlatformInfo(gPlatformID, gManufacturerName, gManufacturerLink, gModelNumber,
+                        gDateOfManufacture, gPlatformVersion, gOperatingSystemVersion,
+                        gHardwareVersion, gFirmwareVersion, gSupportLink, gSystemTime);
+
+    if (registrationResult != OC_STACK_OK)
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "Platform info setting failed locally!");
+        exit (EXIT_FAILURE);
+    }
+
+    registrationResult = OCSetPlatformInfo(platformInfo);
+
+    if (registrationResult != OC_STACK_OK)
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "Platform Registration failed!");
+        exit (EXIT_FAILURE);
+    }
+
+    registrationResult = SetDeviceInfo();
+
+    if (registrationResult != OC_STACK_OK)
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "Device Registration failed!");
+        exit (EXIT_FAILURE);
+    }
+
+    /*
+     * Declare and create the example resource: Light
+     */
+    createLightResource(gResourceUri, &Light);
+
+    // Initialize observations data structure for the resource
+    for (uint8_t i = 0; i < SAMPLE_MAX_NUM_OBSERVATIONS; i++)
+    {
+        interestedObservers[i].valid = false;
+    }
+
+
+    /*
+     * Create a thread for generating changes that cause presence notifications
+     * to be sent to clients
+     */
+    #ifdef WITH_PRESENCE
+    pthread_create(&threadId_presence, NULL, presenceNotificationGenerator, (void *)NULL);
+    #endif
+
+    // Break from loop with Ctrl-C
+    OCSAMPLE_LOG_INFO(TAG, 0, "Entering ocserver main loop...");
+
+    DeletePlatformInfo();
+
+    signal(SIGINT, handleSigInt);
+
+    pthread_create(&threadId_server, NULL, serverStarter, (void *)NULL);
+    g_main_loop_run(mainloop);
+
+    if (observeThreadStarted)
+    {
+#ifdef HAVE_PTHREAD_H
+        pthread_cancel(threadId_observe);
+        pthread_join(threadId_observe, NULL);
+#endif
+    }
+
+#ifdef HAVE_PTHREAD_H
+    pthread_cancel(threadId_presence);
+    pthread_join(threadId_presence, NULL);
+#endif
+
+    OCSAMPLE_LOG_INFO(TAG, 0, "Exiting ocserver main loop...");
+
+    if (OCStop() != OC_STACK_OK)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "OCStack process error");
+    }
+
+    return 0;
+}
diff --git a/resource/csdk/stack/samples/webos/unsecure/ocserver/ocserver.h b/resource/csdk/stack/samples/webos/unsecure/ocserver/ocserver.h
new file mode 100644
index 0000000..fc93713
--- /dev/null
+++ b/resource/csdk/stack/samples/webos/unsecure/ocserver/ocserver.h
@@ -0,0 +1,130 @@
+/*******************************************************************
+ *
+ * Copyright (c) 2018 LG Electronics, Inc.
+ * Copyright 2014 Intel Mobile Communications GmbH All Rights Reserved.
+ *
+ *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+ */
+
+#ifndef OCSERVER_H_
+#define OCSERVER_H_
+
+#include "ocstack.h"
+
+//-----------------------------------------------------------------------------
+// Defines
+//-----------------------------------------------------------------------------
+#define TAG "ocserver"
+#define SAMPLE_MAX_NUM_OBSERVATIONS     8
+#define SAMPLE_MAX_NUM_POST_INSTANCE  2
+#define SAMPLE_MAX_STR_BUFF_SIZE  100
+
+//-----------------------------------------------------------------------------
+// Typedefs
+//-----------------------------------------------------------------------------
+
+/* Structure to represent a Light resource */
+typedef struct LIGHTRESOURCE
+{
+    OCResourceHandle handle;
+    bool state;
+    int64_t power;
+} LightResource;
+
+/* Structure to represent the observers */
+typedef struct
+{
+    OCObservationId observationId;
+    bool valid;
+    OCResourceHandle resourceHandle;
+} Observers;
+
+typedef enum
+{
+    DISPLAY_SUPPORTED_EPS_FLAG        = 0,
+    CREATE_RESOURCE_OC_ALL,
+    CREATE_RESOURCE_OC_COAP,
+    CREATE_RESOURCE_OC_COAP_TCP,
+    CREATE_RESOURCE_OC_COAP_WITH_TCP,
+    ENDPOINT_OPT_NONE
+} EndpointOption;
+//-----------------------------------------------------------------------------
+// Function prototype
+//-----------------------------------------------------------------------------
+
+/* call getResult in common.cpp to get the result in string format. */
+const char *getResult(OCStackResult result);
+
+/* Function that creates a new Light resource by calling the
+ * OCCreateResource() method.
+ */
+int createLightResource (char *uri, LightResource *lightResource);
+
+/* This method constructs a response from the request */
+OCRepPayload* constructResponse (OCEntityHandlerRequest *ehRequest);
+
+/* This method changes the Light power using an independent thread
+ * and notifies the observers of new state of the resource.
+ */
+void *ChangeLightRepresentation (void *param);
+
+/* This method check the validity of resourceTypeName and resource interfaces
+ * Entity Handler has to parse the query string in order to process it
+ */
+OCEntityHandlerResult ValidateQueryParams (OCEntityHandlerRequest *entityHandlerRequest);
+
+/* Following methods process the PUT, GET, POST, Delete,
+ * & Observe requests */
+OCEntityHandlerResult ProcessGetRequest (OCEntityHandlerRequest *ehRequest,
+                                         OCRepPayload **payload);
+OCEntityHandlerResult ProcessPutRequest (OCEntityHandlerRequest *ehRequest,
+                                         OCRepPayload **payload);
+OCEntityHandlerResult ProcessPostRequest (OCEntityHandlerRequest *ehRequest,
+                                          OCEntityHandlerResponse *response,
+                                         OCRepPayload **payload);
+OCEntityHandlerResult ProcessDeleteRequest (OCEntityHandlerRequest *ehRequest);
+
+OCEntityHandlerResult ProcessNonExistingResourceRequest (OCEntityHandlerRequest *ehRequest);
+
+void ProcessObserveRegister (OCEntityHandlerRequest *ehRequest);
+void ProcessObserveDeregister (OCEntityHandlerRequest *ehRequest);
+
+void DeleteDeviceInfo();
+
+OCStackResult SetDeviceInfo(const char *contentType, const char *dateOfManufacture,
+                const char *deviceName, const char *deviceUUID, const char *firmwareVersion,
+                const char *hostName, const char *manufacturerName, const char *manufacturerUrl,
+                const char *modelNumber, const char *platformVersion, const char *supportUrl,
+                const char *version);
+
+
+//-----------------------------------------------------------------------------
+// Callback functions
+//-----------------------------------------------------------------------------
+
+/* Entity Handler callback functions */
+OCEntityHandlerResult
+OCDeviceEntityHandlerCb (OCEntityHandlerFlag flag,
+        OCEntityHandlerRequest *entityHandlerRequest, char* uri);
+
+OCEntityHandlerResult
+OCEntityHandlerCb (OCEntityHandlerFlag flag,
+        OCEntityHandlerRequest *entityHandlerRequest);
+
+
+#endif
+
diff --git a/resource/provisioning/SConscript b/resource/provisioning/SConscript
index f0a6f09..388d4e5 100644
--- a/resource/provisioning/SConscript
+++ b/resource/provisioning/SConscript
@@ -68,7 +68,7 @@ if target_os == 'android':
         'log'
     ])
 
-if target_os in ['linux', 'tizen']:
+if target_os in ['linux', 'tizen', 'webos']:
     ocprovision_env.AppendUnique(LIBS=[
         'oc',
         'octbstack',
@@ -109,5 +109,5 @@ ocprovision_env.UserInstallTargetLib(ocprovision, 'libocprovision')
 ocprovision_env.UserInstallTargetHeader(
     '../include/OCProvisioningManager.hpp', 'resource', 'OCProvisioningManager.hpp')
 
-if target_os in ['linux', 'tizen']:
+if target_os in ['linux', 'tizen', 'webos']:
     SConscript('examples/SConscript')
diff --git a/resource/src/SConscript b/resource/src/SConscript
index e5d6366..457a80e 100644
--- a/resource/src/SConscript
+++ b/resource/src/SConscript
@@ -79,7 +79,7 @@ if target_os == 'android':
 
 if target_os == 'tizen':
     oclib_env.AppendUnique(CPPDEFINES=['__TIZEN__'])
-if target_os in ['linux', 'tizen']:
+if target_os in ['linux', 'tizen', 'webos']:
     oclib_env.ParseConfig('pkg-config --cflags --libs sqlite3')
 
 if target_os in ['linux'] and oclib_env.get('SIMULATOR', False):
@@ -197,5 +197,5 @@ if with_cloud:
         header_dir + 'OCAccountManager.h', 'resource', 'OCAccountManager.h')
 
 # Add Provisioning library
-if target_os in ['linux', 'android', 'tizen', 'ios', 'windows'] and secured == '1':
+if target_os in ['linux', 'android', 'tizen', 'ios', 'windows', 'webos'] and secured == '1':
     SConscript('../provisioning/SConscript')
-- 
1.9.1

